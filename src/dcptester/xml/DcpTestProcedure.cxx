// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "DcpTestProcedure.hxx"

namespace DcpTestSuite
{
  // DcpTestProcedure
  // 

  const DcpTestProcedure::TransportProtocols_type& DcpTestProcedure::
  TransportProtocols () const
  {
    return this->TransportProtocols_.get ();
  }

  DcpTestProcedure::TransportProtocols_type& DcpTestProcedure::
  TransportProtocols ()
  {
    return this->TransportProtocols_.get ();
  }

  void DcpTestProcedure::
  TransportProtocols (const TransportProtocols_type& x)
  {
    this->TransportProtocols_.set (x);
  }

  void DcpTestProcedure::
  TransportProtocols (::std::auto_ptr< TransportProtocols_type > x)
  {
    this->TransportProtocols_.set (x);
  }

  const DcpTestProcedure::Transition_sequence& DcpTestProcedure::
  Transition () const
  {
    return this->Transition_;
  }

  DcpTestProcedure::Transition_sequence& DcpTestProcedure::
  Transition ()
  {
    return this->Transition_;
  }

  void DcpTestProcedure::
  Transition (const Transition_sequence& s)
  {
    this->Transition_ = s;
  }

  const DcpTestProcedure::version_type& DcpTestProcedure::
  version () const
  {
    return this->version_.get ();
  }

  DcpTestProcedure::version_type& DcpTestProcedure::
  version ()
  {
    return this->version_.get ();
  }

  void DcpTestProcedure::
  version (const version_type& x)
  {
    this->version_.set (x);
  }

  const DcpTestProcedure::name_optional& DcpTestProcedure::
  name () const
  {
    return this->name_;
  }

  DcpTestProcedure::name_optional& DcpTestProcedure::
  name ()
  {
    return this->name_;
  }

  void DcpTestProcedure::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void DcpTestProcedure::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void DcpTestProcedure::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const DcpTestProcedure::acceptingSteps_optional& DcpTestProcedure::
  acceptingSteps () const
  {
    return this->acceptingSteps_;
  }

  DcpTestProcedure::acceptingSteps_optional& DcpTestProcedure::
  acceptingSteps ()
  {
    return this->acceptingSteps_;
  }

  void DcpTestProcedure::
  acceptingSteps (const acceptingSteps_type& x)
  {
    this->acceptingSteps_.set (x);
  }

  void DcpTestProcedure::
  acceptingSteps (const acceptingSteps_optional& x)
  {
    this->acceptingSteps_ = x;
  }

  void DcpTestProcedure::
  acceptingSteps (::std::auto_ptr< acceptingSteps_type > x)
  {
    this->acceptingSteps_.set (x);
  }


  // SendingPayloadField
  // 

  const SendingPayloadField::Int8_optional& SendingPayloadField::
  Int8 () const
  {
    return this->Int8_;
  }

  SendingPayloadField::Int8_optional& SendingPayloadField::
  Int8 ()
  {
    return this->Int8_;
  }

  void SendingPayloadField::
  Int8 (const Int8_type& x)
  {
    this->Int8_.set (x);
  }

  void SendingPayloadField::
  Int8 (const Int8_optional& x)
  {
    this->Int8_ = x;
  }

  void SendingPayloadField::
  Int8 (::std::auto_ptr< Int8_type > x)
  {
    this->Int8_.set (x);
  }

  const SendingPayloadField::Int16_optional& SendingPayloadField::
  Int16 () const
  {
    return this->Int16_;
  }

  SendingPayloadField::Int16_optional& SendingPayloadField::
  Int16 ()
  {
    return this->Int16_;
  }

  void SendingPayloadField::
  Int16 (const Int16_type& x)
  {
    this->Int16_.set (x);
  }

  void SendingPayloadField::
  Int16 (const Int16_optional& x)
  {
    this->Int16_ = x;
  }

  void SendingPayloadField::
  Int16 (::std::auto_ptr< Int16_type > x)
  {
    this->Int16_.set (x);
  }

  const SendingPayloadField::Int32_optional& SendingPayloadField::
  Int32 () const
  {
    return this->Int32_;
  }

  SendingPayloadField::Int32_optional& SendingPayloadField::
  Int32 ()
  {
    return this->Int32_;
  }

  void SendingPayloadField::
  Int32 (const Int32_type& x)
  {
    this->Int32_.set (x);
  }

  void SendingPayloadField::
  Int32 (const Int32_optional& x)
  {
    this->Int32_ = x;
  }

  void SendingPayloadField::
  Int32 (::std::auto_ptr< Int32_type > x)
  {
    this->Int32_.set (x);
  }

  const SendingPayloadField::Int64_optional& SendingPayloadField::
  Int64 () const
  {
    return this->Int64_;
  }

  SendingPayloadField::Int64_optional& SendingPayloadField::
  Int64 ()
  {
    return this->Int64_;
  }

  void SendingPayloadField::
  Int64 (const Int64_type& x)
  {
    this->Int64_.set (x);
  }

  void SendingPayloadField::
  Int64 (const Int64_optional& x)
  {
    this->Int64_ = x;
  }

  void SendingPayloadField::
  Int64 (::std::auto_ptr< Int64_type > x)
  {
    this->Int64_.set (x);
  }

  const SendingPayloadField::Uint8_optional& SendingPayloadField::
  Uint8 () const
  {
    return this->Uint8_;
  }

  SendingPayloadField::Uint8_optional& SendingPayloadField::
  Uint8 ()
  {
    return this->Uint8_;
  }

  void SendingPayloadField::
  Uint8 (const Uint8_type& x)
  {
    this->Uint8_.set (x);
  }

  void SendingPayloadField::
  Uint8 (const Uint8_optional& x)
  {
    this->Uint8_ = x;
  }

  void SendingPayloadField::
  Uint8 (::std::auto_ptr< Uint8_type > x)
  {
    this->Uint8_.set (x);
  }

  const SendingPayloadField::Uint16_optional& SendingPayloadField::
  Uint16 () const
  {
    return this->Uint16_;
  }

  SendingPayloadField::Uint16_optional& SendingPayloadField::
  Uint16 ()
  {
    return this->Uint16_;
  }

  void SendingPayloadField::
  Uint16 (const Uint16_type& x)
  {
    this->Uint16_.set (x);
  }

  void SendingPayloadField::
  Uint16 (const Uint16_optional& x)
  {
    this->Uint16_ = x;
  }

  void SendingPayloadField::
  Uint16 (::std::auto_ptr< Uint16_type > x)
  {
    this->Uint16_.set (x);
  }

  const SendingPayloadField::Uint32_optional& SendingPayloadField::
  Uint32 () const
  {
    return this->Uint32_;
  }

  SendingPayloadField::Uint32_optional& SendingPayloadField::
  Uint32 ()
  {
    return this->Uint32_;
  }

  void SendingPayloadField::
  Uint32 (const Uint32_type& x)
  {
    this->Uint32_.set (x);
  }

  void SendingPayloadField::
  Uint32 (const Uint32_optional& x)
  {
    this->Uint32_ = x;
  }

  void SendingPayloadField::
  Uint32 (::std::auto_ptr< Uint32_type > x)
  {
    this->Uint32_.set (x);
  }

  const SendingPayloadField::Uint64_optional& SendingPayloadField::
  Uint64 () const
  {
    return this->Uint64_;
  }

  SendingPayloadField::Uint64_optional& SendingPayloadField::
  Uint64 ()
  {
    return this->Uint64_;
  }

  void SendingPayloadField::
  Uint64 (const Uint64_type& x)
  {
    this->Uint64_.set (x);
  }

  void SendingPayloadField::
  Uint64 (const Uint64_optional& x)
  {
    this->Uint64_ = x;
  }

  void SendingPayloadField::
  Uint64 (::std::auto_ptr< Uint64_type > x)
  {
    this->Uint64_.set (x);
  }

  const SendingPayloadField::Float32_optional& SendingPayloadField::
  Float32 () const
  {
    return this->Float32_;
  }

  SendingPayloadField::Float32_optional& SendingPayloadField::
  Float32 ()
  {
    return this->Float32_;
  }

  void SendingPayloadField::
  Float32 (const Float32_type& x)
  {
    this->Float32_.set (x);
  }

  void SendingPayloadField::
  Float32 (const Float32_optional& x)
  {
    this->Float32_ = x;
  }

  void SendingPayloadField::
  Float32 (::std::auto_ptr< Float32_type > x)
  {
    this->Float32_.set (x);
  }

  const SendingPayloadField::Float64_optional& SendingPayloadField::
  Float64 () const
  {
    return this->Float64_;
  }

  SendingPayloadField::Float64_optional& SendingPayloadField::
  Float64 ()
  {
    return this->Float64_;
  }

  void SendingPayloadField::
  Float64 (const Float64_type& x)
  {
    this->Float64_.set (x);
  }

  void SendingPayloadField::
  Float64 (const Float64_optional& x)
  {
    this->Float64_ = x;
  }

  void SendingPayloadField::
  Float64 (::std::auto_ptr< Float64_type > x)
  {
    this->Float64_.set (x);
  }

  const SendingPayloadField::String_optional& SendingPayloadField::
  String () const
  {
    return this->String_;
  }

  SendingPayloadField::String_optional& SendingPayloadField::
  String ()
  {
    return this->String_;
  }

  void SendingPayloadField::
  String (const String_type& x)
  {
    this->String_.set (x);
  }

  void SendingPayloadField::
  String (const String_optional& x)
  {
    this->String_ = x;
  }

  void SendingPayloadField::
  String (::std::auto_ptr< String_type > x)
  {
    this->String_.set (x);
  }

  const SendingPayloadField::Binary_optional& SendingPayloadField::
  Binary () const
  {
    return this->Binary_;
  }

  SendingPayloadField::Binary_optional& SendingPayloadField::
  Binary ()
  {
    return this->Binary_;
  }

  void SendingPayloadField::
  Binary (const Binary_type& x)
  {
    this->Binary_.set (x);
  }

  void SendingPayloadField::
  Binary (const Binary_optional& x)
  {
    this->Binary_ = x;
  }

  void SendingPayloadField::
  Binary (::std::auto_ptr< Binary_type > x)
  {
    this->Binary_.set (x);
  }

  const SendingPayloadField::pos_type& SendingPayloadField::
  pos () const
  {
    return this->pos_.get ();
  }

  SendingPayloadField::pos_type& SendingPayloadField::
  pos ()
  {
    return this->pos_.get ();
  }

  void SendingPayloadField::
  pos (const pos_type& x)
  {
    this->pos_.set (x);
  }


  // ReceivingPayloadField
  // 

  const ReceivingPayloadField::Int8_optional& ReceivingPayloadField::
  Int8 () const
  {
    return this->Int8_;
  }

  ReceivingPayloadField::Int8_optional& ReceivingPayloadField::
  Int8 ()
  {
    return this->Int8_;
  }

  void ReceivingPayloadField::
  Int8 (const Int8_type& x)
  {
    this->Int8_.set (x);
  }

  void ReceivingPayloadField::
  Int8 (const Int8_optional& x)
  {
    this->Int8_ = x;
  }

  void ReceivingPayloadField::
  Int8 (::std::auto_ptr< Int8_type > x)
  {
    this->Int8_.set (x);
  }

  const ReceivingPayloadField::Int16_optional& ReceivingPayloadField::
  Int16 () const
  {
    return this->Int16_;
  }

  ReceivingPayloadField::Int16_optional& ReceivingPayloadField::
  Int16 ()
  {
    return this->Int16_;
  }

  void ReceivingPayloadField::
  Int16 (const Int16_type& x)
  {
    this->Int16_.set (x);
  }

  void ReceivingPayloadField::
  Int16 (const Int16_optional& x)
  {
    this->Int16_ = x;
  }

  void ReceivingPayloadField::
  Int16 (::std::auto_ptr< Int16_type > x)
  {
    this->Int16_.set (x);
  }

  const ReceivingPayloadField::Int32_optional& ReceivingPayloadField::
  Int32 () const
  {
    return this->Int32_;
  }

  ReceivingPayloadField::Int32_optional& ReceivingPayloadField::
  Int32 ()
  {
    return this->Int32_;
  }

  void ReceivingPayloadField::
  Int32 (const Int32_type& x)
  {
    this->Int32_.set (x);
  }

  void ReceivingPayloadField::
  Int32 (const Int32_optional& x)
  {
    this->Int32_ = x;
  }

  void ReceivingPayloadField::
  Int32 (::std::auto_ptr< Int32_type > x)
  {
    this->Int32_.set (x);
  }

  const ReceivingPayloadField::Int64_optional& ReceivingPayloadField::
  Int64 () const
  {
    return this->Int64_;
  }

  ReceivingPayloadField::Int64_optional& ReceivingPayloadField::
  Int64 ()
  {
    return this->Int64_;
  }

  void ReceivingPayloadField::
  Int64 (const Int64_type& x)
  {
    this->Int64_.set (x);
  }

  void ReceivingPayloadField::
  Int64 (const Int64_optional& x)
  {
    this->Int64_ = x;
  }

  void ReceivingPayloadField::
  Int64 (::std::auto_ptr< Int64_type > x)
  {
    this->Int64_.set (x);
  }

  const ReceivingPayloadField::Uint8_optional& ReceivingPayloadField::
  Uint8 () const
  {
    return this->Uint8_;
  }

  ReceivingPayloadField::Uint8_optional& ReceivingPayloadField::
  Uint8 ()
  {
    return this->Uint8_;
  }

  void ReceivingPayloadField::
  Uint8 (const Uint8_type& x)
  {
    this->Uint8_.set (x);
  }

  void ReceivingPayloadField::
  Uint8 (const Uint8_optional& x)
  {
    this->Uint8_ = x;
  }

  void ReceivingPayloadField::
  Uint8 (::std::auto_ptr< Uint8_type > x)
  {
    this->Uint8_.set (x);
  }

  const ReceivingPayloadField::Uint16_optional& ReceivingPayloadField::
  Uint16 () const
  {
    return this->Uint16_;
  }

  ReceivingPayloadField::Uint16_optional& ReceivingPayloadField::
  Uint16 ()
  {
    return this->Uint16_;
  }

  void ReceivingPayloadField::
  Uint16 (const Uint16_type& x)
  {
    this->Uint16_.set (x);
  }

  void ReceivingPayloadField::
  Uint16 (const Uint16_optional& x)
  {
    this->Uint16_ = x;
  }

  void ReceivingPayloadField::
  Uint16 (::std::auto_ptr< Uint16_type > x)
  {
    this->Uint16_.set (x);
  }

  const ReceivingPayloadField::Uint32_optional& ReceivingPayloadField::
  Uint32 () const
  {
    return this->Uint32_;
  }

  ReceivingPayloadField::Uint32_optional& ReceivingPayloadField::
  Uint32 ()
  {
    return this->Uint32_;
  }

  void ReceivingPayloadField::
  Uint32 (const Uint32_type& x)
  {
    this->Uint32_.set (x);
  }

  void ReceivingPayloadField::
  Uint32 (const Uint32_optional& x)
  {
    this->Uint32_ = x;
  }

  void ReceivingPayloadField::
  Uint32 (::std::auto_ptr< Uint32_type > x)
  {
    this->Uint32_.set (x);
  }

  const ReceivingPayloadField::Uint64_optional& ReceivingPayloadField::
  Uint64 () const
  {
    return this->Uint64_;
  }

  ReceivingPayloadField::Uint64_optional& ReceivingPayloadField::
  Uint64 ()
  {
    return this->Uint64_;
  }

  void ReceivingPayloadField::
  Uint64 (const Uint64_type& x)
  {
    this->Uint64_.set (x);
  }

  void ReceivingPayloadField::
  Uint64 (const Uint64_optional& x)
  {
    this->Uint64_ = x;
  }

  void ReceivingPayloadField::
  Uint64 (::std::auto_ptr< Uint64_type > x)
  {
    this->Uint64_.set (x);
  }

  const ReceivingPayloadField::Float32_optional& ReceivingPayloadField::
  Float32 () const
  {
    return this->Float32_;
  }

  ReceivingPayloadField::Float32_optional& ReceivingPayloadField::
  Float32 ()
  {
    return this->Float32_;
  }

  void ReceivingPayloadField::
  Float32 (const Float32_type& x)
  {
    this->Float32_.set (x);
  }

  void ReceivingPayloadField::
  Float32 (const Float32_optional& x)
  {
    this->Float32_ = x;
  }

  void ReceivingPayloadField::
  Float32 (::std::auto_ptr< Float32_type > x)
  {
    this->Float32_.set (x);
  }

  const ReceivingPayloadField::Float64_optional& ReceivingPayloadField::
  Float64 () const
  {
    return this->Float64_;
  }

  ReceivingPayloadField::Float64_optional& ReceivingPayloadField::
  Float64 ()
  {
    return this->Float64_;
  }

  void ReceivingPayloadField::
  Float64 (const Float64_type& x)
  {
    this->Float64_.set (x);
  }

  void ReceivingPayloadField::
  Float64 (const Float64_optional& x)
  {
    this->Float64_ = x;
  }

  void ReceivingPayloadField::
  Float64 (::std::auto_ptr< Float64_type > x)
  {
    this->Float64_.set (x);
  }

  const ReceivingPayloadField::String_optional& ReceivingPayloadField::
  String () const
  {
    return this->String_;
  }

  ReceivingPayloadField::String_optional& ReceivingPayloadField::
  String ()
  {
    return this->String_;
  }

  void ReceivingPayloadField::
  String (const String_type& x)
  {
    this->String_.set (x);
  }

  void ReceivingPayloadField::
  String (const String_optional& x)
  {
    this->String_ = x;
  }

  void ReceivingPayloadField::
  String (::std::auto_ptr< String_type > x)
  {
    this->String_.set (x);
  }

  const ReceivingPayloadField::Binary_optional& ReceivingPayloadField::
  Binary () const
  {
    return this->Binary_;
  }

  ReceivingPayloadField::Binary_optional& ReceivingPayloadField::
  Binary ()
  {
    return this->Binary_;
  }

  void ReceivingPayloadField::
  Binary (const Binary_type& x)
  {
    this->Binary_.set (x);
  }

  void ReceivingPayloadField::
  Binary (const Binary_optional& x)
  {
    this->Binary_ = x;
  }

  void ReceivingPayloadField::
  Binary (::std::auto_ptr< Binary_type > x)
  {
    this->Binary_.set (x);
  }

  const ReceivingPayloadField::pos_type& ReceivingPayloadField::
  pos () const
  {
    return this->pos_.get ();
  }

  ReceivingPayloadField::pos_type& ReceivingPayloadField::
  pos ()
  {
    return this->pos_.get ();
  }

  void ReceivingPayloadField::
  pos (const pos_type& x)
  {
    this->pos_.set (x);
  }


  // TransportProtocols
  // 

  const TransportProtocols::UDP_IPv4_optional& TransportProtocols::
  UDP_IPv4 () const
  {
    return this->UDP_IPv4_;
  }

  TransportProtocols::UDP_IPv4_optional& TransportProtocols::
  UDP_IPv4 ()
  {
    return this->UDP_IPv4_;
  }

  void TransportProtocols::
  UDP_IPv4 (const UDP_IPv4_type& x)
  {
    this->UDP_IPv4_.set (x);
  }

  void TransportProtocols::
  UDP_IPv4 (const UDP_IPv4_optional& x)
  {
    this->UDP_IPv4_ = x;
  }

  void TransportProtocols::
  UDP_IPv4 (::std::auto_ptr< UDP_IPv4_type > x)
  {
    this->UDP_IPv4_.set (x);
  }

  const TransportProtocols::CAN_optional& TransportProtocols::
  CAN () const
  {
    return this->CAN_;
  }

  TransportProtocols::CAN_optional& TransportProtocols::
  CAN ()
  {
    return this->CAN_;
  }

  void TransportProtocols::
  CAN (const CAN_type& x)
  {
    this->CAN_.set (x);
  }

  void TransportProtocols::
  CAN (const CAN_optional& x)
  {
    this->CAN_ = x;
  }

  void TransportProtocols::
  CAN (::std::auto_ptr< CAN_type > x)
  {
    this->CAN_.set (x);
  }

  const TransportProtocols::USB_optional& TransportProtocols::
  USB () const
  {
    return this->USB_;
  }

  TransportProtocols::USB_optional& TransportProtocols::
  USB ()
  {
    return this->USB_;
  }

  void TransportProtocols::
  USB (const USB_type& x)
  {
    this->USB_.set (x);
  }

  void TransportProtocols::
  USB (const USB_optional& x)
  {
    this->USB_ = x;
  }

  void TransportProtocols::
  USB (::std::auto_ptr< USB_type > x)
  {
    this->USB_.set (x);
  }

  const TransportProtocols::Bluetooth_optional& TransportProtocols::
  Bluetooth () const
  {
    return this->Bluetooth_;
  }

  TransportProtocols::Bluetooth_optional& TransportProtocols::
  Bluetooth ()
  {
    return this->Bluetooth_;
  }

  void TransportProtocols::
  Bluetooth (const Bluetooth_type& x)
  {
    this->Bluetooth_.set (x);
  }

  void TransportProtocols::
  Bluetooth (const Bluetooth_optional& x)
  {
    this->Bluetooth_ = x;
  }

  void TransportProtocols::
  Bluetooth (::std::auto_ptr< Bluetooth_type > x)
  {
    this->Bluetooth_.set (x);
  }

  const TransportProtocols::TCP_IPv4_optional& TransportProtocols::
  TCP_IPv4 () const
  {
    return this->TCP_IPv4_;
  }

  TransportProtocols::TCP_IPv4_optional& TransportProtocols::
  TCP_IPv4 ()
  {
    return this->TCP_IPv4_;
  }

  void TransportProtocols::
  TCP_IPv4 (const TCP_IPv4_type& x)
  {
    this->TCP_IPv4_.set (x);
  }

  void TransportProtocols::
  TCP_IPv4 (const TCP_IPv4_optional& x)
  {
    this->TCP_IPv4_ = x;
  }

  void TransportProtocols::
  TCP_IPv4 (::std::auto_ptr< TCP_IPv4_type > x)
  {
    this->TCP_IPv4_.set (x);
  }


  // Transition
  // 

  const Transition::Sending_optional& Transition::
  Sending () const
  {
    return this->Sending_;
  }

  Transition::Sending_optional& Transition::
  Sending ()
  {
    return this->Sending_;
  }

  void Transition::
  Sending (const Sending_type& x)
  {
    this->Sending_.set (x);
  }

  void Transition::
  Sending (const Sending_optional& x)
  {
    this->Sending_ = x;
  }

  void Transition::
  Sending (::std::auto_ptr< Sending_type > x)
  {
    this->Sending_.set (x);
  }

  const Transition::Receiving_optional& Transition::
  Receiving () const
  {
    return this->Receiving_;
  }

  Transition::Receiving_optional& Transition::
  Receiving ()
  {
    return this->Receiving_;
  }

  void Transition::
  Receiving (const Receiving_type& x)
  {
    this->Receiving_.set (x);
  }

  void Transition::
  Receiving (const Receiving_optional& x)
  {
    this->Receiving_ = x;
  }

  void Transition::
  Receiving (::std::auto_ptr< Receiving_type > x)
  {
    this->Receiving_.set (x);
  }

  const Transition::from_type& Transition::
  from () const
  {
    return this->from_.get ();
  }

  Transition::from_type& Transition::
  from ()
  {
    return this->from_.get ();
  }

  void Transition::
  from (const from_type& x)
  {
    this->from_.set (x);
  }

  const Transition::to_type& Transition::
  to () const
  {
    return this->to_.get ();
  }

  Transition::to_type& Transition::
  to ()
  {
    return this->to_.get ();
  }

  void Transition::
  to (const to_type& x)
  {
    this->to_.set (x);
  }

  const Transition::log_type& Transition::
  log () const
  {
    return this->log_.get ();
  }

  Transition::log_type& Transition::
  log ()
  {
    return this->log_.get ();
  }

  void Transition::
  log (const log_type& x)
  {
    this->log_.set (x);
  }

  Transition::log_type Transition::
  log_default_value ()
  {
    return log_type (false);
  }


  // acceptingSteps
  //

  acceptingSteps::
  acceptingSteps ()
  : ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char > (this)
  {
  }

  acceptingSteps::
  acceptingSteps (size_type n, const ::xml_schema::unsigned_int& x)
  : ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char > (n, x, this)
  {
  }

  acceptingSteps::
  acceptingSteps (const acceptingSteps& o,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char > (o, f, this)
  {
  }

  // Int8
  // 

  const Int8::value_type& Int8::
  value () const
  {
    return this->value_.get ();
  }

  Int8::value_type& Int8::
  value ()
  {
    return this->value_.get ();
  }

  void Int8::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void Int8::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }


  // Int16
  // 

  const Int16::value_type& Int16::
  value () const
  {
    return this->value_.get ();
  }

  Int16::value_type& Int16::
  value ()
  {
    return this->value_.get ();
  }

  void Int16::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void Int16::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }


  // Int32
  // 

  const Int32::value_type& Int32::
  value () const
  {
    return this->value_.get ();
  }

  Int32::value_type& Int32::
  value ()
  {
    return this->value_.get ();
  }

  void Int32::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void Int32::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }


  // Int64
  // 

  const Int64::value_type& Int64::
  value () const
  {
    return this->value_.get ();
  }

  Int64::value_type& Int64::
  value ()
  {
    return this->value_.get ();
  }

  void Int64::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void Int64::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }


  // Uint8
  // 

  const Uint8::value_type& Uint8::
  value () const
  {
    return this->value_.get ();
  }

  Uint8::value_type& Uint8::
  value ()
  {
    return this->value_.get ();
  }

  void Uint8::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void Uint8::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }


  // Uint16
  // 

  const Uint16::value_type& Uint16::
  value () const
  {
    return this->value_.get ();
  }

  Uint16::value_type& Uint16::
  value ()
  {
    return this->value_.get ();
  }

  void Uint16::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void Uint16::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }


  // Uint32
  // 

  const Uint32::value_type& Uint32::
  value () const
  {
    return this->value_.get ();
  }

  Uint32::value_type& Uint32::
  value ()
  {
    return this->value_.get ();
  }

  void Uint32::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void Uint32::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }


  // Uint64
  // 

  const Uint64::value_type& Uint64::
  value () const
  {
    return this->value_.get ();
  }

  Uint64::value_type& Uint64::
  value ()
  {
    return this->value_.get ();
  }

  void Uint64::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void Uint64::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }


  // Float32
  // 

  const Float32::value_type& Float32::
  value () const
  {
    return this->value_.get ();
  }

  Float32::value_type& Float32::
  value ()
  {
    return this->value_.get ();
  }

  void Float32::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void Float32::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }


  // Float64
  // 

  const Float64::value_type& Float64::
  value () const
  {
    return this->value_.get ();
  }

  Float64::value_type& Float64::
  value ()
  {
    return this->value_.get ();
  }

  void Float64::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void Float64::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }


  // String
  // 

  const String::value_type& String::
  value () const
  {
    return this->value_.get ();
  }

  String::value_type& String::
  value ()
  {
    return this->value_.get ();
  }

  void String::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void String::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }


  // Binary
  // 

  const Binary::value_type& Binary::
  value () const
  {
    return this->value_.get ();
  }

  Binary::value_type& Binary::
  value ()
  {
    return this->value_.get ();
  }

  void Binary::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void Binary::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }


  // Int81
  // 

  const Int81::min_optional& Int81::
  min () const
  {
    return this->min_;
  }

  Int81::min_optional& Int81::
  min ()
  {
    return this->min_;
  }

  void Int81::
  min (const min_type& x)
  {
    this->min_.set (x);
  }

  void Int81::
  min (const min_optional& x)
  {
    this->min_ = x;
  }

  const Int81::max_optional& Int81::
  max () const
  {
    return this->max_;
  }

  Int81::max_optional& Int81::
  max ()
  {
    return this->max_;
  }

  void Int81::
  max (const max_type& x)
  {
    this->max_.set (x);
  }

  void Int81::
  max (const max_optional& x)
  {
    this->max_ = x;
  }

  const Int81::value_optional& Int81::
  value () const
  {
    return this->value_;
  }

  Int81::value_optional& Int81::
  value ()
  {
    return this->value_;
  }

  void Int81::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void Int81::
  value (const value_optional& x)
  {
    this->value_ = x;
  }

  void Int81::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }

  const Int81::dimensionSize_type& Int81::
  dimensionSize () const
  {
    return this->dimensionSize_.get ();
  }

  Int81::dimensionSize_type& Int81::
  dimensionSize ()
  {
    return this->dimensionSize_.get ();
  }

  void Int81::
  dimensionSize (const dimensionSize_type& x)
  {
    this->dimensionSize_.set (x);
  }

  Int81::dimensionSize_type Int81::
  dimensionSize_default_value ()
  {
    return dimensionSize_type (1ULL);
  }


  // Int161
  // 

  const Int161::min_optional& Int161::
  min () const
  {
    return this->min_;
  }

  Int161::min_optional& Int161::
  min ()
  {
    return this->min_;
  }

  void Int161::
  min (const min_type& x)
  {
    this->min_.set (x);
  }

  void Int161::
  min (const min_optional& x)
  {
    this->min_ = x;
  }

  const Int161::max_optional& Int161::
  max () const
  {
    return this->max_;
  }

  Int161::max_optional& Int161::
  max ()
  {
    return this->max_;
  }

  void Int161::
  max (const max_type& x)
  {
    this->max_.set (x);
  }

  void Int161::
  max (const max_optional& x)
  {
    this->max_ = x;
  }

  const Int161::value_optional& Int161::
  value () const
  {
    return this->value_;
  }

  Int161::value_optional& Int161::
  value ()
  {
    return this->value_;
  }

  void Int161::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void Int161::
  value (const value_optional& x)
  {
    this->value_ = x;
  }

  void Int161::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }

  const Int161::dimensionSize_type& Int161::
  dimensionSize () const
  {
    return this->dimensionSize_.get ();
  }

  Int161::dimensionSize_type& Int161::
  dimensionSize ()
  {
    return this->dimensionSize_.get ();
  }

  void Int161::
  dimensionSize (const dimensionSize_type& x)
  {
    this->dimensionSize_.set (x);
  }

  Int161::dimensionSize_type Int161::
  dimensionSize_default_value ()
  {
    return dimensionSize_type (1ULL);
  }


  // Int321
  // 

  const Int321::min_optional& Int321::
  min () const
  {
    return this->min_;
  }

  Int321::min_optional& Int321::
  min ()
  {
    return this->min_;
  }

  void Int321::
  min (const min_type& x)
  {
    this->min_.set (x);
  }

  void Int321::
  min (const min_optional& x)
  {
    this->min_ = x;
  }

  const Int321::max_optional& Int321::
  max () const
  {
    return this->max_;
  }

  Int321::max_optional& Int321::
  max ()
  {
    return this->max_;
  }

  void Int321::
  max (const max_type& x)
  {
    this->max_.set (x);
  }

  void Int321::
  max (const max_optional& x)
  {
    this->max_ = x;
  }

  const Int321::value_optional& Int321::
  value () const
  {
    return this->value_;
  }

  Int321::value_optional& Int321::
  value ()
  {
    return this->value_;
  }

  void Int321::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void Int321::
  value (const value_optional& x)
  {
    this->value_ = x;
  }

  void Int321::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }

  const Int321::dimensionSize_type& Int321::
  dimensionSize () const
  {
    return this->dimensionSize_.get ();
  }

  Int321::dimensionSize_type& Int321::
  dimensionSize ()
  {
    return this->dimensionSize_.get ();
  }

  void Int321::
  dimensionSize (const dimensionSize_type& x)
  {
    this->dimensionSize_.set (x);
  }

  Int321::dimensionSize_type Int321::
  dimensionSize_default_value ()
  {
    return dimensionSize_type (1ULL);
  }


  // Int641
  // 

  const Int641::min_optional& Int641::
  min () const
  {
    return this->min_;
  }

  Int641::min_optional& Int641::
  min ()
  {
    return this->min_;
  }

  void Int641::
  min (const min_type& x)
  {
    this->min_.set (x);
  }

  void Int641::
  min (const min_optional& x)
  {
    this->min_ = x;
  }

  const Int641::max_optional& Int641::
  max () const
  {
    return this->max_;
  }

  Int641::max_optional& Int641::
  max ()
  {
    return this->max_;
  }

  void Int641::
  max (const max_type& x)
  {
    this->max_.set (x);
  }

  void Int641::
  max (const max_optional& x)
  {
    this->max_ = x;
  }

  const Int641::value_optional& Int641::
  value () const
  {
    return this->value_;
  }

  Int641::value_optional& Int641::
  value ()
  {
    return this->value_;
  }

  void Int641::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void Int641::
  value (const value_optional& x)
  {
    this->value_ = x;
  }

  void Int641::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }

  const Int641::dimensionSize_type& Int641::
  dimensionSize () const
  {
    return this->dimensionSize_.get ();
  }

  Int641::dimensionSize_type& Int641::
  dimensionSize ()
  {
    return this->dimensionSize_.get ();
  }

  void Int641::
  dimensionSize (const dimensionSize_type& x)
  {
    this->dimensionSize_.set (x);
  }

  Int641::dimensionSize_type Int641::
  dimensionSize_default_value ()
  {
    return dimensionSize_type (1ULL);
  }


  // Uint81
  // 

  const Uint81::min_optional& Uint81::
  min () const
  {
    return this->min_;
  }

  Uint81::min_optional& Uint81::
  min ()
  {
    return this->min_;
  }

  void Uint81::
  min (const min_type& x)
  {
    this->min_.set (x);
  }

  void Uint81::
  min (const min_optional& x)
  {
    this->min_ = x;
  }

  const Uint81::max_optional& Uint81::
  max () const
  {
    return this->max_;
  }

  Uint81::max_optional& Uint81::
  max ()
  {
    return this->max_;
  }

  void Uint81::
  max (const max_type& x)
  {
    this->max_.set (x);
  }

  void Uint81::
  max (const max_optional& x)
  {
    this->max_ = x;
  }

  const Uint81::value_optional& Uint81::
  value () const
  {
    return this->value_;
  }

  Uint81::value_optional& Uint81::
  value ()
  {
    return this->value_;
  }

  void Uint81::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void Uint81::
  value (const value_optional& x)
  {
    this->value_ = x;
  }

  void Uint81::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }

  const Uint81::dimensionSize_type& Uint81::
  dimensionSize () const
  {
    return this->dimensionSize_.get ();
  }

  Uint81::dimensionSize_type& Uint81::
  dimensionSize ()
  {
    return this->dimensionSize_.get ();
  }

  void Uint81::
  dimensionSize (const dimensionSize_type& x)
  {
    this->dimensionSize_.set (x);
  }

  Uint81::dimensionSize_type Uint81::
  dimensionSize_default_value ()
  {
    return dimensionSize_type (1ULL);
  }


  // Uint161
  // 

  const Uint161::min_optional& Uint161::
  min () const
  {
    return this->min_;
  }

  Uint161::min_optional& Uint161::
  min ()
  {
    return this->min_;
  }

  void Uint161::
  min (const min_type& x)
  {
    this->min_.set (x);
  }

  void Uint161::
  min (const min_optional& x)
  {
    this->min_ = x;
  }

  const Uint161::max_optional& Uint161::
  max () const
  {
    return this->max_;
  }

  Uint161::max_optional& Uint161::
  max ()
  {
    return this->max_;
  }

  void Uint161::
  max (const max_type& x)
  {
    this->max_.set (x);
  }

  void Uint161::
  max (const max_optional& x)
  {
    this->max_ = x;
  }

  const Uint161::value_optional& Uint161::
  value () const
  {
    return this->value_;
  }

  Uint161::value_optional& Uint161::
  value ()
  {
    return this->value_;
  }

  void Uint161::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void Uint161::
  value (const value_optional& x)
  {
    this->value_ = x;
  }

  void Uint161::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }

  const Uint161::dimensionSize_type& Uint161::
  dimensionSize () const
  {
    return this->dimensionSize_.get ();
  }

  Uint161::dimensionSize_type& Uint161::
  dimensionSize ()
  {
    return this->dimensionSize_.get ();
  }

  void Uint161::
  dimensionSize (const dimensionSize_type& x)
  {
    this->dimensionSize_.set (x);
  }

  Uint161::dimensionSize_type Uint161::
  dimensionSize_default_value ()
  {
    return dimensionSize_type (1ULL);
  }


  // Uint321
  // 

  const Uint321::min_optional& Uint321::
  min () const
  {
    return this->min_;
  }

  Uint321::min_optional& Uint321::
  min ()
  {
    return this->min_;
  }

  void Uint321::
  min (const min_type& x)
  {
    this->min_.set (x);
  }

  void Uint321::
  min (const min_optional& x)
  {
    this->min_ = x;
  }

  const Uint321::max_optional& Uint321::
  max () const
  {
    return this->max_;
  }

  Uint321::max_optional& Uint321::
  max ()
  {
    return this->max_;
  }

  void Uint321::
  max (const max_type& x)
  {
    this->max_.set (x);
  }

  void Uint321::
  max (const max_optional& x)
  {
    this->max_ = x;
  }

  const Uint321::value_optional& Uint321::
  value () const
  {
    return this->value_;
  }

  Uint321::value_optional& Uint321::
  value ()
  {
    return this->value_;
  }

  void Uint321::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void Uint321::
  value (const value_optional& x)
  {
    this->value_ = x;
  }

  void Uint321::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }

  const Uint321::dimensionSize_type& Uint321::
  dimensionSize () const
  {
    return this->dimensionSize_.get ();
  }

  Uint321::dimensionSize_type& Uint321::
  dimensionSize ()
  {
    return this->dimensionSize_.get ();
  }

  void Uint321::
  dimensionSize (const dimensionSize_type& x)
  {
    this->dimensionSize_.set (x);
  }

  Uint321::dimensionSize_type Uint321::
  dimensionSize_default_value ()
  {
    return dimensionSize_type (1ULL);
  }


  // Uint641
  // 

  const Uint641::min_optional& Uint641::
  min () const
  {
    return this->min_;
  }

  Uint641::min_optional& Uint641::
  min ()
  {
    return this->min_;
  }

  void Uint641::
  min (const min_type& x)
  {
    this->min_.set (x);
  }

  void Uint641::
  min (const min_optional& x)
  {
    this->min_ = x;
  }

  const Uint641::max_optional& Uint641::
  max () const
  {
    return this->max_;
  }

  Uint641::max_optional& Uint641::
  max ()
  {
    return this->max_;
  }

  void Uint641::
  max (const max_type& x)
  {
    this->max_.set (x);
  }

  void Uint641::
  max (const max_optional& x)
  {
    this->max_ = x;
  }

  const Uint641::value_optional& Uint641::
  value () const
  {
    return this->value_;
  }

  Uint641::value_optional& Uint641::
  value ()
  {
    return this->value_;
  }

  void Uint641::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void Uint641::
  value (const value_optional& x)
  {
    this->value_ = x;
  }

  void Uint641::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }

  const Uint641::dimensionSize_type& Uint641::
  dimensionSize () const
  {
    return this->dimensionSize_.get ();
  }

  Uint641::dimensionSize_type& Uint641::
  dimensionSize ()
  {
    return this->dimensionSize_.get ();
  }

  void Uint641::
  dimensionSize (const dimensionSize_type& x)
  {
    this->dimensionSize_.set (x);
  }

  Uint641::dimensionSize_type Uint641::
  dimensionSize_default_value ()
  {
    return dimensionSize_type (1ULL);
  }


  // Float321
  // 

  const Float321::min_optional& Float321::
  min () const
  {
    return this->min_;
  }

  Float321::min_optional& Float321::
  min ()
  {
    return this->min_;
  }

  void Float321::
  min (const min_type& x)
  {
    this->min_.set (x);
  }

  void Float321::
  min (const min_optional& x)
  {
    this->min_ = x;
  }

  const Float321::max_optional& Float321::
  max () const
  {
    return this->max_;
  }

  Float321::max_optional& Float321::
  max ()
  {
    return this->max_;
  }

  void Float321::
  max (const max_type& x)
  {
    this->max_.set (x);
  }

  void Float321::
  max (const max_optional& x)
  {
    this->max_ = x;
  }

  const Float321::value_optional& Float321::
  value () const
  {
    return this->value_;
  }

  Float321::value_optional& Float321::
  value ()
  {
    return this->value_;
  }

  void Float321::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void Float321::
  value (const value_optional& x)
  {
    this->value_ = x;
  }

  void Float321::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }

  const Float321::dimensionSize_type& Float321::
  dimensionSize () const
  {
    return this->dimensionSize_.get ();
  }

  Float321::dimensionSize_type& Float321::
  dimensionSize ()
  {
    return this->dimensionSize_.get ();
  }

  void Float321::
  dimensionSize (const dimensionSize_type& x)
  {
    this->dimensionSize_.set (x);
  }

  Float321::dimensionSize_type Float321::
  dimensionSize_default_value ()
  {
    return dimensionSize_type (1ULL);
  }


  // Float641
  // 

  const Float641::min_optional& Float641::
  min () const
  {
    return this->min_;
  }

  Float641::min_optional& Float641::
  min ()
  {
    return this->min_;
  }

  void Float641::
  min (const min_type& x)
  {
    this->min_.set (x);
  }

  void Float641::
  min (const min_optional& x)
  {
    this->min_ = x;
  }

  const Float641::max_optional& Float641::
  max () const
  {
    return this->max_;
  }

  Float641::max_optional& Float641::
  max ()
  {
    return this->max_;
  }

  void Float641::
  max (const max_type& x)
  {
    this->max_.set (x);
  }

  void Float641::
  max (const max_optional& x)
  {
    this->max_ = x;
  }

  const Float641::value_optional& Float641::
  value () const
  {
    return this->value_;
  }

  Float641::value_optional& Float641::
  value ()
  {
    return this->value_;
  }

  void Float641::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void Float641::
  value (const value_optional& x)
  {
    this->value_ = x;
  }

  void Float641::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }

  const Float641::dimensionSize_type& Float641::
  dimensionSize () const
  {
    return this->dimensionSize_.get ();
  }

  Float641::dimensionSize_type& Float641::
  dimensionSize ()
  {
    return this->dimensionSize_.get ();
  }

  void Float641::
  dimensionSize (const dimensionSize_type& x)
  {
    this->dimensionSize_.set (x);
  }

  Float641::dimensionSize_type Float641::
  dimensionSize_default_value ()
  {
    return dimensionSize_type (1ULL);
  }


  // String1
  // 

  const String1::value_optional& String1::
  value () const
  {
    return this->value_;
  }

  String1::value_optional& String1::
  value ()
  {
    return this->value_;
  }

  void String1::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void String1::
  value (const value_optional& x)
  {
    this->value_ = x;
  }

  void String1::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }

  const String1::dimensionSize_type& String1::
  dimensionSize () const
  {
    return this->dimensionSize_.get ();
  }

  const String1::dimensionSize_type& String1::
  dimensionSize_default_value ()
  {
    return dimensionSize_default_value_;
  }


  // Binary1
  // 

  const Binary1::value_optional& Binary1::
  value () const
  {
    return this->value_;
  }

  Binary1::value_optional& Binary1::
  value ()
  {
    return this->value_;
  }

  void Binary1::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void Binary1::
  value (const value_optional& x)
  {
    this->value_ = x;
  }

  void Binary1::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }

  const Binary1::dimensionSize_type& Binary1::
  dimensionSize () const
  {
    return this->dimensionSize_.get ();
  }

  const Binary1::dimensionSize_type& Binary1::
  dimensionSize_default_value ()
  {
    return dimensionSize_default_value_;
  }


  // UDP_IPv4
  // 

  const UDP_IPv4::Control_type& UDP_IPv4::
  Control () const
  {
    return this->Control_.get ();
  }

  UDP_IPv4::Control_type& UDP_IPv4::
  Control ()
  {
    return this->Control_.get ();
  }

  void UDP_IPv4::
  Control (const Control_type& x)
  {
    this->Control_.set (x);
  }

  void UDP_IPv4::
  Control (::std::auto_ptr< Control_type > x)
  {
    this->Control_.set (x);
  }

  const UDP_IPv4::DAT_input_output_optional& UDP_IPv4::
  DAT_input_output () const
  {
    return this->DAT_input_output_;
  }

  UDP_IPv4::DAT_input_output_optional& UDP_IPv4::
  DAT_input_output ()
  {
    return this->DAT_input_output_;
  }

  void UDP_IPv4::
  DAT_input_output (const DAT_input_output_type& x)
  {
    this->DAT_input_output_.set (x);
  }

  void UDP_IPv4::
  DAT_input_output (const DAT_input_output_optional& x)
  {
    this->DAT_input_output_ = x;
  }

  void UDP_IPv4::
  DAT_input_output (::std::auto_ptr< DAT_input_output_type > x)
  {
    this->DAT_input_output_.set (x);
  }

  const UDP_IPv4::DAT_parameter_optional& UDP_IPv4::
  DAT_parameter () const
  {
    return this->DAT_parameter_;
  }

  UDP_IPv4::DAT_parameter_optional& UDP_IPv4::
  DAT_parameter ()
  {
    return this->DAT_parameter_;
  }

  void UDP_IPv4::
  DAT_parameter (const DAT_parameter_type& x)
  {
    this->DAT_parameter_.set (x);
  }

  void UDP_IPv4::
  DAT_parameter (const DAT_parameter_optional& x)
  {
    this->DAT_parameter_ = x;
  }

  void UDP_IPv4::
  DAT_parameter (::std::auto_ptr< DAT_parameter_type > x)
  {
    this->DAT_parameter_.set (x);
  }


  // USB
  // 

  const USB::DataPipe_sequence& USB::
  DataPipe () const
  {
    return this->DataPipe_;
  }

  USB::DataPipe_sequence& USB::
  DataPipe ()
  {
    return this->DataPipe_;
  }

  void USB::
  DataPipe (const DataPipe_sequence& s)
  {
    this->DataPipe_ = s;
  }


  // Bluetooth
  // 

  const Bluetooth::Address_type& Bluetooth::
  Address () const
  {
    return this->Address_.get ();
  }

  Bluetooth::Address_type& Bluetooth::
  Address ()
  {
    return this->Address_.get ();
  }

  void Bluetooth::
  Address (const Address_type& x)
  {
    this->Address_.set (x);
  }

  void Bluetooth::
  Address (::std::auto_ptr< Address_type > x)
  {
    this->Address_.set (x);
  }


  // TCP_IPv4
  // 

  const TCP_IPv4::Control_type& TCP_IPv4::
  Control () const
  {
    return this->Control_.get ();
  }

  TCP_IPv4::Control_type& TCP_IPv4::
  Control ()
  {
    return this->Control_.get ();
  }

  void TCP_IPv4::
  Control (const Control_type& x)
  {
    this->Control_.set (x);
  }

  void TCP_IPv4::
  Control (::std::auto_ptr< Control_type > x)
  {
    this->Control_.set (x);
  }

  const TCP_IPv4::DAT_input_output_optional& TCP_IPv4::
  DAT_input_output () const
  {
    return this->DAT_input_output_;
  }

  TCP_IPv4::DAT_input_output_optional& TCP_IPv4::
  DAT_input_output ()
  {
    return this->DAT_input_output_;
  }

  void TCP_IPv4::
  DAT_input_output (const DAT_input_output_type& x)
  {
    this->DAT_input_output_.set (x);
  }

  void TCP_IPv4::
  DAT_input_output (const DAT_input_output_optional& x)
  {
    this->DAT_input_output_ = x;
  }

  void TCP_IPv4::
  DAT_input_output (::std::auto_ptr< DAT_input_output_type > x)
  {
    this->DAT_input_output_.set (x);
  }

  const TCP_IPv4::DAT_parameter_optional& TCP_IPv4::
  DAT_parameter () const
  {
    return this->DAT_parameter_;
  }

  TCP_IPv4::DAT_parameter_optional& TCP_IPv4::
  DAT_parameter ()
  {
    return this->DAT_parameter_;
  }

  void TCP_IPv4::
  DAT_parameter (const DAT_parameter_type& x)
  {
    this->DAT_parameter_.set (x);
  }

  void TCP_IPv4::
  DAT_parameter (const DAT_parameter_optional& x)
  {
    this->DAT_parameter_ = x;
  }

  void TCP_IPv4::
  DAT_parameter (::std::auto_ptr< DAT_parameter_type > x)
  {
    this->DAT_parameter_.set (x);
  }


  // Sending
  // 

  const Sending::ClockTime_optional& Sending::
  ClockTime () const
  {
    return this->ClockTime_;
  }

  Sending::ClockTime_optional& Sending::
  ClockTime ()
  {
    return this->ClockTime_;
  }

  void Sending::
  ClockTime (const ClockTime_type& x)
  {
    this->ClockTime_.set (x);
  }

  void Sending::
  ClockTime (const ClockTime_optional& x)
  {
    this->ClockTime_ = x;
  }

  void Sending::
  ClockTime (::std::auto_ptr< ClockTime_type > x)
  {
    this->ClockTime_.set (x);
  }

  const Sending::CFG_time_res_optional& Sending::
  CFG_time_res () const
  {
    return this->CFG_time_res_;
  }

  Sending::CFG_time_res_optional& Sending::
  CFG_time_res ()
  {
    return this->CFG_time_res_;
  }

  void Sending::
  CFG_time_res (const CFG_time_res_type& x)
  {
    this->CFG_time_res_.set (x);
  }

  void Sending::
  CFG_time_res (const CFG_time_res_optional& x)
  {
    this->CFG_time_res_ = x;
  }

  void Sending::
  CFG_time_res (::std::auto_ptr< CFG_time_res_type > x)
  {
    this->CFG_time_res_.set (x);
  }

  const Sending::CFG_steps_optional& Sending::
  CFG_steps () const
  {
    return this->CFG_steps_;
  }

  Sending::CFG_steps_optional& Sending::
  CFG_steps ()
  {
    return this->CFG_steps_;
  }

  void Sending::
  CFG_steps (const CFG_steps_type& x)
  {
    this->CFG_steps_.set (x);
  }

  void Sending::
  CFG_steps (const CFG_steps_optional& x)
  {
    this->CFG_steps_ = x;
  }

  void Sending::
  CFG_steps (::std::auto_ptr< CFG_steps_type > x)
  {
    this->CFG_steps_.set (x);
  }

  const Sending::CFG_input_optional& Sending::
  CFG_input () const
  {
    return this->CFG_input_;
  }

  Sending::CFG_input_optional& Sending::
  CFG_input ()
  {
    return this->CFG_input_;
  }

  void Sending::
  CFG_input (const CFG_input_type& x)
  {
    this->CFG_input_.set (x);
  }

  void Sending::
  CFG_input (const CFG_input_optional& x)
  {
    this->CFG_input_ = x;
  }

  void Sending::
  CFG_input (::std::auto_ptr< CFG_input_type > x)
  {
    this->CFG_input_.set (x);
  }

  const Sending::CFG_output_optional& Sending::
  CFG_output () const
  {
    return this->CFG_output_;
  }

  Sending::CFG_output_optional& Sending::
  CFG_output ()
  {
    return this->CFG_output_;
  }

  void Sending::
  CFG_output (const CFG_output_type& x)
  {
    this->CFG_output_.set (x);
  }

  void Sending::
  CFG_output (const CFG_output_optional& x)
  {
    this->CFG_output_ = x;
  }

  void Sending::
  CFG_output (::std::auto_ptr< CFG_output_type > x)
  {
    this->CFG_output_.set (x);
  }

  const Sending::CFG_source_network_information_optional& Sending::
  CFG_source_network_information () const
  {
    return this->CFG_source_network_information_;
  }

  Sending::CFG_source_network_information_optional& Sending::
  CFG_source_network_information ()
  {
    return this->CFG_source_network_information_;
  }

  void Sending::
  CFG_source_network_information (const CFG_source_network_information_type& x)
  {
    this->CFG_source_network_information_.set (x);
  }

  void Sending::
  CFG_source_network_information (const CFG_source_network_information_optional& x)
  {
    this->CFG_source_network_information_ = x;
  }

  void Sending::
  CFG_source_network_information (::std::auto_ptr< CFG_source_network_information_type > x)
  {
    this->CFG_source_network_information_.set (x);
  }

  const Sending::CFG_source_network_information_UDP_IPv4_optional& Sending::
  CFG_source_network_information_UDP_IPv4 () const
  {
    return this->CFG_source_network_information_UDP_IPv4_;
  }

  Sending::CFG_source_network_information_UDP_IPv4_optional& Sending::
  CFG_source_network_information_UDP_IPv4 ()
  {
    return this->CFG_source_network_information_UDP_IPv4_;
  }

  void Sending::
  CFG_source_network_information_UDP_IPv4 (const CFG_source_network_information_UDP_IPv4_type& x)
  {
    this->CFG_source_network_information_UDP_IPv4_.set (x);
  }

  void Sending::
  CFG_source_network_information_UDP_IPv4 (const CFG_source_network_information_UDP_IPv4_optional& x)
  {
    this->CFG_source_network_information_UDP_IPv4_ = x;
  }

  void Sending::
  CFG_source_network_information_UDP_IPv4 (::std::auto_ptr< CFG_source_network_information_UDP_IPv4_type > x)
  {
    this->CFG_source_network_information_UDP_IPv4_.set (x);
  }

  const Sending::CFG_source_network_information_USB_optional& Sending::
  CFG_source_network_information_USB () const
  {
    return this->CFG_source_network_information_USB_;
  }

  Sending::CFG_source_network_information_USB_optional& Sending::
  CFG_source_network_information_USB ()
  {
    return this->CFG_source_network_information_USB_;
  }

  void Sending::
  CFG_source_network_information_USB (const CFG_source_network_information_USB_type& x)
  {
    this->CFG_source_network_information_USB_.set (x);
  }

  void Sending::
  CFG_source_network_information_USB (const CFG_source_network_information_USB_optional& x)
  {
    this->CFG_source_network_information_USB_ = x;
  }

  void Sending::
  CFG_source_network_information_USB (::std::auto_ptr< CFG_source_network_information_USB_type > x)
  {
    this->CFG_source_network_information_USB_.set (x);
  }

  const Sending::CFG_source_network_information_Bluetooth_optional& Sending::
  CFG_source_network_information_Bluetooth () const
  {
    return this->CFG_source_network_information_Bluetooth_;
  }

  Sending::CFG_source_network_information_Bluetooth_optional& Sending::
  CFG_source_network_information_Bluetooth ()
  {
    return this->CFG_source_network_information_Bluetooth_;
  }

  void Sending::
  CFG_source_network_information_Bluetooth (const CFG_source_network_information_Bluetooth_type& x)
  {
    this->CFG_source_network_information_Bluetooth_.set (x);
  }

  void Sending::
  CFG_source_network_information_Bluetooth (const CFG_source_network_information_Bluetooth_optional& x)
  {
    this->CFG_source_network_information_Bluetooth_ = x;
  }

  void Sending::
  CFG_source_network_information_Bluetooth (::std::auto_ptr< CFG_source_network_information_Bluetooth_type > x)
  {
    this->CFG_source_network_information_Bluetooth_.set (x);
  }

  const Sending::CFG_source_network_information_TCP_IPv4_optional& Sending::
  CFG_source_network_information_TCP_IPv4 () const
  {
    return this->CFG_source_network_information_TCP_IPv4_;
  }

  Sending::CFG_source_network_information_TCP_IPv4_optional& Sending::
  CFG_source_network_information_TCP_IPv4 ()
  {
    return this->CFG_source_network_information_TCP_IPv4_;
  }

  void Sending::
  CFG_source_network_information_TCP_IPv4 (const CFG_source_network_information_TCP_IPv4_type& x)
  {
    this->CFG_source_network_information_TCP_IPv4_.set (x);
  }

  void Sending::
  CFG_source_network_information_TCP_IPv4 (const CFG_source_network_information_TCP_IPv4_optional& x)
  {
    this->CFG_source_network_information_TCP_IPv4_ = x;
  }

  void Sending::
  CFG_source_network_information_TCP_IPv4 (::std::auto_ptr< CFG_source_network_information_TCP_IPv4_type > x)
  {
    this->CFG_source_network_information_TCP_IPv4_.set (x);
  }

  const Sending::CFG_target_network_information_optional& Sending::
  CFG_target_network_information () const
  {
    return this->CFG_target_network_information_;
  }

  Sending::CFG_target_network_information_optional& Sending::
  CFG_target_network_information ()
  {
    return this->CFG_target_network_information_;
  }

  void Sending::
  CFG_target_network_information (const CFG_target_network_information_type& x)
  {
    this->CFG_target_network_information_.set (x);
  }

  void Sending::
  CFG_target_network_information (const CFG_target_network_information_optional& x)
  {
    this->CFG_target_network_information_ = x;
  }

  void Sending::
  CFG_target_network_information (::std::auto_ptr< CFG_target_network_information_type > x)
  {
    this->CFG_target_network_information_.set (x);
  }

  const Sending::CFG_target_network_information_UDP_IPv4_optional& Sending::
  CFG_target_network_information_UDP_IPv4 () const
  {
    return this->CFG_target_network_information_UDP_IPv4_;
  }

  Sending::CFG_target_network_information_UDP_IPv4_optional& Sending::
  CFG_target_network_information_UDP_IPv4 ()
  {
    return this->CFG_target_network_information_UDP_IPv4_;
  }

  void Sending::
  CFG_target_network_information_UDP_IPv4 (const CFG_target_network_information_UDP_IPv4_type& x)
  {
    this->CFG_target_network_information_UDP_IPv4_.set (x);
  }

  void Sending::
  CFG_target_network_information_UDP_IPv4 (const CFG_target_network_information_UDP_IPv4_optional& x)
  {
    this->CFG_target_network_information_UDP_IPv4_ = x;
  }

  void Sending::
  CFG_target_network_information_UDP_IPv4 (::std::auto_ptr< CFG_target_network_information_UDP_IPv4_type > x)
  {
    this->CFG_target_network_information_UDP_IPv4_.set (x);
  }

  const Sending::CFG_target_network_information_USB_optional& Sending::
  CFG_target_network_information_USB () const
  {
    return this->CFG_target_network_information_USB_;
  }

  Sending::CFG_target_network_information_USB_optional& Sending::
  CFG_target_network_information_USB ()
  {
    return this->CFG_target_network_information_USB_;
  }

  void Sending::
  CFG_target_network_information_USB (const CFG_target_network_information_USB_type& x)
  {
    this->CFG_target_network_information_USB_.set (x);
  }

  void Sending::
  CFG_target_network_information_USB (const CFG_target_network_information_USB_optional& x)
  {
    this->CFG_target_network_information_USB_ = x;
  }

  void Sending::
  CFG_target_network_information_USB (::std::auto_ptr< CFG_target_network_information_USB_type > x)
  {
    this->CFG_target_network_information_USB_.set (x);
  }

  const Sending::CFG_target_network_information_Bluetooth_optional& Sending::
  CFG_target_network_information_Bluetooth () const
  {
    return this->CFG_target_network_information_Bluetooth_;
  }

  Sending::CFG_target_network_information_Bluetooth_optional& Sending::
  CFG_target_network_information_Bluetooth ()
  {
    return this->CFG_target_network_information_Bluetooth_;
  }

  void Sending::
  CFG_target_network_information_Bluetooth (const CFG_target_network_information_Bluetooth_type& x)
  {
    this->CFG_target_network_information_Bluetooth_.set (x);
  }

  void Sending::
  CFG_target_network_information_Bluetooth (const CFG_target_network_information_Bluetooth_optional& x)
  {
    this->CFG_target_network_information_Bluetooth_ = x;
  }

  void Sending::
  CFG_target_network_information_Bluetooth (::std::auto_ptr< CFG_target_network_information_Bluetooth_type > x)
  {
    this->CFG_target_network_information_Bluetooth_.set (x);
  }

  const Sending::CFG_target_network_information_TCP_IPv4_optional& Sending::
  CFG_target_network_information_TCP_IPv4 () const
  {
    return this->CFG_target_network_information_TCP_IPv4_;
  }

  Sending::CFG_target_network_information_TCP_IPv4_optional& Sending::
  CFG_target_network_information_TCP_IPv4 ()
  {
    return this->CFG_target_network_information_TCP_IPv4_;
  }

  void Sending::
  CFG_target_network_information_TCP_IPv4 (const CFG_target_network_information_TCP_IPv4_type& x)
  {
    this->CFG_target_network_information_TCP_IPv4_.set (x);
  }

  void Sending::
  CFG_target_network_information_TCP_IPv4 (const CFG_target_network_information_TCP_IPv4_optional& x)
  {
    this->CFG_target_network_information_TCP_IPv4_ = x;
  }

  void Sending::
  CFG_target_network_information_TCP_IPv4 (::std::auto_ptr< CFG_target_network_information_TCP_IPv4_type > x)
  {
    this->CFG_target_network_information_TCP_IPv4_.set (x);
  }

  const Sending::CFG_clear_optional& Sending::
  CFG_clear () const
  {
    return this->CFG_clear_;
  }

  Sending::CFG_clear_optional& Sending::
  CFG_clear ()
  {
    return this->CFG_clear_;
  }

  void Sending::
  CFG_clear (const CFG_clear_type& x)
  {
    this->CFG_clear_.set (x);
  }

  void Sending::
  CFG_clear (const CFG_clear_optional& x)
  {
    this->CFG_clear_ = x;
  }

  void Sending::
  CFG_clear (::std::auto_ptr< CFG_clear_type > x)
  {
    this->CFG_clear_.set (x);
  }

  const Sending::CFG_parameter_optional& Sending::
  CFG_parameter () const
  {
    return this->CFG_parameter_;
  }

  Sending::CFG_parameter_optional& Sending::
  CFG_parameter ()
  {
    return this->CFG_parameter_;
  }

  void Sending::
  CFG_parameter (const CFG_parameter_type& x)
  {
    this->CFG_parameter_.set (x);
  }

  void Sending::
  CFG_parameter (const CFG_parameter_optional& x)
  {
    this->CFG_parameter_ = x;
  }

  void Sending::
  CFG_parameter (::std::auto_ptr< CFG_parameter_type > x)
  {
    this->CFG_parameter_.set (x);
  }

  const Sending::CFG_tunable_parameter_optional& Sending::
  CFG_tunable_parameter () const
  {
    return this->CFG_tunable_parameter_;
  }

  Sending::CFG_tunable_parameter_optional& Sending::
  CFG_tunable_parameter ()
  {
    return this->CFG_tunable_parameter_;
  }

  void Sending::
  CFG_tunable_parameter (const CFG_tunable_parameter_type& x)
  {
    this->CFG_tunable_parameter_.set (x);
  }

  void Sending::
  CFG_tunable_parameter (const CFG_tunable_parameter_optional& x)
  {
    this->CFG_tunable_parameter_ = x;
  }

  void Sending::
  CFG_tunable_parameter (::std::auto_ptr< CFG_tunable_parameter_type > x)
  {
    this->CFG_tunable_parameter_.set (x);
  }

  const Sending::CFG_param_network_information_optional& Sending::
  CFG_param_network_information () const
  {
    return this->CFG_param_network_information_;
  }

  Sending::CFG_param_network_information_optional& Sending::
  CFG_param_network_information ()
  {
    return this->CFG_param_network_information_;
  }

  void Sending::
  CFG_param_network_information (const CFG_param_network_information_type& x)
  {
    this->CFG_param_network_information_.set (x);
  }

  void Sending::
  CFG_param_network_information (const CFG_param_network_information_optional& x)
  {
    this->CFG_param_network_information_ = x;
  }

  void Sending::
  CFG_param_network_information (::std::auto_ptr< CFG_param_network_information_type > x)
  {
    this->CFG_param_network_information_.set (x);
  }

  const Sending::CFG_param_network_information_UDP_IPv4_optional& Sending::
  CFG_param_network_information_UDP_IPv4 () const
  {
    return this->CFG_param_network_information_UDP_IPv4_;
  }

  Sending::CFG_param_network_information_UDP_IPv4_optional& Sending::
  CFG_param_network_information_UDP_IPv4 ()
  {
    return this->CFG_param_network_information_UDP_IPv4_;
  }

  void Sending::
  CFG_param_network_information_UDP_IPv4 (const CFG_param_network_information_UDP_IPv4_type& x)
  {
    this->CFG_param_network_information_UDP_IPv4_.set (x);
  }

  void Sending::
  CFG_param_network_information_UDP_IPv4 (const CFG_param_network_information_UDP_IPv4_optional& x)
  {
    this->CFG_param_network_information_UDP_IPv4_ = x;
  }

  void Sending::
  CFG_param_network_information_UDP_IPv4 (::std::auto_ptr< CFG_param_network_information_UDP_IPv4_type > x)
  {
    this->CFG_param_network_information_UDP_IPv4_.set (x);
  }

  const Sending::CFG_param_network_information_USB_optional& Sending::
  CFG_param_network_information_USB () const
  {
    return this->CFG_param_network_information_USB_;
  }

  Sending::CFG_param_network_information_USB_optional& Sending::
  CFG_param_network_information_USB ()
  {
    return this->CFG_param_network_information_USB_;
  }

  void Sending::
  CFG_param_network_information_USB (const CFG_param_network_information_USB_type& x)
  {
    this->CFG_param_network_information_USB_.set (x);
  }

  void Sending::
  CFG_param_network_information_USB (const CFG_param_network_information_USB_optional& x)
  {
    this->CFG_param_network_information_USB_ = x;
  }

  void Sending::
  CFG_param_network_information_USB (::std::auto_ptr< CFG_param_network_information_USB_type > x)
  {
    this->CFG_param_network_information_USB_.set (x);
  }

  const Sending::CFG_param_network_information_Bluetooth_optional& Sending::
  CFG_param_network_information_Bluetooth () const
  {
    return this->CFG_param_network_information_Bluetooth_;
  }

  Sending::CFG_param_network_information_Bluetooth_optional& Sending::
  CFG_param_network_information_Bluetooth ()
  {
    return this->CFG_param_network_information_Bluetooth_;
  }

  void Sending::
  CFG_param_network_information_Bluetooth (const CFG_param_network_information_Bluetooth_type& x)
  {
    this->CFG_param_network_information_Bluetooth_.set (x);
  }

  void Sending::
  CFG_param_network_information_Bluetooth (const CFG_param_network_information_Bluetooth_optional& x)
  {
    this->CFG_param_network_information_Bluetooth_ = x;
  }

  void Sending::
  CFG_param_network_information_Bluetooth (::std::auto_ptr< CFG_param_network_information_Bluetooth_type > x)
  {
    this->CFG_param_network_information_Bluetooth_.set (x);
  }

  const Sending::CFG_param_network_information_TCP_IPv4_optional& Sending::
  CFG_param_network_information_TCP_IPv4 () const
  {
    return this->CFG_param_network_information_TCP_IPv4_;
  }

  Sending::CFG_param_network_information_TCP_IPv4_optional& Sending::
  CFG_param_network_information_TCP_IPv4 ()
  {
    return this->CFG_param_network_information_TCP_IPv4_;
  }

  void Sending::
  CFG_param_network_information_TCP_IPv4 (const CFG_param_network_information_TCP_IPv4_type& x)
  {
    this->CFG_param_network_information_TCP_IPv4_.set (x);
  }

  void Sending::
  CFG_param_network_information_TCP_IPv4 (const CFG_param_network_information_TCP_IPv4_optional& x)
  {
    this->CFG_param_network_information_TCP_IPv4_ = x;
  }

  void Sending::
  CFG_param_network_information_TCP_IPv4 (::std::auto_ptr< CFG_param_network_information_TCP_IPv4_type > x)
  {
    this->CFG_param_network_information_TCP_IPv4_.set (x);
  }

  const Sending::CFG_logging_optional& Sending::
  CFG_logging () const
  {
    return this->CFG_logging_;
  }

  Sending::CFG_logging_optional& Sending::
  CFG_logging ()
  {
    return this->CFG_logging_;
  }

  void Sending::
  CFG_logging (const CFG_logging_type& x)
  {
    this->CFG_logging_.set (x);
  }

  void Sending::
  CFG_logging (const CFG_logging_optional& x)
  {
    this->CFG_logging_ = x;
  }

  void Sending::
  CFG_logging (::std::auto_ptr< CFG_logging_type > x)
  {
    this->CFG_logging_.set (x);
  }

  const Sending::CFG_scope_optional& Sending::
  CFG_scope () const
  {
    return this->CFG_scope_;
  }

  Sending::CFG_scope_optional& Sending::
  CFG_scope ()
  {
    return this->CFG_scope_;
  }

  void Sending::
  CFG_scope (const CFG_scope_type& x)
  {
    this->CFG_scope_.set (x);
  }

  void Sending::
  CFG_scope (const CFG_scope_optional& x)
  {
    this->CFG_scope_ = x;
  }

  void Sending::
  CFG_scope (::std::auto_ptr< CFG_scope_type > x)
  {
    this->CFG_scope_.set (x);
  }

  const Sending::STC_register_optional& Sending::
  STC_register () const
  {
    return this->STC_register_;
  }

  Sending::STC_register_optional& Sending::
  STC_register ()
  {
    return this->STC_register_;
  }

  void Sending::
  STC_register (const STC_register_type& x)
  {
    this->STC_register_.set (x);
  }

  void Sending::
  STC_register (const STC_register_optional& x)
  {
    this->STC_register_ = x;
  }

  void Sending::
  STC_register (::std::auto_ptr< STC_register_type > x)
  {
    this->STC_register_.set (x);
  }

  const Sending::STC_deregister_optional& Sending::
  STC_deregister () const
  {
    return this->STC_deregister_;
  }

  Sending::STC_deregister_optional& Sending::
  STC_deregister ()
  {
    return this->STC_deregister_;
  }

  void Sending::
  STC_deregister (const STC_deregister_type& x)
  {
    this->STC_deregister_.set (x);
  }

  void Sending::
  STC_deregister (const STC_deregister_optional& x)
  {
    this->STC_deregister_ = x;
  }

  void Sending::
  STC_deregister (::std::auto_ptr< STC_deregister_type > x)
  {
    this->STC_deregister_.set (x);
  }

  const Sending::STC_prepare_optional& Sending::
  STC_prepare () const
  {
    return this->STC_prepare_;
  }

  Sending::STC_prepare_optional& Sending::
  STC_prepare ()
  {
    return this->STC_prepare_;
  }

  void Sending::
  STC_prepare (const STC_prepare_type& x)
  {
    this->STC_prepare_.set (x);
  }

  void Sending::
  STC_prepare (const STC_prepare_optional& x)
  {
    this->STC_prepare_ = x;
  }

  void Sending::
  STC_prepare (::std::auto_ptr< STC_prepare_type > x)
  {
    this->STC_prepare_.set (x);
  }

  const Sending::STC_configure_optional& Sending::
  STC_configure () const
  {
    return this->STC_configure_;
  }

  Sending::STC_configure_optional& Sending::
  STC_configure ()
  {
    return this->STC_configure_;
  }

  void Sending::
  STC_configure (const STC_configure_type& x)
  {
    this->STC_configure_.set (x);
  }

  void Sending::
  STC_configure (const STC_configure_optional& x)
  {
    this->STC_configure_ = x;
  }

  void Sending::
  STC_configure (::std::auto_ptr< STC_configure_type > x)
  {
    this->STC_configure_.set (x);
  }

  const Sending::STC_initialize_optional& Sending::
  STC_initialize () const
  {
    return this->STC_initialize_;
  }

  Sending::STC_initialize_optional& Sending::
  STC_initialize ()
  {
    return this->STC_initialize_;
  }

  void Sending::
  STC_initialize (const STC_initialize_type& x)
  {
    this->STC_initialize_.set (x);
  }

  void Sending::
  STC_initialize (const STC_initialize_optional& x)
  {
    this->STC_initialize_ = x;
  }

  void Sending::
  STC_initialize (::std::auto_ptr< STC_initialize_type > x)
  {
    this->STC_initialize_.set (x);
  }

  const Sending::STC_run_optional& Sending::
  STC_run () const
  {
    return this->STC_run_;
  }

  Sending::STC_run_optional& Sending::
  STC_run ()
  {
    return this->STC_run_;
  }

  void Sending::
  STC_run (const STC_run_type& x)
  {
    this->STC_run_.set (x);
  }

  void Sending::
  STC_run (const STC_run_optional& x)
  {
    this->STC_run_ = x;
  }

  void Sending::
  STC_run (::std::auto_ptr< STC_run_type > x)
  {
    this->STC_run_.set (x);
  }

  const Sending::STC_do_step_optional& Sending::
  STC_do_step () const
  {
    return this->STC_do_step_;
  }

  Sending::STC_do_step_optional& Sending::
  STC_do_step ()
  {
    return this->STC_do_step_;
  }

  void Sending::
  STC_do_step (const STC_do_step_type& x)
  {
    this->STC_do_step_.set (x);
  }

  void Sending::
  STC_do_step (const STC_do_step_optional& x)
  {
    this->STC_do_step_ = x;
  }

  void Sending::
  STC_do_step (::std::auto_ptr< STC_do_step_type > x)
  {
    this->STC_do_step_.set (x);
  }

  const Sending::STC_send_outputs_optional& Sending::
  STC_send_outputs () const
  {
    return this->STC_send_outputs_;
  }

  Sending::STC_send_outputs_optional& Sending::
  STC_send_outputs ()
  {
    return this->STC_send_outputs_;
  }

  void Sending::
  STC_send_outputs (const STC_send_outputs_type& x)
  {
    this->STC_send_outputs_.set (x);
  }

  void Sending::
  STC_send_outputs (const STC_send_outputs_optional& x)
  {
    this->STC_send_outputs_ = x;
  }

  void Sending::
  STC_send_outputs (::std::auto_ptr< STC_send_outputs_type > x)
  {
    this->STC_send_outputs_.set (x);
  }

  const Sending::STC_stop_optional& Sending::
  STC_stop () const
  {
    return this->STC_stop_;
  }

  Sending::STC_stop_optional& Sending::
  STC_stop ()
  {
    return this->STC_stop_;
  }

  void Sending::
  STC_stop (const STC_stop_type& x)
  {
    this->STC_stop_.set (x);
  }

  void Sending::
  STC_stop (const STC_stop_optional& x)
  {
    this->STC_stop_ = x;
  }

  void Sending::
  STC_stop (::std::auto_ptr< STC_stop_type > x)
  {
    this->STC_stop_.set (x);
  }

  const Sending::STC_reset_optional& Sending::
  STC_reset () const
  {
    return this->STC_reset_;
  }

  Sending::STC_reset_optional& Sending::
  STC_reset ()
  {
    return this->STC_reset_;
  }

  void Sending::
  STC_reset (const STC_reset_type& x)
  {
    this->STC_reset_.set (x);
  }

  void Sending::
  STC_reset (const STC_reset_optional& x)
  {
    this->STC_reset_ = x;
  }

  void Sending::
  STC_reset (::std::auto_ptr< STC_reset_type > x)
  {
    this->STC_reset_.set (x);
  }

  const Sending::INF_state_optional& Sending::
  INF_state () const
  {
    return this->INF_state_;
  }

  Sending::INF_state_optional& Sending::
  INF_state ()
  {
    return this->INF_state_;
  }

  void Sending::
  INF_state (const INF_state_type& x)
  {
    this->INF_state_.set (x);
  }

  void Sending::
  INF_state (const INF_state_optional& x)
  {
    this->INF_state_ = x;
  }

  void Sending::
  INF_state (::std::auto_ptr< INF_state_type > x)
  {
    this->INF_state_.set (x);
  }

  const Sending::INF_error_optional& Sending::
  INF_error () const
  {
    return this->INF_error_;
  }

  Sending::INF_error_optional& Sending::
  INF_error ()
  {
    return this->INF_error_;
  }

  void Sending::
  INF_error (const INF_error_type& x)
  {
    this->INF_error_.set (x);
  }

  void Sending::
  INF_error (const INF_error_optional& x)
  {
    this->INF_error_ = x;
  }

  void Sending::
  INF_error (::std::auto_ptr< INF_error_type > x)
  {
    this->INF_error_.set (x);
  }

  const Sending::INF_log_optional& Sending::
  INF_log () const
  {
    return this->INF_log_;
  }

  Sending::INF_log_optional& Sending::
  INF_log ()
  {
    return this->INF_log_;
  }

  void Sending::
  INF_log (const INF_log_type& x)
  {
    this->INF_log_.set (x);
  }

  void Sending::
  INF_log (const INF_log_optional& x)
  {
    this->INF_log_ = x;
  }

  void Sending::
  INF_log (::std::auto_ptr< INF_log_type > x)
  {
    this->INF_log_.set (x);
  }

  const Sending::DAT_input_output_optional& Sending::
  DAT_input_output () const
  {
    return this->DAT_input_output_;
  }

  Sending::DAT_input_output_optional& Sending::
  DAT_input_output ()
  {
    return this->DAT_input_output_;
  }

  void Sending::
  DAT_input_output (const DAT_input_output_type& x)
  {
    this->DAT_input_output_.set (x);
  }

  void Sending::
  DAT_input_output (const DAT_input_output_optional& x)
  {
    this->DAT_input_output_ = x;
  }

  void Sending::
  DAT_input_output (::std::auto_ptr< DAT_input_output_type > x)
  {
    this->DAT_input_output_.set (x);
  }

  const Sending::DAT_parameter_optional& Sending::
  DAT_parameter () const
  {
    return this->DAT_parameter_;
  }

  Sending::DAT_parameter_optional& Sending::
  DAT_parameter ()
  {
    return this->DAT_parameter_;
  }

  void Sending::
  DAT_parameter (const DAT_parameter_type& x)
  {
    this->DAT_parameter_.set (x);
  }

  void Sending::
  DAT_parameter (const DAT_parameter_optional& x)
  {
    this->DAT_parameter_ = x;
  }

  void Sending::
  DAT_parameter (::std::auto_ptr< DAT_parameter_type > x)
  {
    this->DAT_parameter_.set (x);
  }


  // Receiving
  // 

  const Receiving::RSP_ack_optional& Receiving::
  RSP_ack () const
  {
    return this->RSP_ack_;
  }

  Receiving::RSP_ack_optional& Receiving::
  RSP_ack ()
  {
    return this->RSP_ack_;
  }

  void Receiving::
  RSP_ack (const RSP_ack_type& x)
  {
    this->RSP_ack_.set (x);
  }

  void Receiving::
  RSP_ack (const RSP_ack_optional& x)
  {
    this->RSP_ack_ = x;
  }

  void Receiving::
  RSP_ack (::std::auto_ptr< RSP_ack_type > x)
  {
    this->RSP_ack_.set (x);
  }

  const Receiving::RSP_error_ack_optional& Receiving::
  RSP_error_ack () const
  {
    return this->RSP_error_ack_;
  }

  Receiving::RSP_error_ack_optional& Receiving::
  RSP_error_ack ()
  {
    return this->RSP_error_ack_;
  }

  void Receiving::
  RSP_error_ack (const RSP_error_ack_type& x)
  {
    this->RSP_error_ack_.set (x);
  }

  void Receiving::
  RSP_error_ack (const RSP_error_ack_optional& x)
  {
    this->RSP_error_ack_ = x;
  }

  void Receiving::
  RSP_error_ack (::std::auto_ptr< RSP_error_ack_type > x)
  {
    this->RSP_error_ack_.set (x);
  }

  const Receiving::RSP_nack_optional& Receiving::
  RSP_nack () const
  {
    return this->RSP_nack_;
  }

  Receiving::RSP_nack_optional& Receiving::
  RSP_nack ()
  {
    return this->RSP_nack_;
  }

  void Receiving::
  RSP_nack (const RSP_nack_type& x)
  {
    this->RSP_nack_.set (x);
  }

  void Receiving::
  RSP_nack (const RSP_nack_optional& x)
  {
    this->RSP_nack_ = x;
  }

  void Receiving::
  RSP_nack (::std::auto_ptr< RSP_nack_type > x)
  {
    this->RSP_nack_.set (x);
  }

  const Receiving::RSP_state_ack_optional& Receiving::
  RSP_state_ack () const
  {
    return this->RSP_state_ack_;
  }

  Receiving::RSP_state_ack_optional& Receiving::
  RSP_state_ack ()
  {
    return this->RSP_state_ack_;
  }

  void Receiving::
  RSP_state_ack (const RSP_state_ack_type& x)
  {
    this->RSP_state_ack_.set (x);
  }

  void Receiving::
  RSP_state_ack (const RSP_state_ack_optional& x)
  {
    this->RSP_state_ack_ = x;
  }

  void Receiving::
  RSP_state_ack (::std::auto_ptr< RSP_state_ack_type > x)
  {
    this->RSP_state_ack_.set (x);
  }

  const Receiving::NTF_state_changed_optional& Receiving::
  NTF_state_changed () const
  {
    return this->NTF_state_changed_;
  }

  Receiving::NTF_state_changed_optional& Receiving::
  NTF_state_changed ()
  {
    return this->NTF_state_changed_;
  }

  void Receiving::
  NTF_state_changed (const NTF_state_changed_type& x)
  {
    this->NTF_state_changed_.set (x);
  }

  void Receiving::
  NTF_state_changed (const NTF_state_changed_optional& x)
  {
    this->NTF_state_changed_ = x;
  }

  void Receiving::
  NTF_state_changed (::std::auto_ptr< NTF_state_changed_type > x)
  {
    this->NTF_state_changed_.set (x);
  }

  const Receiving::RSP_log_ack_optional& Receiving::
  RSP_log_ack () const
  {
    return this->RSP_log_ack_;
  }

  Receiving::RSP_log_ack_optional& Receiving::
  RSP_log_ack ()
  {
    return this->RSP_log_ack_;
  }

  void Receiving::
  RSP_log_ack (const RSP_log_ack_type& x)
  {
    this->RSP_log_ack_.set (x);
  }

  void Receiving::
  RSP_log_ack (const RSP_log_ack_optional& x)
  {
    this->RSP_log_ack_ = x;
  }

  void Receiving::
  RSP_log_ack (::std::auto_ptr< RSP_log_ack_type > x)
  {
    this->RSP_log_ack_.set (x);
  }

  const Receiving::NTF_log_optional& Receiving::
  NTF_log () const
  {
    return this->NTF_log_;
  }

  Receiving::NTF_log_optional& Receiving::
  NTF_log ()
  {
    return this->NTF_log_;
  }

  void Receiving::
  NTF_log (const NTF_log_type& x)
  {
    this->NTF_log_.set (x);
  }

  void Receiving::
  NTF_log (const NTF_log_optional& x)
  {
    this->NTF_log_ = x;
  }

  void Receiving::
  NTF_log (::std::auto_ptr< NTF_log_type > x)
  {
    this->NTF_log_.set (x);
  }

  const Receiving::DAT_input_output_optional& Receiving::
  DAT_input_output () const
  {
    return this->DAT_input_output_;
  }

  Receiving::DAT_input_output_optional& Receiving::
  DAT_input_output ()
  {
    return this->DAT_input_output_;
  }

  void Receiving::
  DAT_input_output (const DAT_input_output_type& x)
  {
    this->DAT_input_output_.set (x);
  }

  void Receiving::
  DAT_input_output (const DAT_input_output_optional& x)
  {
    this->DAT_input_output_ = x;
  }

  void Receiving::
  DAT_input_output (::std::auto_ptr< DAT_input_output_type > x)
  {
    this->DAT_input_output_.set (x);
  }

  const Receiving::DAT_parameter_optional& Receiving::
  DAT_parameter () const
  {
    return this->DAT_parameter_;
  }

  Receiving::DAT_parameter_optional& Receiving::
  DAT_parameter ()
  {
    return this->DAT_parameter_;
  }

  void Receiving::
  DAT_parameter (const DAT_parameter_type& x)
  {
    this->DAT_parameter_.set (x);
  }

  void Receiving::
  DAT_parameter (const DAT_parameter_optional& x)
  {
    this->DAT_parameter_ = x;
  }

  void Receiving::
  DAT_parameter (::std::auto_ptr< DAT_parameter_type > x)
  {
    this->DAT_parameter_.set (x);
  }


  // value
  //

  value::
  value ()
  : ::xsd::cxx::tree::list< ::xml_schema::byte, char > (this)
  {
  }

  value::
  value (size_type n, const ::xml_schema::byte& x)
  : ::xsd::cxx::tree::list< ::xml_schema::byte, char > (n, x, this)
  {
  }

  value::
  value (const value& o,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::byte, char > (o, f, this)
  {
  }

  // value1
  //

  value1::
  value1 ()
  : ::xsd::cxx::tree::list< ::xml_schema::short_, char > (this)
  {
  }

  value1::
  value1 (size_type n, const ::xml_schema::short_& x)
  : ::xsd::cxx::tree::list< ::xml_schema::short_, char > (n, x, this)
  {
  }

  value1::
  value1 (const value1& o,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::short_, char > (o, f, this)
  {
  }

  // value2
  //

  value2::
  value2 ()
  : ::xsd::cxx::tree::list< ::xml_schema::int_, char > (this)
  {
  }

  value2::
  value2 (size_type n, const ::xml_schema::int_& x)
  : ::xsd::cxx::tree::list< ::xml_schema::int_, char > (n, x, this)
  {
  }

  value2::
  value2 (const value2& o,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::int_, char > (o, f, this)
  {
  }

  // value3
  //

  value3::
  value3 ()
  : ::xsd::cxx::tree::list< ::xml_schema::long_, char > (this)
  {
  }

  value3::
  value3 (size_type n, const ::xml_schema::long_& x)
  : ::xsd::cxx::tree::list< ::xml_schema::long_, char > (n, x, this)
  {
  }

  value3::
  value3 (const value3& o,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::long_, char > (o, f, this)
  {
  }

  // value4
  //

  value4::
  value4 ()
  : ::xsd::cxx::tree::list< ::xml_schema::unsigned_byte, char > (this)
  {
  }

  value4::
  value4 (size_type n, const ::xml_schema::unsigned_byte& x)
  : ::xsd::cxx::tree::list< ::xml_schema::unsigned_byte, char > (n, x, this)
  {
  }

  value4::
  value4 (const value4& o,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_byte, char > (o, f, this)
  {
  }

  // value5
  //

  value5::
  value5 ()
  : ::xsd::cxx::tree::list< ::xml_schema::unsigned_short, char > (this)
  {
  }

  value5::
  value5 (size_type n, const ::xml_schema::unsigned_short& x)
  : ::xsd::cxx::tree::list< ::xml_schema::unsigned_short, char > (n, x, this)
  {
  }

  value5::
  value5 (const value5& o,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_short, char > (o, f, this)
  {
  }

  // value6
  //

  value6::
  value6 ()
  : ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char > (this)
  {
  }

  value6::
  value6 (size_type n, const ::xml_schema::unsigned_int& x)
  : ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char > (n, x, this)
  {
  }

  value6::
  value6 (const value6& o,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char > (o, f, this)
  {
  }

  // value7
  //

  value7::
  value7 ()
  : ::xsd::cxx::tree::list< ::xml_schema::unsigned_long, char > (this)
  {
  }

  value7::
  value7 (size_type n, const ::xml_schema::unsigned_long& x)
  : ::xsd::cxx::tree::list< ::xml_schema::unsigned_long, char > (n, x, this)
  {
  }

  value7::
  value7 (const value7& o,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_long, char > (o, f, this)
  {
  }

  // value8
  //

  value8::
  value8 ()
  : ::xsd::cxx::tree::list< ::xml_schema::float_, char > (this)
  {
  }

  value8::
  value8 (size_type n, const ::xml_schema::float_& x)
  : ::xsd::cxx::tree::list< ::xml_schema::float_, char > (n, x, this)
  {
  }

  value8::
  value8 (const value8& o,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::float_, char > (o, f, this)
  {
  }

  // value9
  //

  value9::
  value9 ()
  : ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (this)
  {
  }

  value9::
  value9 (size_type n, const ::xml_schema::double_& x)
  : ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (n, x, this)
  {
  }

  value9::
  value9 (const value9& o,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (o, f, this)
  {
  }

  // value10
  //

  value10::
  value10 ()
  : ::xsd::cxx::tree::list< ::xml_schema::byte, char > (this)
  {
  }

  value10::
  value10 (size_type n, const ::xml_schema::byte& x)
  : ::xsd::cxx::tree::list< ::xml_schema::byte, char > (n, x, this)
  {
  }

  value10::
  value10 (const value10& o,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::byte, char > (o, f, this)
  {
  }

  // value11
  //

  value11::
  value11 ()
  : ::xsd::cxx::tree::list< ::xml_schema::short_, char > (this)
  {
  }

  value11::
  value11 (size_type n, const ::xml_schema::short_& x)
  : ::xsd::cxx::tree::list< ::xml_schema::short_, char > (n, x, this)
  {
  }

  value11::
  value11 (const value11& o,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::short_, char > (o, f, this)
  {
  }

  // value12
  //

  value12::
  value12 ()
  : ::xsd::cxx::tree::list< ::xml_schema::int_, char > (this)
  {
  }

  value12::
  value12 (size_type n, const ::xml_schema::int_& x)
  : ::xsd::cxx::tree::list< ::xml_schema::int_, char > (n, x, this)
  {
  }

  value12::
  value12 (const value12& o,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::int_, char > (o, f, this)
  {
  }

  // value13
  //

  value13::
  value13 ()
  : ::xsd::cxx::tree::list< ::xml_schema::long_, char > (this)
  {
  }

  value13::
  value13 (size_type n, const ::xml_schema::long_& x)
  : ::xsd::cxx::tree::list< ::xml_schema::long_, char > (n, x, this)
  {
  }

  value13::
  value13 (const value13& o,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::long_, char > (o, f, this)
  {
  }

  // value14
  //

  value14::
  value14 ()
  : ::xsd::cxx::tree::list< ::xml_schema::unsigned_byte, char > (this)
  {
  }

  value14::
  value14 (size_type n, const ::xml_schema::unsigned_byte& x)
  : ::xsd::cxx::tree::list< ::xml_schema::unsigned_byte, char > (n, x, this)
  {
  }

  value14::
  value14 (const value14& o,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_byte, char > (o, f, this)
  {
  }

  // value15
  //

  value15::
  value15 ()
  : ::xsd::cxx::tree::list< ::xml_schema::unsigned_short, char > (this)
  {
  }

  value15::
  value15 (size_type n, const ::xml_schema::unsigned_short& x)
  : ::xsd::cxx::tree::list< ::xml_schema::unsigned_short, char > (n, x, this)
  {
  }

  value15::
  value15 (const value15& o,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_short, char > (o, f, this)
  {
  }

  // value16
  //

  value16::
  value16 ()
  : ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char > (this)
  {
  }

  value16::
  value16 (size_type n, const ::xml_schema::unsigned_int& x)
  : ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char > (n, x, this)
  {
  }

  value16::
  value16 (const value16& o,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char > (o, f, this)
  {
  }

  // value17
  //

  value17::
  value17 ()
  : ::xsd::cxx::tree::list< ::xml_schema::unsigned_long, char > (this)
  {
  }

  value17::
  value17 (size_type n, const ::xml_schema::unsigned_long& x)
  : ::xsd::cxx::tree::list< ::xml_schema::unsigned_long, char > (n, x, this)
  {
  }

  value17::
  value17 (const value17& o,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_long, char > (o, f, this)
  {
  }

  // value18
  //

  value18::
  value18 ()
  : ::xsd::cxx::tree::list< ::xml_schema::float_, char > (this)
  {
  }

  value18::
  value18 (size_type n, const ::xml_schema::float_& x)
  : ::xsd::cxx::tree::list< ::xml_schema::float_, char > (n, x, this)
  {
  }

  value18::
  value18 (const value18& o,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::float_, char > (o, f, this)
  {
  }

  // value19
  //

  value19::
  value19 ()
  : ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (this)
  {
  }

  value19::
  value19 (size_type n, const ::xml_schema::double_& x)
  : ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (n, x, this)
  {
  }

  value19::
  value19 (const value19& o,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (o, f, this)
  {
  }

  // Control
  // 

  const Control::host_optional& Control::
  host () const
  {
    return this->host_;
  }

  Control::host_optional& Control::
  host ()
  {
    return this->host_;
  }

  void Control::
  host (const host_type& x)
  {
    this->host_.set (x);
  }

  void Control::
  host (const host_optional& x)
  {
    this->host_ = x;
  }

  void Control::
  host (::std::auto_ptr< host_type > x)
  {
    this->host_.set (x);
  }

  const Control::port_type& Control::
  port () const
  {
    return this->port_.get ();
  }

  Control::port_type& Control::
  port ()
  {
    return this->port_.get ();
  }

  void Control::
  port (const port_type& x)
  {
    this->port_.set (x);
  }


  // DAT_input_output
  // 

  const DAT_input_output::AvailablePortRange_optional& DAT_input_output::
  AvailablePortRange () const
  {
    return this->AvailablePortRange_;
  }

  DAT_input_output::AvailablePortRange_optional& DAT_input_output::
  AvailablePortRange ()
  {
    return this->AvailablePortRange_;
  }

  void DAT_input_output::
  AvailablePortRange (const AvailablePortRange_type& x)
  {
    this->AvailablePortRange_.set (x);
  }

  void DAT_input_output::
  AvailablePortRange (const AvailablePortRange_optional& x)
  {
    this->AvailablePortRange_ = x;
  }

  void DAT_input_output::
  AvailablePortRange (::std::auto_ptr< AvailablePortRange_type > x)
  {
    this->AvailablePortRange_.set (x);
  }

  const DAT_input_output::AvailablePort_optional& DAT_input_output::
  AvailablePort () const
  {
    return this->AvailablePort_;
  }

  DAT_input_output::AvailablePort_optional& DAT_input_output::
  AvailablePort ()
  {
    return this->AvailablePort_;
  }

  void DAT_input_output::
  AvailablePort (const AvailablePort_type& x)
  {
    this->AvailablePort_.set (x);
  }

  void DAT_input_output::
  AvailablePort (const AvailablePort_optional& x)
  {
    this->AvailablePort_ = x;
  }

  void DAT_input_output::
  AvailablePort (::std::auto_ptr< AvailablePort_type > x)
  {
    this->AvailablePort_.set (x);
  }

  const DAT_input_output::host_optional& DAT_input_output::
  host () const
  {
    return this->host_;
  }

  DAT_input_output::host_optional& DAT_input_output::
  host ()
  {
    return this->host_;
  }

  void DAT_input_output::
  host (const host_type& x)
  {
    this->host_.set (x);
  }

  void DAT_input_output::
  host (const host_optional& x)
  {
    this->host_ = x;
  }

  void DAT_input_output::
  host (::std::auto_ptr< host_type > x)
  {
    this->host_.set (x);
  }


  // DAT_parameter
  // 

  const DAT_parameter::AvailablePortRange_optional& DAT_parameter::
  AvailablePortRange () const
  {
    return this->AvailablePortRange_;
  }

  DAT_parameter::AvailablePortRange_optional& DAT_parameter::
  AvailablePortRange ()
  {
    return this->AvailablePortRange_;
  }

  void DAT_parameter::
  AvailablePortRange (const AvailablePortRange_type& x)
  {
    this->AvailablePortRange_.set (x);
  }

  void DAT_parameter::
  AvailablePortRange (const AvailablePortRange_optional& x)
  {
    this->AvailablePortRange_ = x;
  }

  void DAT_parameter::
  AvailablePortRange (::std::auto_ptr< AvailablePortRange_type > x)
  {
    this->AvailablePortRange_.set (x);
  }

  const DAT_parameter::AvailablePort_optional& DAT_parameter::
  AvailablePort () const
  {
    return this->AvailablePort_;
  }

  DAT_parameter::AvailablePort_optional& DAT_parameter::
  AvailablePort ()
  {
    return this->AvailablePort_;
  }

  void DAT_parameter::
  AvailablePort (const AvailablePort_type& x)
  {
    this->AvailablePort_.set (x);
  }

  void DAT_parameter::
  AvailablePort (const AvailablePort_optional& x)
  {
    this->AvailablePort_ = x;
  }

  void DAT_parameter::
  AvailablePort (::std::auto_ptr< AvailablePort_type > x)
  {
    this->AvailablePort_.set (x);
  }

  const DAT_parameter::host_optional& DAT_parameter::
  host () const
  {
    return this->host_;
  }

  DAT_parameter::host_optional& DAT_parameter::
  host ()
  {
    return this->host_;
  }

  void DAT_parameter::
  host (const host_type& x)
  {
    this->host_.set (x);
  }

  void DAT_parameter::
  host (const host_optional& x)
  {
    this->host_ = x;
  }

  void DAT_parameter::
  host (::std::auto_ptr< host_type > x)
  {
    this->host_.set (x);
  }


  // DataPipe
  // 

  const DataPipe::direction_optional& DataPipe::
  direction () const
  {
    return this->direction_;
  }

  DataPipe::direction_optional& DataPipe::
  direction ()
  {
    return this->direction_;
  }

  void DataPipe::
  direction (const direction_type& x)
  {
    this->direction_.set (x);
  }

  void DataPipe::
  direction (const direction_optional& x)
  {
    this->direction_ = x;
  }

  void DataPipe::
  direction (::std::auto_ptr< direction_type > x)
  {
    this->direction_.set (x);
  }

  const DataPipe::endpointAddress_type& DataPipe::
  endpointAddress () const
  {
    return this->endpointAddress_.get ();
  }

  DataPipe::endpointAddress_type& DataPipe::
  endpointAddress ()
  {
    return this->endpointAddress_.get ();
  }

  void DataPipe::
  endpointAddress (const endpointAddress_type& x)
  {
    this->endpointAddress_.set (x);
  }

  const DataPipe::intervall_type& DataPipe::
  intervall () const
  {
    return this->intervall_.get ();
  }

  DataPipe::intervall_type& DataPipe::
  intervall ()
  {
    return this->intervall_.get ();
  }

  void DataPipe::
  intervall (const intervall_type& x)
  {
    this->intervall_.set (x);
  }


  // Address
  // 

  const Address::bd_addr_type& Address::
  bd_addr () const
  {
    return this->bd_addr_.get ();
  }

  Address::bd_addr_type& Address::
  bd_addr ()
  {
    return this->bd_addr_.get ();
  }

  void Address::
  bd_addr (const bd_addr_type& x)
  {
    this->bd_addr_.set (x);
  }

  void Address::
  bd_addr (::std::auto_ptr< bd_addr_type > x)
  {
    this->bd_addr_.set (x);
  }

  const Address::port_type& Address::
  port () const
  {
    return this->port_.get ();
  }

  Address::port_type& Address::
  port ()
  {
    return this->port_.get ();
  }

  void Address::
  port (const port_type& x)
  {
    this->port_.set (x);
  }

  void Address::
  port (::std::auto_ptr< port_type > x)
  {
    this->port_.set (x);
  }

  const Address::alias_optional& Address::
  alias () const
  {
    return this->alias_;
  }

  Address::alias_optional& Address::
  alias ()
  {
    return this->alias_;
  }

  void Address::
  alias (const alias_type& x)
  {
    this->alias_.set (x);
  }

  void Address::
  alias (const alias_optional& x)
  {
    this->alias_ = x;
  }

  void Address::
  alias (::std::auto_ptr< alias_type > x)
  {
    this->alias_.set (x);
  }


  // DAT_input_output1
  // 

  const DAT_input_output1::AvailablePortRange_optional& DAT_input_output1::
  AvailablePortRange () const
  {
    return this->AvailablePortRange_;
  }

  DAT_input_output1::AvailablePortRange_optional& DAT_input_output1::
  AvailablePortRange ()
  {
    return this->AvailablePortRange_;
  }

  void DAT_input_output1::
  AvailablePortRange (const AvailablePortRange_type& x)
  {
    this->AvailablePortRange_.set (x);
  }

  void DAT_input_output1::
  AvailablePortRange (const AvailablePortRange_optional& x)
  {
    this->AvailablePortRange_ = x;
  }

  void DAT_input_output1::
  AvailablePortRange (::std::auto_ptr< AvailablePortRange_type > x)
  {
    this->AvailablePortRange_.set (x);
  }

  const DAT_input_output1::AvailablePort_optional& DAT_input_output1::
  AvailablePort () const
  {
    return this->AvailablePort_;
  }

  DAT_input_output1::AvailablePort_optional& DAT_input_output1::
  AvailablePort ()
  {
    return this->AvailablePort_;
  }

  void DAT_input_output1::
  AvailablePort (const AvailablePort_type& x)
  {
    this->AvailablePort_.set (x);
  }

  void DAT_input_output1::
  AvailablePort (const AvailablePort_optional& x)
  {
    this->AvailablePort_ = x;
  }

  void DAT_input_output1::
  AvailablePort (::std::auto_ptr< AvailablePort_type > x)
  {
    this->AvailablePort_.set (x);
  }

  const DAT_input_output1::host_optional& DAT_input_output1::
  host () const
  {
    return this->host_;
  }

  DAT_input_output1::host_optional& DAT_input_output1::
  host ()
  {
    return this->host_;
  }

  void DAT_input_output1::
  host (const host_type& x)
  {
    this->host_.set (x);
  }

  void DAT_input_output1::
  host (const host_optional& x)
  {
    this->host_ = x;
  }

  void DAT_input_output1::
  host (::std::auto_ptr< host_type > x)
  {
    this->host_.set (x);
  }


  // DAT_parameter1
  // 

  const DAT_parameter1::AvailablePortRange_optional& DAT_parameter1::
  AvailablePortRange () const
  {
    return this->AvailablePortRange_;
  }

  DAT_parameter1::AvailablePortRange_optional& DAT_parameter1::
  AvailablePortRange ()
  {
    return this->AvailablePortRange_;
  }

  void DAT_parameter1::
  AvailablePortRange (const AvailablePortRange_type& x)
  {
    this->AvailablePortRange_.set (x);
  }

  void DAT_parameter1::
  AvailablePortRange (const AvailablePortRange_optional& x)
  {
    this->AvailablePortRange_ = x;
  }

  void DAT_parameter1::
  AvailablePortRange (::std::auto_ptr< AvailablePortRange_type > x)
  {
    this->AvailablePortRange_.set (x);
  }

  const DAT_parameter1::AvailablePort_optional& DAT_parameter1::
  AvailablePort () const
  {
    return this->AvailablePort_;
  }

  DAT_parameter1::AvailablePort_optional& DAT_parameter1::
  AvailablePort ()
  {
    return this->AvailablePort_;
  }

  void DAT_parameter1::
  AvailablePort (const AvailablePort_type& x)
  {
    this->AvailablePort_.set (x);
  }

  void DAT_parameter1::
  AvailablePort (const AvailablePort_optional& x)
  {
    this->AvailablePort_ = x;
  }

  void DAT_parameter1::
  AvailablePort (::std::auto_ptr< AvailablePort_type > x)
  {
    this->AvailablePort_.set (x);
  }

  const DAT_parameter1::host_optional& DAT_parameter1::
  host () const
  {
    return this->host_;
  }

  DAT_parameter1::host_optional& DAT_parameter1::
  host ()
  {
    return this->host_;
  }

  void DAT_parameter1::
  host (const host_type& x)
  {
    this->host_.set (x);
  }

  void DAT_parameter1::
  host (const host_optional& x)
  {
    this->host_ = x;
  }

  void DAT_parameter1::
  host (::std::auto_ptr< host_type > x)
  {
    this->host_.set (x);
  }


  // ClockTime
  // 

  const ClockTime::numerator_type& ClockTime::
  numerator () const
  {
    return this->numerator_.get ();
  }

  ClockTime::numerator_type& ClockTime::
  numerator ()
  {
    return this->numerator_.get ();
  }

  void ClockTime::
  numerator (const numerator_type& x)
  {
    this->numerator_.set (x);
  }

  const ClockTime::denominator_type& ClockTime::
  denominator () const
  {
    return this->denominator_.get ();
  }

  ClockTime::denominator_type& ClockTime::
  denominator ()
  {
    return this->denominator_.get ();
  }

  void ClockTime::
  denominator (const denominator_type& x)
  {
    this->denominator_.set (x);
  }


  // CFG_time_res
  // 

  const CFG_time_res::receiver_type& CFG_time_res::
  receiver () const
  {
    return this->receiver_.get ();
  }

  CFG_time_res::receiver_type& CFG_time_res::
  receiver ()
  {
    return this->receiver_.get ();
  }

  void CFG_time_res::
  receiver (const receiver_type& x)
  {
    this->receiver_.set (x);
  }

  const CFG_time_res::numerator_type& CFG_time_res::
  numerator () const
  {
    return this->numerator_.get ();
  }

  CFG_time_res::numerator_type& CFG_time_res::
  numerator ()
  {
    return this->numerator_.get ();
  }

  void CFG_time_res::
  numerator (const numerator_type& x)
  {
    this->numerator_.set (x);
  }

  const CFG_time_res::denominator_type& CFG_time_res::
  denominator () const
  {
    return this->denominator_.get ();
  }

  CFG_time_res::denominator_type& CFG_time_res::
  denominator ()
  {
    return this->denominator_.get ();
  }

  void CFG_time_res::
  denominator (const denominator_type& x)
  {
    this->denominator_.set (x);
  }


  // CFG_steps
  // 

  const CFG_steps::receiver_type& CFG_steps::
  receiver () const
  {
    return this->receiver_.get ();
  }

  CFG_steps::receiver_type& CFG_steps::
  receiver ()
  {
    return this->receiver_.get ();
  }

  void CFG_steps::
  receiver (const receiver_type& x)
  {
    this->receiver_.set (x);
  }

  const CFG_steps::data_id_type& CFG_steps::
  data_id () const
  {
    return this->data_id_.get ();
  }

  CFG_steps::data_id_type& CFG_steps::
  data_id ()
  {
    return this->data_id_.get ();
  }

  void CFG_steps::
  data_id (const data_id_type& x)
  {
    this->data_id_.set (x);
  }

  const CFG_steps::steps_type& CFG_steps::
  steps () const
  {
    return this->steps_.get ();
  }

  CFG_steps::steps_type& CFG_steps::
  steps ()
  {
    return this->steps_.get ();
  }

  void CFG_steps::
  steps (const steps_type& x)
  {
    this->steps_.set (x);
  }


  // CFG_input
  // 

  const CFG_input::receiver_type& CFG_input::
  receiver () const
  {
    return this->receiver_.get ();
  }

  CFG_input::receiver_type& CFG_input::
  receiver ()
  {
    return this->receiver_.get ();
  }

  void CFG_input::
  receiver (const receiver_type& x)
  {
    this->receiver_.set (x);
  }

  const CFG_input::data_id_type& CFG_input::
  data_id () const
  {
    return this->data_id_.get ();
  }

  CFG_input::data_id_type& CFG_input::
  data_id ()
  {
    return this->data_id_.get ();
  }

  void CFG_input::
  data_id (const data_id_type& x)
  {
    this->data_id_.set (x);
  }

  const CFG_input::pos_type& CFG_input::
  pos () const
  {
    return this->pos_.get ();
  }

  CFG_input::pos_type& CFG_input::
  pos ()
  {
    return this->pos_.get ();
  }

  void CFG_input::
  pos (const pos_type& x)
  {
    this->pos_.set (x);
  }

  const CFG_input::target_vr_type& CFG_input::
  target_vr () const
  {
    return this->target_vr_.get ();
  }

  CFG_input::target_vr_type& CFG_input::
  target_vr ()
  {
    return this->target_vr_.get ();
  }

  void CFG_input::
  target_vr (const target_vr_type& x)
  {
    this->target_vr_.set (x);
  }

  const CFG_input::source_data_type_type& CFG_input::
  source_data_type () const
  {
    return this->source_data_type_.get ();
  }

  CFG_input::source_data_type_type& CFG_input::
  source_data_type ()
  {
    return this->source_data_type_.get ();
  }

  void CFG_input::
  source_data_type (const source_data_type_type& x)
  {
    this->source_data_type_.set (x);
  }


  // CFG_output
  // 

  const CFG_output::receiver_type& CFG_output::
  receiver () const
  {
    return this->receiver_.get ();
  }

  CFG_output::receiver_type& CFG_output::
  receiver ()
  {
    return this->receiver_.get ();
  }

  void CFG_output::
  receiver (const receiver_type& x)
  {
    this->receiver_.set (x);
  }

  const CFG_output::data_id_type& CFG_output::
  data_id () const
  {
    return this->data_id_.get ();
  }

  CFG_output::data_id_type& CFG_output::
  data_id ()
  {
    return this->data_id_.get ();
  }

  void CFG_output::
  data_id (const data_id_type& x)
  {
    this->data_id_.set (x);
  }

  const CFG_output::pos_type& CFG_output::
  pos () const
  {
    return this->pos_.get ();
  }

  CFG_output::pos_type& CFG_output::
  pos ()
  {
    return this->pos_.get ();
  }

  void CFG_output::
  pos (const pos_type& x)
  {
    this->pos_.set (x);
  }

  const CFG_output::source_vr_type& CFG_output::
  source_vr () const
  {
    return this->source_vr_.get ();
  }

  CFG_output::source_vr_type& CFG_output::
  source_vr ()
  {
    return this->source_vr_.get ();
  }

  void CFG_output::
  source_vr (const source_vr_type& x)
  {
    this->source_vr_.set (x);
  }


  // CFG_source_network_information
  // 

  const CFG_source_network_information::receiver_type& CFG_source_network_information::
  receiver () const
  {
    return this->receiver_.get ();
  }

  CFG_source_network_information::receiver_type& CFG_source_network_information::
  receiver ()
  {
    return this->receiver_.get ();
  }

  void CFG_source_network_information::
  receiver (const receiver_type& x)
  {
    this->receiver_.set (x);
  }

  const CFG_source_network_information::data_id_type& CFG_source_network_information::
  data_id () const
  {
    return this->data_id_.get ();
  }

  CFG_source_network_information::data_id_type& CFG_source_network_information::
  data_id ()
  {
    return this->data_id_.get ();
  }

  void CFG_source_network_information::
  data_id (const data_id_type& x)
  {
    this->data_id_.set (x);
  }

  const CFG_source_network_information::transport_protocol_type& CFG_source_network_information::
  transport_protocol () const
  {
    return this->transport_protocol_.get ();
  }

  CFG_source_network_information::transport_protocol_type& CFG_source_network_information::
  transport_protocol ()
  {
    return this->transport_protocol_.get ();
  }

  void CFG_source_network_information::
  transport_protocol (const transport_protocol_type& x)
  {
    this->transport_protocol_.set (x);
  }


  // CFG_source_network_information_UDP_IPv4
  // 

  const CFG_source_network_information_UDP_IPv4::receiver_type& CFG_source_network_information_UDP_IPv4::
  receiver () const
  {
    return this->receiver_.get ();
  }

  CFG_source_network_information_UDP_IPv4::receiver_type& CFG_source_network_information_UDP_IPv4::
  receiver ()
  {
    return this->receiver_.get ();
  }

  void CFG_source_network_information_UDP_IPv4::
  receiver (const receiver_type& x)
  {
    this->receiver_.set (x);
  }

  const CFG_source_network_information_UDP_IPv4::data_id_type& CFG_source_network_information_UDP_IPv4::
  data_id () const
  {
    return this->data_id_.get ();
  }

  CFG_source_network_information_UDP_IPv4::data_id_type& CFG_source_network_information_UDP_IPv4::
  data_id ()
  {
    return this->data_id_.get ();
  }

  void CFG_source_network_information_UDP_IPv4::
  data_id (const data_id_type& x)
  {
    this->data_id_.set (x);
  }

  const CFG_source_network_information_UDP_IPv4::transport_protocol_type& CFG_source_network_information_UDP_IPv4::
  transport_protocol () const
  {
    return this->transport_protocol_.get ();
  }

  CFG_source_network_information_UDP_IPv4::transport_protocol_type& CFG_source_network_information_UDP_IPv4::
  transport_protocol ()
  {
    return this->transport_protocol_.get ();
  }

  void CFG_source_network_information_UDP_IPv4::
  transport_protocol (const transport_protocol_type& x)
  {
    this->transport_protocol_.set (x);
  }

  const CFG_source_network_information_UDP_IPv4::ip_address_type& CFG_source_network_information_UDP_IPv4::
  ip_address () const
  {
    return this->ip_address_.get ();
  }

  CFG_source_network_information_UDP_IPv4::ip_address_type& CFG_source_network_information_UDP_IPv4::
  ip_address ()
  {
    return this->ip_address_.get ();
  }

  void CFG_source_network_information_UDP_IPv4::
  ip_address (const ip_address_type& x)
  {
    this->ip_address_.set (x);
  }

  const CFG_source_network_information_UDP_IPv4::port_type& CFG_source_network_information_UDP_IPv4::
  port () const
  {
    return this->port_.get ();
  }

  CFG_source_network_information_UDP_IPv4::port_type& CFG_source_network_information_UDP_IPv4::
  port ()
  {
    return this->port_.get ();
  }

  void CFG_source_network_information_UDP_IPv4::
  port (const port_type& x)
  {
    this->port_.set (x);
  }


  // CFG_source_network_information_USB
  // 

  const CFG_source_network_information_USB::receiver_type& CFG_source_network_information_USB::
  receiver () const
  {
    return this->receiver_.get ();
  }

  CFG_source_network_information_USB::receiver_type& CFG_source_network_information_USB::
  receiver ()
  {
    return this->receiver_.get ();
  }

  void CFG_source_network_information_USB::
  receiver (const receiver_type& x)
  {
    this->receiver_.set (x);
  }

  const CFG_source_network_information_USB::data_id_type& CFG_source_network_information_USB::
  data_id () const
  {
    return this->data_id_.get ();
  }

  CFG_source_network_information_USB::data_id_type& CFG_source_network_information_USB::
  data_id ()
  {
    return this->data_id_.get ();
  }

  void CFG_source_network_information_USB::
  data_id (const data_id_type& x)
  {
    this->data_id_.set (x);
  }

  const CFG_source_network_information_USB::transport_protocol_type& CFG_source_network_information_USB::
  transport_protocol () const
  {
    return this->transport_protocol_.get ();
  }

  CFG_source_network_information_USB::transport_protocol_type& CFG_source_network_information_USB::
  transport_protocol ()
  {
    return this->transport_protocol_.get ();
  }

  void CFG_source_network_information_USB::
  transport_protocol (const transport_protocol_type& x)
  {
    this->transport_protocol_.set (x);
  }

  const CFG_source_network_information_USB::endpoint_address_type& CFG_source_network_information_USB::
  endpoint_address () const
  {
    return this->endpoint_address_.get ();
  }

  CFG_source_network_information_USB::endpoint_address_type& CFG_source_network_information_USB::
  endpoint_address ()
  {
    return this->endpoint_address_.get ();
  }

  void CFG_source_network_information_USB::
  endpoint_address (const endpoint_address_type& x)
  {
    this->endpoint_address_.set (x);
  }


  // CFG_source_network_information_Bluetooth
  // 

  const CFG_source_network_information_Bluetooth::receiver_type& CFG_source_network_information_Bluetooth::
  receiver () const
  {
    return this->receiver_.get ();
  }

  CFG_source_network_information_Bluetooth::receiver_type& CFG_source_network_information_Bluetooth::
  receiver ()
  {
    return this->receiver_.get ();
  }

  void CFG_source_network_information_Bluetooth::
  receiver (const receiver_type& x)
  {
    this->receiver_.set (x);
  }

  const CFG_source_network_information_Bluetooth::data_id_type& CFG_source_network_information_Bluetooth::
  data_id () const
  {
    return this->data_id_.get ();
  }

  CFG_source_network_information_Bluetooth::data_id_type& CFG_source_network_information_Bluetooth::
  data_id ()
  {
    return this->data_id_.get ();
  }

  void CFG_source_network_information_Bluetooth::
  data_id (const data_id_type& x)
  {
    this->data_id_.set (x);
  }

  const CFG_source_network_information_Bluetooth::transport_protocol_type& CFG_source_network_information_Bluetooth::
  transport_protocol () const
  {
    return this->transport_protocol_.get ();
  }

  CFG_source_network_information_Bluetooth::transport_protocol_type& CFG_source_network_information_Bluetooth::
  transport_protocol ()
  {
    return this->transport_protocol_.get ();
  }

  void CFG_source_network_information_Bluetooth::
  transport_protocol (const transport_protocol_type& x)
  {
    this->transport_protocol_.set (x);
  }

  const CFG_source_network_information_Bluetooth::port_type& CFG_source_network_information_Bluetooth::
  port () const
  {
    return this->port_.get ();
  }

  CFG_source_network_information_Bluetooth::port_type& CFG_source_network_information_Bluetooth::
  port ()
  {
    return this->port_.get ();
  }

  void CFG_source_network_information_Bluetooth::
  port (const port_type& x)
  {
    this->port_.set (x);
  }

  const CFG_source_network_information_Bluetooth::bd_addr_type& CFG_source_network_information_Bluetooth::
  bd_addr () const
  {
    return this->bd_addr_.get ();
  }

  CFG_source_network_information_Bluetooth::bd_addr_type& CFG_source_network_information_Bluetooth::
  bd_addr ()
  {
    return this->bd_addr_.get ();
  }

  void CFG_source_network_information_Bluetooth::
  bd_addr (const bd_addr_type& x)
  {
    this->bd_addr_.set (x);
  }


  // CFG_source_network_information_TCP_IPv4
  // 

  const CFG_source_network_information_TCP_IPv4::receiver_type& CFG_source_network_information_TCP_IPv4::
  receiver () const
  {
    return this->receiver_.get ();
  }

  CFG_source_network_information_TCP_IPv4::receiver_type& CFG_source_network_information_TCP_IPv4::
  receiver ()
  {
    return this->receiver_.get ();
  }

  void CFG_source_network_information_TCP_IPv4::
  receiver (const receiver_type& x)
  {
    this->receiver_.set (x);
  }

  const CFG_source_network_information_TCP_IPv4::data_id_type& CFG_source_network_information_TCP_IPv4::
  data_id () const
  {
    return this->data_id_.get ();
  }

  CFG_source_network_information_TCP_IPv4::data_id_type& CFG_source_network_information_TCP_IPv4::
  data_id ()
  {
    return this->data_id_.get ();
  }

  void CFG_source_network_information_TCP_IPv4::
  data_id (const data_id_type& x)
  {
    this->data_id_.set (x);
  }

  const CFG_source_network_information_TCP_IPv4::transport_protocol_type& CFG_source_network_information_TCP_IPv4::
  transport_protocol () const
  {
    return this->transport_protocol_.get ();
  }

  CFG_source_network_information_TCP_IPv4::transport_protocol_type& CFG_source_network_information_TCP_IPv4::
  transport_protocol ()
  {
    return this->transport_protocol_.get ();
  }

  void CFG_source_network_information_TCP_IPv4::
  transport_protocol (const transport_protocol_type& x)
  {
    this->transport_protocol_.set (x);
  }

  const CFG_source_network_information_TCP_IPv4::ip_address_type& CFG_source_network_information_TCP_IPv4::
  ip_address () const
  {
    return this->ip_address_.get ();
  }

  CFG_source_network_information_TCP_IPv4::ip_address_type& CFG_source_network_information_TCP_IPv4::
  ip_address ()
  {
    return this->ip_address_.get ();
  }

  void CFG_source_network_information_TCP_IPv4::
  ip_address (const ip_address_type& x)
  {
    this->ip_address_.set (x);
  }

  const CFG_source_network_information_TCP_IPv4::port_type& CFG_source_network_information_TCP_IPv4::
  port () const
  {
    return this->port_.get ();
  }

  CFG_source_network_information_TCP_IPv4::port_type& CFG_source_network_information_TCP_IPv4::
  port ()
  {
    return this->port_.get ();
  }

  void CFG_source_network_information_TCP_IPv4::
  port (const port_type& x)
  {
    this->port_.set (x);
  }


  // CFG_target_network_information
  // 

  const CFG_target_network_information::receiver_type& CFG_target_network_information::
  receiver () const
  {
    return this->receiver_.get ();
  }

  CFG_target_network_information::receiver_type& CFG_target_network_information::
  receiver ()
  {
    return this->receiver_.get ();
  }

  void CFG_target_network_information::
  receiver (const receiver_type& x)
  {
    this->receiver_.set (x);
  }

  const CFG_target_network_information::data_id_type& CFG_target_network_information::
  data_id () const
  {
    return this->data_id_.get ();
  }

  CFG_target_network_information::data_id_type& CFG_target_network_information::
  data_id ()
  {
    return this->data_id_.get ();
  }

  void CFG_target_network_information::
  data_id (const data_id_type& x)
  {
    this->data_id_.set (x);
  }

  const CFG_target_network_information::transport_protocol_type& CFG_target_network_information::
  transport_protocol () const
  {
    return this->transport_protocol_.get ();
  }

  CFG_target_network_information::transport_protocol_type& CFG_target_network_information::
  transport_protocol ()
  {
    return this->transport_protocol_.get ();
  }

  void CFG_target_network_information::
  transport_protocol (const transport_protocol_type& x)
  {
    this->transport_protocol_.set (x);
  }


  // CFG_target_network_information_UDP_IPv4
  // 

  const CFG_target_network_information_UDP_IPv4::receiver_type& CFG_target_network_information_UDP_IPv4::
  receiver () const
  {
    return this->receiver_.get ();
  }

  CFG_target_network_information_UDP_IPv4::receiver_type& CFG_target_network_information_UDP_IPv4::
  receiver ()
  {
    return this->receiver_.get ();
  }

  void CFG_target_network_information_UDP_IPv4::
  receiver (const receiver_type& x)
  {
    this->receiver_.set (x);
  }

  const CFG_target_network_information_UDP_IPv4::data_id_type& CFG_target_network_information_UDP_IPv4::
  data_id () const
  {
    return this->data_id_.get ();
  }

  CFG_target_network_information_UDP_IPv4::data_id_type& CFG_target_network_information_UDP_IPv4::
  data_id ()
  {
    return this->data_id_.get ();
  }

  void CFG_target_network_information_UDP_IPv4::
  data_id (const data_id_type& x)
  {
    this->data_id_.set (x);
  }

  const CFG_target_network_information_UDP_IPv4::transport_protocol_type& CFG_target_network_information_UDP_IPv4::
  transport_protocol () const
  {
    return this->transport_protocol_.get ();
  }

  CFG_target_network_information_UDP_IPv4::transport_protocol_type& CFG_target_network_information_UDP_IPv4::
  transport_protocol ()
  {
    return this->transport_protocol_.get ();
  }

  void CFG_target_network_information_UDP_IPv4::
  transport_protocol (const transport_protocol_type& x)
  {
    this->transport_protocol_.set (x);
  }

  const CFG_target_network_information_UDP_IPv4::ip_address_type& CFG_target_network_information_UDP_IPv4::
  ip_address () const
  {
    return this->ip_address_.get ();
  }

  CFG_target_network_information_UDP_IPv4::ip_address_type& CFG_target_network_information_UDP_IPv4::
  ip_address ()
  {
    return this->ip_address_.get ();
  }

  void CFG_target_network_information_UDP_IPv4::
  ip_address (const ip_address_type& x)
  {
    this->ip_address_.set (x);
  }

  const CFG_target_network_information_UDP_IPv4::port_type& CFG_target_network_information_UDP_IPv4::
  port () const
  {
    return this->port_.get ();
  }

  CFG_target_network_information_UDP_IPv4::port_type& CFG_target_network_information_UDP_IPv4::
  port ()
  {
    return this->port_.get ();
  }

  void CFG_target_network_information_UDP_IPv4::
  port (const port_type& x)
  {
    this->port_.set (x);
  }


  // CFG_target_network_information_USB
  // 

  const CFG_target_network_information_USB::receiver_type& CFG_target_network_information_USB::
  receiver () const
  {
    return this->receiver_.get ();
  }

  CFG_target_network_information_USB::receiver_type& CFG_target_network_information_USB::
  receiver ()
  {
    return this->receiver_.get ();
  }

  void CFG_target_network_information_USB::
  receiver (const receiver_type& x)
  {
    this->receiver_.set (x);
  }

  const CFG_target_network_information_USB::data_id_type& CFG_target_network_information_USB::
  data_id () const
  {
    return this->data_id_.get ();
  }

  CFG_target_network_information_USB::data_id_type& CFG_target_network_information_USB::
  data_id ()
  {
    return this->data_id_.get ();
  }

  void CFG_target_network_information_USB::
  data_id (const data_id_type& x)
  {
    this->data_id_.set (x);
  }

  const CFG_target_network_information_USB::transport_protocol_type& CFG_target_network_information_USB::
  transport_protocol () const
  {
    return this->transport_protocol_.get ();
  }

  CFG_target_network_information_USB::transport_protocol_type& CFG_target_network_information_USB::
  transport_protocol ()
  {
    return this->transport_protocol_.get ();
  }

  void CFG_target_network_information_USB::
  transport_protocol (const transport_protocol_type& x)
  {
    this->transport_protocol_.set (x);
  }

  const CFG_target_network_information_USB::endpoint_address_type& CFG_target_network_information_USB::
  endpoint_address () const
  {
    return this->endpoint_address_.get ();
  }

  CFG_target_network_information_USB::endpoint_address_type& CFG_target_network_information_USB::
  endpoint_address ()
  {
    return this->endpoint_address_.get ();
  }

  void CFG_target_network_information_USB::
  endpoint_address (const endpoint_address_type& x)
  {
    this->endpoint_address_.set (x);
  }

  const CFG_target_network_information_USB::slave_uuid_type& CFG_target_network_information_USB::
  slave_uuid () const
  {
    return this->slave_uuid_.get ();
  }

  CFG_target_network_information_USB::slave_uuid_type& CFG_target_network_information_USB::
  slave_uuid ()
  {
    return this->slave_uuid_.get ();
  }

  void CFG_target_network_information_USB::
  slave_uuid (const slave_uuid_type& x)
  {
    this->slave_uuid_.set (x);
  }

  void CFG_target_network_information_USB::
  slave_uuid (::std::auto_ptr< slave_uuid_type > x)
  {
    this->slave_uuid_.set (x);
  }


  // CFG_target_network_information_Bluetooth
  // 

  const CFG_target_network_information_Bluetooth::receiver_type& CFG_target_network_information_Bluetooth::
  receiver () const
  {
    return this->receiver_.get ();
  }

  CFG_target_network_information_Bluetooth::receiver_type& CFG_target_network_information_Bluetooth::
  receiver ()
  {
    return this->receiver_.get ();
  }

  void CFG_target_network_information_Bluetooth::
  receiver (const receiver_type& x)
  {
    this->receiver_.set (x);
  }

  const CFG_target_network_information_Bluetooth::data_id_type& CFG_target_network_information_Bluetooth::
  data_id () const
  {
    return this->data_id_.get ();
  }

  CFG_target_network_information_Bluetooth::data_id_type& CFG_target_network_information_Bluetooth::
  data_id ()
  {
    return this->data_id_.get ();
  }

  void CFG_target_network_information_Bluetooth::
  data_id (const data_id_type& x)
  {
    this->data_id_.set (x);
  }

  const CFG_target_network_information_Bluetooth::transport_protocol_type& CFG_target_network_information_Bluetooth::
  transport_protocol () const
  {
    return this->transport_protocol_.get ();
  }

  CFG_target_network_information_Bluetooth::transport_protocol_type& CFG_target_network_information_Bluetooth::
  transport_protocol ()
  {
    return this->transport_protocol_.get ();
  }

  void CFG_target_network_information_Bluetooth::
  transport_protocol (const transport_protocol_type& x)
  {
    this->transport_protocol_.set (x);
  }

  const CFG_target_network_information_Bluetooth::port_type& CFG_target_network_information_Bluetooth::
  port () const
  {
    return this->port_.get ();
  }

  CFG_target_network_information_Bluetooth::port_type& CFG_target_network_information_Bluetooth::
  port ()
  {
    return this->port_.get ();
  }

  void CFG_target_network_information_Bluetooth::
  port (const port_type& x)
  {
    this->port_.set (x);
  }

  const CFG_target_network_information_Bluetooth::bd_addr_type& CFG_target_network_information_Bluetooth::
  bd_addr () const
  {
    return this->bd_addr_.get ();
  }

  CFG_target_network_information_Bluetooth::bd_addr_type& CFG_target_network_information_Bluetooth::
  bd_addr ()
  {
    return this->bd_addr_.get ();
  }

  void CFG_target_network_information_Bluetooth::
  bd_addr (const bd_addr_type& x)
  {
    this->bd_addr_.set (x);
  }


  // CFG_target_network_information_TCP_IPv4
  // 

  const CFG_target_network_information_TCP_IPv4::receiver_type& CFG_target_network_information_TCP_IPv4::
  receiver () const
  {
    return this->receiver_.get ();
  }

  CFG_target_network_information_TCP_IPv4::receiver_type& CFG_target_network_information_TCP_IPv4::
  receiver ()
  {
    return this->receiver_.get ();
  }

  void CFG_target_network_information_TCP_IPv4::
  receiver (const receiver_type& x)
  {
    this->receiver_.set (x);
  }

  const CFG_target_network_information_TCP_IPv4::data_id_type& CFG_target_network_information_TCP_IPv4::
  data_id () const
  {
    return this->data_id_.get ();
  }

  CFG_target_network_information_TCP_IPv4::data_id_type& CFG_target_network_information_TCP_IPv4::
  data_id ()
  {
    return this->data_id_.get ();
  }

  void CFG_target_network_information_TCP_IPv4::
  data_id (const data_id_type& x)
  {
    this->data_id_.set (x);
  }

  const CFG_target_network_information_TCP_IPv4::transport_protocol_type& CFG_target_network_information_TCP_IPv4::
  transport_protocol () const
  {
    return this->transport_protocol_.get ();
  }

  CFG_target_network_information_TCP_IPv4::transport_protocol_type& CFG_target_network_information_TCP_IPv4::
  transport_protocol ()
  {
    return this->transport_protocol_.get ();
  }

  void CFG_target_network_information_TCP_IPv4::
  transport_protocol (const transport_protocol_type& x)
  {
    this->transport_protocol_.set (x);
  }

  const CFG_target_network_information_TCP_IPv4::ip_address_type& CFG_target_network_information_TCP_IPv4::
  ip_address () const
  {
    return this->ip_address_.get ();
  }

  CFG_target_network_information_TCP_IPv4::ip_address_type& CFG_target_network_information_TCP_IPv4::
  ip_address ()
  {
    return this->ip_address_.get ();
  }

  void CFG_target_network_information_TCP_IPv4::
  ip_address (const ip_address_type& x)
  {
    this->ip_address_.set (x);
  }

  const CFG_target_network_information_TCP_IPv4::port_type& CFG_target_network_information_TCP_IPv4::
  port () const
  {
    return this->port_.get ();
  }

  CFG_target_network_information_TCP_IPv4::port_type& CFG_target_network_information_TCP_IPv4::
  port ()
  {
    return this->port_.get ();
  }

  void CFG_target_network_information_TCP_IPv4::
  port (const port_type& x)
  {
    this->port_.set (x);
  }


  // CFG_clear
  // 

  const CFG_clear::receiver_type& CFG_clear::
  receiver () const
  {
    return this->receiver_.get ();
  }

  CFG_clear::receiver_type& CFG_clear::
  receiver ()
  {
    return this->receiver_.get ();
  }

  void CFG_clear::
  receiver (const receiver_type& x)
  {
    this->receiver_.set (x);
  }


  // CFG_parameter
  // 

  const CFG_parameter::Payload_type& CFG_parameter::
  Payload () const
  {
    return this->Payload_.get ();
  }

  CFG_parameter::Payload_type& CFG_parameter::
  Payload ()
  {
    return this->Payload_.get ();
  }

  void CFG_parameter::
  Payload (const Payload_type& x)
  {
    this->Payload_.set (x);
  }

  void CFG_parameter::
  Payload (::std::auto_ptr< Payload_type > x)
  {
    this->Payload_.set (x);
  }

  const CFG_parameter::receiver_type& CFG_parameter::
  receiver () const
  {
    return this->receiver_.get ();
  }

  CFG_parameter::receiver_type& CFG_parameter::
  receiver ()
  {
    return this->receiver_.get ();
  }

  void CFG_parameter::
  receiver (const receiver_type& x)
  {
    this->receiver_.set (x);
  }

  const CFG_parameter::target_vr_type& CFG_parameter::
  target_vr () const
  {
    return this->target_vr_.get ();
  }

  CFG_parameter::target_vr_type& CFG_parameter::
  target_vr ()
  {
    return this->target_vr_.get ();
  }

  void CFG_parameter::
  target_vr (const target_vr_type& x)
  {
    this->target_vr_.set (x);
  }

  const CFG_parameter::source_data_type_type& CFG_parameter::
  source_data_type () const
  {
    return this->source_data_type_.get ();
  }

  CFG_parameter::source_data_type_type& CFG_parameter::
  source_data_type ()
  {
    return this->source_data_type_.get ();
  }

  void CFG_parameter::
  source_data_type (const source_data_type_type& x)
  {
    this->source_data_type_.set (x);
  }


  // CFG_tunable_parameter
  // 

  const CFG_tunable_parameter::receiver_type& CFG_tunable_parameter::
  receiver () const
  {
    return this->receiver_.get ();
  }

  CFG_tunable_parameter::receiver_type& CFG_tunable_parameter::
  receiver ()
  {
    return this->receiver_.get ();
  }

  void CFG_tunable_parameter::
  receiver (const receiver_type& x)
  {
    this->receiver_.set (x);
  }

  const CFG_tunable_parameter::param_id_type& CFG_tunable_parameter::
  param_id () const
  {
    return this->param_id_.get ();
  }

  CFG_tunable_parameter::param_id_type& CFG_tunable_parameter::
  param_id ()
  {
    return this->param_id_.get ();
  }

  void CFG_tunable_parameter::
  param_id (const param_id_type& x)
  {
    this->param_id_.set (x);
  }

  const CFG_tunable_parameter::pos_type& CFG_tunable_parameter::
  pos () const
  {
    return this->pos_.get ();
  }

  CFG_tunable_parameter::pos_type& CFG_tunable_parameter::
  pos ()
  {
    return this->pos_.get ();
  }

  void CFG_tunable_parameter::
  pos (const pos_type& x)
  {
    this->pos_.set (x);
  }

  const CFG_tunable_parameter::target_vr_type& CFG_tunable_parameter::
  target_vr () const
  {
    return this->target_vr_.get ();
  }

  CFG_tunable_parameter::target_vr_type& CFG_tunable_parameter::
  target_vr ()
  {
    return this->target_vr_.get ();
  }

  void CFG_tunable_parameter::
  target_vr (const target_vr_type& x)
  {
    this->target_vr_.set (x);
  }

  const CFG_tunable_parameter::source_data_type_type& CFG_tunable_parameter::
  source_data_type () const
  {
    return this->source_data_type_.get ();
  }

  CFG_tunable_parameter::source_data_type_type& CFG_tunable_parameter::
  source_data_type ()
  {
    return this->source_data_type_.get ();
  }

  void CFG_tunable_parameter::
  source_data_type (const source_data_type_type& x)
  {
    this->source_data_type_.set (x);
  }


  // CFG_param_network_information
  // 

  const CFG_param_network_information::receiver_type& CFG_param_network_information::
  receiver () const
  {
    return this->receiver_.get ();
  }

  CFG_param_network_information::receiver_type& CFG_param_network_information::
  receiver ()
  {
    return this->receiver_.get ();
  }

  void CFG_param_network_information::
  receiver (const receiver_type& x)
  {
    this->receiver_.set (x);
  }

  const CFG_param_network_information::param_id_type& CFG_param_network_information::
  param_id () const
  {
    return this->param_id_.get ();
  }

  CFG_param_network_information::param_id_type& CFG_param_network_information::
  param_id ()
  {
    return this->param_id_.get ();
  }

  void CFG_param_network_information::
  param_id (const param_id_type& x)
  {
    this->param_id_.set (x);
  }

  const CFG_param_network_information::transport_protocol_type& CFG_param_network_information::
  transport_protocol () const
  {
    return this->transport_protocol_.get ();
  }

  CFG_param_network_information::transport_protocol_type& CFG_param_network_information::
  transport_protocol ()
  {
    return this->transport_protocol_.get ();
  }

  void CFG_param_network_information::
  transport_protocol (const transport_protocol_type& x)
  {
    this->transport_protocol_.set (x);
  }


  // CFG_param_network_information_UDP_IPv4
  // 

  const CFG_param_network_information_UDP_IPv4::receiver_type& CFG_param_network_information_UDP_IPv4::
  receiver () const
  {
    return this->receiver_.get ();
  }

  CFG_param_network_information_UDP_IPv4::receiver_type& CFG_param_network_information_UDP_IPv4::
  receiver ()
  {
    return this->receiver_.get ();
  }

  void CFG_param_network_information_UDP_IPv4::
  receiver (const receiver_type& x)
  {
    this->receiver_.set (x);
  }

  const CFG_param_network_information_UDP_IPv4::param_id_type& CFG_param_network_information_UDP_IPv4::
  param_id () const
  {
    return this->param_id_.get ();
  }

  CFG_param_network_information_UDP_IPv4::param_id_type& CFG_param_network_information_UDP_IPv4::
  param_id ()
  {
    return this->param_id_.get ();
  }

  void CFG_param_network_information_UDP_IPv4::
  param_id (const param_id_type& x)
  {
    this->param_id_.set (x);
  }

  const CFG_param_network_information_UDP_IPv4::transport_protocol_type& CFG_param_network_information_UDP_IPv4::
  transport_protocol () const
  {
    return this->transport_protocol_.get ();
  }

  CFG_param_network_information_UDP_IPv4::transport_protocol_type& CFG_param_network_information_UDP_IPv4::
  transport_protocol ()
  {
    return this->transport_protocol_.get ();
  }

  void CFG_param_network_information_UDP_IPv4::
  transport_protocol (const transport_protocol_type& x)
  {
    this->transport_protocol_.set (x);
  }

  const CFG_param_network_information_UDP_IPv4::ip_address_type& CFG_param_network_information_UDP_IPv4::
  ip_address () const
  {
    return this->ip_address_.get ();
  }

  CFG_param_network_information_UDP_IPv4::ip_address_type& CFG_param_network_information_UDP_IPv4::
  ip_address ()
  {
    return this->ip_address_.get ();
  }

  void CFG_param_network_information_UDP_IPv4::
  ip_address (const ip_address_type& x)
  {
    this->ip_address_.set (x);
  }

  const CFG_param_network_information_UDP_IPv4::port_type& CFG_param_network_information_UDP_IPv4::
  port () const
  {
    return this->port_.get ();
  }

  CFG_param_network_information_UDP_IPv4::port_type& CFG_param_network_information_UDP_IPv4::
  port ()
  {
    return this->port_.get ();
  }

  void CFG_param_network_information_UDP_IPv4::
  port (const port_type& x)
  {
    this->port_.set (x);
  }


  // CFG_param_network_information_USB
  // 

  const CFG_param_network_information_USB::receiver_type& CFG_param_network_information_USB::
  receiver () const
  {
    return this->receiver_.get ();
  }

  CFG_param_network_information_USB::receiver_type& CFG_param_network_information_USB::
  receiver ()
  {
    return this->receiver_.get ();
  }

  void CFG_param_network_information_USB::
  receiver (const receiver_type& x)
  {
    this->receiver_.set (x);
  }

  const CFG_param_network_information_USB::data_id_type& CFG_param_network_information_USB::
  data_id () const
  {
    return this->data_id_.get ();
  }

  CFG_param_network_information_USB::data_id_type& CFG_param_network_information_USB::
  data_id ()
  {
    return this->data_id_.get ();
  }

  void CFG_param_network_information_USB::
  data_id (const data_id_type& x)
  {
    this->data_id_.set (x);
  }

  const CFG_param_network_information_USB::transport_protocol_type& CFG_param_network_information_USB::
  transport_protocol () const
  {
    return this->transport_protocol_.get ();
  }

  CFG_param_network_information_USB::transport_protocol_type& CFG_param_network_information_USB::
  transport_protocol ()
  {
    return this->transport_protocol_.get ();
  }

  void CFG_param_network_information_USB::
  transport_protocol (const transport_protocol_type& x)
  {
    this->transport_protocol_.set (x);
  }

  const CFG_param_network_information_USB::endpoint_address_type& CFG_param_network_information_USB::
  endpoint_address () const
  {
    return this->endpoint_address_.get ();
  }

  CFG_param_network_information_USB::endpoint_address_type& CFG_param_network_information_USB::
  endpoint_address ()
  {
    return this->endpoint_address_.get ();
  }

  void CFG_param_network_information_USB::
  endpoint_address (const endpoint_address_type& x)
  {
    this->endpoint_address_.set (x);
  }


  // CFG_param_network_information_Bluetooth
  // 

  const CFG_param_network_information_Bluetooth::receiver_type& CFG_param_network_information_Bluetooth::
  receiver () const
  {
    return this->receiver_.get ();
  }

  CFG_param_network_information_Bluetooth::receiver_type& CFG_param_network_information_Bluetooth::
  receiver ()
  {
    return this->receiver_.get ();
  }

  void CFG_param_network_information_Bluetooth::
  receiver (const receiver_type& x)
  {
    this->receiver_.set (x);
  }

  const CFG_param_network_information_Bluetooth::data_id_type& CFG_param_network_information_Bluetooth::
  data_id () const
  {
    return this->data_id_.get ();
  }

  CFG_param_network_information_Bluetooth::data_id_type& CFG_param_network_information_Bluetooth::
  data_id ()
  {
    return this->data_id_.get ();
  }

  void CFG_param_network_information_Bluetooth::
  data_id (const data_id_type& x)
  {
    this->data_id_.set (x);
  }

  const CFG_param_network_information_Bluetooth::transport_protocol_type& CFG_param_network_information_Bluetooth::
  transport_protocol () const
  {
    return this->transport_protocol_.get ();
  }

  CFG_param_network_information_Bluetooth::transport_protocol_type& CFG_param_network_information_Bluetooth::
  transport_protocol ()
  {
    return this->transport_protocol_.get ();
  }

  void CFG_param_network_information_Bluetooth::
  transport_protocol (const transport_protocol_type& x)
  {
    this->transport_protocol_.set (x);
  }

  const CFG_param_network_information_Bluetooth::port_type& CFG_param_network_information_Bluetooth::
  port () const
  {
    return this->port_.get ();
  }

  CFG_param_network_information_Bluetooth::port_type& CFG_param_network_information_Bluetooth::
  port ()
  {
    return this->port_.get ();
  }

  void CFG_param_network_information_Bluetooth::
  port (const port_type& x)
  {
    this->port_.set (x);
  }

  const CFG_param_network_information_Bluetooth::bd_addr_type& CFG_param_network_information_Bluetooth::
  bd_addr () const
  {
    return this->bd_addr_.get ();
  }

  CFG_param_network_information_Bluetooth::bd_addr_type& CFG_param_network_information_Bluetooth::
  bd_addr ()
  {
    return this->bd_addr_.get ();
  }

  void CFG_param_network_information_Bluetooth::
  bd_addr (const bd_addr_type& x)
  {
    this->bd_addr_.set (x);
  }


  // CFG_param_network_information_TCP_IPv4
  // 

  const CFG_param_network_information_TCP_IPv4::receiver_type& CFG_param_network_information_TCP_IPv4::
  receiver () const
  {
    return this->receiver_.get ();
  }

  CFG_param_network_information_TCP_IPv4::receiver_type& CFG_param_network_information_TCP_IPv4::
  receiver ()
  {
    return this->receiver_.get ();
  }

  void CFG_param_network_information_TCP_IPv4::
  receiver (const receiver_type& x)
  {
    this->receiver_.set (x);
  }

  const CFG_param_network_information_TCP_IPv4::param_id_type& CFG_param_network_information_TCP_IPv4::
  param_id () const
  {
    return this->param_id_.get ();
  }

  CFG_param_network_information_TCP_IPv4::param_id_type& CFG_param_network_information_TCP_IPv4::
  param_id ()
  {
    return this->param_id_.get ();
  }

  void CFG_param_network_information_TCP_IPv4::
  param_id (const param_id_type& x)
  {
    this->param_id_.set (x);
  }

  const CFG_param_network_information_TCP_IPv4::transport_protocol_type& CFG_param_network_information_TCP_IPv4::
  transport_protocol () const
  {
    return this->transport_protocol_.get ();
  }

  CFG_param_network_information_TCP_IPv4::transport_protocol_type& CFG_param_network_information_TCP_IPv4::
  transport_protocol ()
  {
    return this->transport_protocol_.get ();
  }

  void CFG_param_network_information_TCP_IPv4::
  transport_protocol (const transport_protocol_type& x)
  {
    this->transport_protocol_.set (x);
  }

  const CFG_param_network_information_TCP_IPv4::ip_address_type& CFG_param_network_information_TCP_IPv4::
  ip_address () const
  {
    return this->ip_address_.get ();
  }

  CFG_param_network_information_TCP_IPv4::ip_address_type& CFG_param_network_information_TCP_IPv4::
  ip_address ()
  {
    return this->ip_address_.get ();
  }

  void CFG_param_network_information_TCP_IPv4::
  ip_address (const ip_address_type& x)
  {
    this->ip_address_.set (x);
  }

  const CFG_param_network_information_TCP_IPv4::port_type& CFG_param_network_information_TCP_IPv4::
  port () const
  {
    return this->port_.get ();
  }

  CFG_param_network_information_TCP_IPv4::port_type& CFG_param_network_information_TCP_IPv4::
  port ()
  {
    return this->port_.get ();
  }

  void CFG_param_network_information_TCP_IPv4::
  port (const port_type& x)
  {
    this->port_.set (x);
  }


  // CFG_logging
  // 

  const CFG_logging::receiver_type& CFG_logging::
  receiver () const
  {
    return this->receiver_.get ();
  }

  CFG_logging::receiver_type& CFG_logging::
  receiver ()
  {
    return this->receiver_.get ();
  }

  void CFG_logging::
  receiver (const receiver_type& x)
  {
    this->receiver_.set (x);
  }

  const CFG_logging::log_category_type& CFG_logging::
  log_category () const
  {
    return this->log_category_.get ();
  }

  CFG_logging::log_category_type& CFG_logging::
  log_category ()
  {
    return this->log_category_.get ();
  }

  void CFG_logging::
  log_category (const log_category_type& x)
  {
    this->log_category_.set (x);
  }

  const CFG_logging::log_level_type& CFG_logging::
  log_level () const
  {
    return this->log_level_.get ();
  }

  CFG_logging::log_level_type& CFG_logging::
  log_level ()
  {
    return this->log_level_.get ();
  }

  void CFG_logging::
  log_level (const log_level_type& x)
  {
    this->log_level_.set (x);
  }

  const CFG_logging::log_mode_type& CFG_logging::
  log_mode () const
  {
    return this->log_mode_.get ();
  }

  CFG_logging::log_mode_type& CFG_logging::
  log_mode ()
  {
    return this->log_mode_.get ();
  }

  void CFG_logging::
  log_mode (const log_mode_type& x)
  {
    this->log_mode_.set (x);
  }


  // CFG_scope
  // 

  const CFG_scope::receiver_type& CFG_scope::
  receiver () const
  {
    return this->receiver_.get ();
  }

  CFG_scope::receiver_type& CFG_scope::
  receiver ()
  {
    return this->receiver_.get ();
  }

  void CFG_scope::
  receiver (const receiver_type& x)
  {
    this->receiver_.set (x);
  }

  const CFG_scope::data_id_type& CFG_scope::
  data_id () const
  {
    return this->data_id_.get ();
  }

  CFG_scope::data_id_type& CFG_scope::
  data_id ()
  {
    return this->data_id_.get ();
  }

  void CFG_scope::
  data_id (const data_id_type& x)
  {
    this->data_id_.set (x);
  }

  const CFG_scope::scope_type& CFG_scope::
  scope () const
  {
    return this->scope_.get ();
  }

  CFG_scope::scope_type& CFG_scope::
  scope ()
  {
    return this->scope_.get ();
  }

  void CFG_scope::
  scope (const scope_type& x)
  {
    this->scope_.set (x);
  }


  // STC_register
  // 

  const STC_register::receiver_type& STC_register::
  receiver () const
  {
    return this->receiver_.get ();
  }

  STC_register::receiver_type& STC_register::
  receiver ()
  {
    return this->receiver_.get ();
  }

  void STC_register::
  receiver (const receiver_type& x)
  {
    this->receiver_.set (x);
  }

  const STC_register::state_id_type& STC_register::
  state_id () const
  {
    return this->state_id_.get ();
  }

  STC_register::state_id_type& STC_register::
  state_id ()
  {
    return this->state_id_.get ();
  }

  void STC_register::
  state_id (const state_id_type& x)
  {
    this->state_id_.set (x);
  }

  const STC_register::slave_uuid_optional& STC_register::
  slave_uuid () const
  {
    return this->slave_uuid_;
  }

  STC_register::slave_uuid_optional& STC_register::
  slave_uuid ()
  {
    return this->slave_uuid_;
  }

  void STC_register::
  slave_uuid (const slave_uuid_type& x)
  {
    this->slave_uuid_.set (x);
  }

  void STC_register::
  slave_uuid (const slave_uuid_optional& x)
  {
    this->slave_uuid_ = x;
  }

  void STC_register::
  slave_uuid (::std::auto_ptr< slave_uuid_type > x)
  {
    this->slave_uuid_.set (x);
  }

  const STC_register::op_mode_type& STC_register::
  op_mode () const
  {
    return this->op_mode_.get ();
  }

  STC_register::op_mode_type& STC_register::
  op_mode ()
  {
    return this->op_mode_.get ();
  }

  void STC_register::
  op_mode (const op_mode_type& x)
  {
    this->op_mode_.set (x);
  }

  const STC_register::major_version_type& STC_register::
  major_version () const
  {
    return this->major_version_.get ();
  }

  STC_register::major_version_type& STC_register::
  major_version ()
  {
    return this->major_version_.get ();
  }

  void STC_register::
  major_version (const major_version_type& x)
  {
    this->major_version_.set (x);
  }

  const STC_register::minor_version_type& STC_register::
  minor_version () const
  {
    return this->minor_version_.get ();
  }

  STC_register::minor_version_type& STC_register::
  minor_version ()
  {
    return this->minor_version_.get ();
  }

  void STC_register::
  minor_version (const minor_version_type& x)
  {
    this->minor_version_.set (x);
  }


  // STC_deregister
  // 

  const STC_deregister::receiver_type& STC_deregister::
  receiver () const
  {
    return this->receiver_.get ();
  }

  STC_deregister::receiver_type& STC_deregister::
  receiver ()
  {
    return this->receiver_.get ();
  }

  void STC_deregister::
  receiver (const receiver_type& x)
  {
    this->receiver_.set (x);
  }

  const STC_deregister::state_id_type& STC_deregister::
  state_id () const
  {
    return this->state_id_.get ();
  }

  STC_deregister::state_id_type& STC_deregister::
  state_id ()
  {
    return this->state_id_.get ();
  }

  void STC_deregister::
  state_id (const state_id_type& x)
  {
    this->state_id_.set (x);
  }


  // STC_prepare
  // 

  const STC_prepare::receiver_type& STC_prepare::
  receiver () const
  {
    return this->receiver_.get ();
  }

  STC_prepare::receiver_type& STC_prepare::
  receiver ()
  {
    return this->receiver_.get ();
  }

  void STC_prepare::
  receiver (const receiver_type& x)
  {
    this->receiver_.set (x);
  }

  const STC_prepare::state_id_type& STC_prepare::
  state_id () const
  {
    return this->state_id_.get ();
  }

  STC_prepare::state_id_type& STC_prepare::
  state_id ()
  {
    return this->state_id_.get ();
  }

  void STC_prepare::
  state_id (const state_id_type& x)
  {
    this->state_id_.set (x);
  }


  // STC_configure
  // 

  const STC_configure::receiver_type& STC_configure::
  receiver () const
  {
    return this->receiver_.get ();
  }

  STC_configure::receiver_type& STC_configure::
  receiver ()
  {
    return this->receiver_.get ();
  }

  void STC_configure::
  receiver (const receiver_type& x)
  {
    this->receiver_.set (x);
  }

  const STC_configure::state_id_type& STC_configure::
  state_id () const
  {
    return this->state_id_.get ();
  }

  STC_configure::state_id_type& STC_configure::
  state_id ()
  {
    return this->state_id_.get ();
  }

  void STC_configure::
  state_id (const state_id_type& x)
  {
    this->state_id_.set (x);
  }


  // STC_initialize
  // 

  const STC_initialize::receiver_type& STC_initialize::
  receiver () const
  {
    return this->receiver_.get ();
  }

  STC_initialize::receiver_type& STC_initialize::
  receiver ()
  {
    return this->receiver_.get ();
  }

  void STC_initialize::
  receiver (const receiver_type& x)
  {
    this->receiver_.set (x);
  }

  const STC_initialize::state_id_type& STC_initialize::
  state_id () const
  {
    return this->state_id_.get ();
  }

  STC_initialize::state_id_type& STC_initialize::
  state_id ()
  {
    return this->state_id_.get ();
  }

  void STC_initialize::
  state_id (const state_id_type& x)
  {
    this->state_id_.set (x);
  }


  // STC_run
  // 

  const STC_run::receiver_type& STC_run::
  receiver () const
  {
    return this->receiver_.get ();
  }

  STC_run::receiver_type& STC_run::
  receiver ()
  {
    return this->receiver_.get ();
  }

  void STC_run::
  receiver (const receiver_type& x)
  {
    this->receiver_.set (x);
  }

  const STC_run::state_id_type& STC_run::
  state_id () const
  {
    return this->state_id_.get ();
  }

  STC_run::state_id_type& STC_run::
  state_id ()
  {
    return this->state_id_.get ();
  }

  void STC_run::
  state_id (const state_id_type& x)
  {
    this->state_id_.set (x);
  }

  const STC_run::start_time_optional& STC_run::
  start_time () const
  {
    return this->start_time_;
  }

  STC_run::start_time_optional& STC_run::
  start_time ()
  {
    return this->start_time_;
  }

  void STC_run::
  start_time (const start_time_type& x)
  {
    this->start_time_.set (x);
  }

  void STC_run::
  start_time (const start_time_optional& x)
  {
    this->start_time_ = x;
  }


  // STC_do_step
  // 

  const STC_do_step::receiver_type& STC_do_step::
  receiver () const
  {
    return this->receiver_.get ();
  }

  STC_do_step::receiver_type& STC_do_step::
  receiver ()
  {
    return this->receiver_.get ();
  }

  void STC_do_step::
  receiver (const receiver_type& x)
  {
    this->receiver_.set (x);
  }

  const STC_do_step::state_id_type& STC_do_step::
  state_id () const
  {
    return this->state_id_.get ();
  }

  STC_do_step::state_id_type& STC_do_step::
  state_id ()
  {
    return this->state_id_.get ();
  }

  void STC_do_step::
  state_id (const state_id_type& x)
  {
    this->state_id_.set (x);
  }

  const STC_do_step::steps_type& STC_do_step::
  steps () const
  {
    return this->steps_.get ();
  }

  STC_do_step::steps_type& STC_do_step::
  steps ()
  {
    return this->steps_.get ();
  }

  void STC_do_step::
  steps (const steps_type& x)
  {
    this->steps_.set (x);
  }


  // STC_send_outputs
  // 

  const STC_send_outputs::receiver_type& STC_send_outputs::
  receiver () const
  {
    return this->receiver_.get ();
  }

  STC_send_outputs::receiver_type& STC_send_outputs::
  receiver ()
  {
    return this->receiver_.get ();
  }

  void STC_send_outputs::
  receiver (const receiver_type& x)
  {
    this->receiver_.set (x);
  }

  const STC_send_outputs::state_id_type& STC_send_outputs::
  state_id () const
  {
    return this->state_id_.get ();
  }

  STC_send_outputs::state_id_type& STC_send_outputs::
  state_id ()
  {
    return this->state_id_.get ();
  }

  void STC_send_outputs::
  state_id (const state_id_type& x)
  {
    this->state_id_.set (x);
  }


  // STC_stop
  // 

  const STC_stop::receiver_type& STC_stop::
  receiver () const
  {
    return this->receiver_.get ();
  }

  STC_stop::receiver_type& STC_stop::
  receiver ()
  {
    return this->receiver_.get ();
  }

  void STC_stop::
  receiver (const receiver_type& x)
  {
    this->receiver_.set (x);
  }

  const STC_stop::state_id_type& STC_stop::
  state_id () const
  {
    return this->state_id_.get ();
  }

  STC_stop::state_id_type& STC_stop::
  state_id ()
  {
    return this->state_id_.get ();
  }

  void STC_stop::
  state_id (const state_id_type& x)
  {
    this->state_id_.set (x);
  }


  // STC_reset
  // 

  const STC_reset::receiver_type& STC_reset::
  receiver () const
  {
    return this->receiver_.get ();
  }

  STC_reset::receiver_type& STC_reset::
  receiver ()
  {
    return this->receiver_.get ();
  }

  void STC_reset::
  receiver (const receiver_type& x)
  {
    this->receiver_.set (x);
  }

  const STC_reset::state_id_type& STC_reset::
  state_id () const
  {
    return this->state_id_.get ();
  }

  STC_reset::state_id_type& STC_reset::
  state_id ()
  {
    return this->state_id_.get ();
  }

  void STC_reset::
  state_id (const state_id_type& x)
  {
    this->state_id_.set (x);
  }


  // INF_state
  // 

  const INF_state::receiver_type& INF_state::
  receiver () const
  {
    return this->receiver_.get ();
  }

  INF_state::receiver_type& INF_state::
  receiver ()
  {
    return this->receiver_.get ();
  }

  void INF_state::
  receiver (const receiver_type& x)
  {
    this->receiver_.set (x);
  }


  // INF_error
  // 

  const INF_error::receiver_type& INF_error::
  receiver () const
  {
    return this->receiver_.get ();
  }

  INF_error::receiver_type& INF_error::
  receiver ()
  {
    return this->receiver_.get ();
  }

  void INF_error::
  receiver (const receiver_type& x)
  {
    this->receiver_.set (x);
  }


  // INF_log
  // 

  const INF_log::receiver_type& INF_log::
  receiver () const
  {
    return this->receiver_.get ();
  }

  INF_log::receiver_type& INF_log::
  receiver ()
  {
    return this->receiver_.get ();
  }

  void INF_log::
  receiver (const receiver_type& x)
  {
    this->receiver_.set (x);
  }

  const INF_log::log_category_type& INF_log::
  log_category () const
  {
    return this->log_category_.get ();
  }

  INF_log::log_category_type& INF_log::
  log_category ()
  {
    return this->log_category_.get ();
  }

  void INF_log::
  log_category (const log_category_type& x)
  {
    this->log_category_.set (x);
  }

  const INF_log::log_max_num_type& INF_log::
  log_max_num () const
  {
    return this->log_max_num_.get ();
  }

  INF_log::log_max_num_type& INF_log::
  log_max_num ()
  {
    return this->log_max_num_.get ();
  }

  void INF_log::
  log_max_num (const log_max_num_type& x)
  {
    this->log_max_num_.set (x);
  }


  // DAT_input_output2
  // 

  const DAT_input_output2::SendingPayloadField_sequence& DAT_input_output2::
  SendingPayloadField () const
  {
    return this->SendingPayloadField_;
  }

  DAT_input_output2::SendingPayloadField_sequence& DAT_input_output2::
  SendingPayloadField ()
  {
    return this->SendingPayloadField_;
  }

  void DAT_input_output2::
  SendingPayloadField (const SendingPayloadField_sequence& s)
  {
    this->SendingPayloadField_ = s;
  }

  const DAT_input_output2::data_id_type& DAT_input_output2::
  data_id () const
  {
    return this->data_id_.get ();
  }

  DAT_input_output2::data_id_type& DAT_input_output2::
  data_id ()
  {
    return this->data_id_.get ();
  }

  void DAT_input_output2::
  data_id (const data_id_type& x)
  {
    this->data_id_.set (x);
  }


  // DAT_parameter2
  // 

  const DAT_parameter2::SendingPayloadField_sequence& DAT_parameter2::
  SendingPayloadField () const
  {
    return this->SendingPayloadField_;
  }

  DAT_parameter2::SendingPayloadField_sequence& DAT_parameter2::
  SendingPayloadField ()
  {
    return this->SendingPayloadField_;
  }

  void DAT_parameter2::
  SendingPayloadField (const SendingPayloadField_sequence& s)
  {
    this->SendingPayloadField_ = s;
  }

  const DAT_parameter2::param_id_type& DAT_parameter2::
  param_id () const
  {
    return this->param_id_.get ();
  }

  DAT_parameter2::param_id_type& DAT_parameter2::
  param_id ()
  {
    return this->param_id_.get ();
  }

  void DAT_parameter2::
  param_id (const param_id_type& x)
  {
    this->param_id_.set (x);
  }


  // RSP_ack
  // 

  const RSP_ack::sender_type& RSP_ack::
  sender () const
  {
    return this->sender_.get ();
  }

  RSP_ack::sender_type& RSP_ack::
  sender ()
  {
    return this->sender_.get ();
  }

  void RSP_ack::
  sender (const sender_type& x)
  {
    this->sender_.set (x);
  }


  // RSP_error_ack
  // 

  const RSP_error_ack::sender_type& RSP_error_ack::
  sender () const
  {
    return this->sender_.get ();
  }

  RSP_error_ack::sender_type& RSP_error_ack::
  sender ()
  {
    return this->sender_.get ();
  }

  void RSP_error_ack::
  sender (const sender_type& x)
  {
    this->sender_.set (x);
  }

  const RSP_error_ack::error_code_type& RSP_error_ack::
  error_code () const
  {
    return this->error_code_.get ();
  }

  RSP_error_ack::error_code_type& RSP_error_ack::
  error_code ()
  {
    return this->error_code_.get ();
  }

  void RSP_error_ack::
  error_code (const error_code_type& x)
  {
    this->error_code_.set (x);
  }


  // RSP_nack
  // 

  const RSP_nack::sender_type& RSP_nack::
  sender () const
  {
    return this->sender_.get ();
  }

  RSP_nack::sender_type& RSP_nack::
  sender ()
  {
    return this->sender_.get ();
  }

  void RSP_nack::
  sender (const sender_type& x)
  {
    this->sender_.set (x);
  }

  const RSP_nack::error_code_type& RSP_nack::
  error_code () const
  {
    return this->error_code_.get ();
  }

  RSP_nack::error_code_type& RSP_nack::
  error_code ()
  {
    return this->error_code_.get ();
  }

  void RSP_nack::
  error_code (const error_code_type& x)
  {
    this->error_code_.set (x);
  }

  const RSP_nack::exp_pdu_seq_id_optional& RSP_nack::
  exp_pdu_seq_id () const
  {
    return this->exp_pdu_seq_id_;
  }

  RSP_nack::exp_pdu_seq_id_optional& RSP_nack::
  exp_pdu_seq_id ()
  {
    return this->exp_pdu_seq_id_;
  }

  void RSP_nack::
  exp_pdu_seq_id (const exp_pdu_seq_id_type& x)
  {
    this->exp_pdu_seq_id_.set (x);
  }

  void RSP_nack::
  exp_pdu_seq_id (const exp_pdu_seq_id_optional& x)
  {
    this->exp_pdu_seq_id_ = x;
  }


  // RSP_state_ack
  // 

  const RSP_state_ack::sender_type& RSP_state_ack::
  sender () const
  {
    return this->sender_.get ();
  }

  RSP_state_ack::sender_type& RSP_state_ack::
  sender ()
  {
    return this->sender_.get ();
  }

  void RSP_state_ack::
  sender (const sender_type& x)
  {
    this->sender_.set (x);
  }

  const RSP_state_ack::state_id_type& RSP_state_ack::
  state_id () const
  {
    return this->state_id_.get ();
  }

  RSP_state_ack::state_id_type& RSP_state_ack::
  state_id ()
  {
    return this->state_id_.get ();
  }

  void RSP_state_ack::
  state_id (const state_id_type& x)
  {
    this->state_id_.set (x);
  }


  // NTF_state_changed
  // 

  const NTF_state_changed::sender_type& NTF_state_changed::
  sender () const
  {
    return this->sender_.get ();
  }

  NTF_state_changed::sender_type& NTF_state_changed::
  sender ()
  {
    return this->sender_.get ();
  }

  void NTF_state_changed::
  sender (const sender_type& x)
  {
    this->sender_.set (x);
  }

  const NTF_state_changed::state_id_type& NTF_state_changed::
  state_id () const
  {
    return this->state_id_.get ();
  }

  NTF_state_changed::state_id_type& NTF_state_changed::
  state_id ()
  {
    return this->state_id_.get ();
  }

  void NTF_state_changed::
  state_id (const state_id_type& x)
  {
    this->state_id_.set (x);
  }


  // RSP_log_ack
  // 

  const RSP_log_ack::sender_type& RSP_log_ack::
  sender () const
  {
    return this->sender_.get ();
  }

  RSP_log_ack::sender_type& RSP_log_ack::
  sender ()
  {
    return this->sender_.get ();
  }

  void RSP_log_ack::
  sender (const sender_type& x)
  {
    this->sender_.set (x);
  }

  const RSP_log_ack::length_type& RSP_log_ack::
  length () const
  {
    return this->length_.get ();
  }

  RSP_log_ack::length_type& RSP_log_ack::
  length ()
  {
    return this->length_.get ();
  }

  void RSP_log_ack::
  length (const length_type& x)
  {
    this->length_.set (x);
  }


  // NTF_log
  // 

  const NTF_log::sender_type& NTF_log::
  sender () const
  {
    return this->sender_.get ();
  }

  NTF_log::sender_type& NTF_log::
  sender ()
  {
    return this->sender_.get ();
  }

  void NTF_log::
  sender (const sender_type& x)
  {
    this->sender_.set (x);
  }

  const NTF_log::length_type& NTF_log::
  length () const
  {
    return this->length_.get ();
  }

  NTF_log::length_type& NTF_log::
  length ()
  {
    return this->length_.get ();
  }

  void NTF_log::
  length (const length_type& x)
  {
    this->length_.set (x);
  }


  // DAT_input_output3
  // 

  const DAT_input_output3::ReceivingPayloadField_sequence& DAT_input_output3::
  ReceivingPayloadField () const
  {
    return this->ReceivingPayloadField_;
  }

  DAT_input_output3::ReceivingPayloadField_sequence& DAT_input_output3::
  ReceivingPayloadField ()
  {
    return this->ReceivingPayloadField_;
  }

  void DAT_input_output3::
  ReceivingPayloadField (const ReceivingPayloadField_sequence& s)
  {
    this->ReceivingPayloadField_ = s;
  }

  const DAT_input_output3::data_id_type& DAT_input_output3::
  data_id () const
  {
    return this->data_id_.get ();
  }

  DAT_input_output3::data_id_type& DAT_input_output3::
  data_id ()
  {
    return this->data_id_.get ();
  }

  void DAT_input_output3::
  data_id (const data_id_type& x)
  {
    this->data_id_.set (x);
  }


  // DAT_parameter3
  // 

  const DAT_parameter3::ReceivingPayloadField_sequence& DAT_parameter3::
  ReceivingPayloadField () const
  {
    return this->ReceivingPayloadField_;
  }

  DAT_parameter3::ReceivingPayloadField_sequence& DAT_parameter3::
  ReceivingPayloadField ()
  {
    return this->ReceivingPayloadField_;
  }

  void DAT_parameter3::
  ReceivingPayloadField (const ReceivingPayloadField_sequence& s)
  {
    this->ReceivingPayloadField_ = s;
  }

  const DAT_parameter3::param_id_type& DAT_parameter3::
  param_id () const
  {
    return this->param_id_.get ();
  }

  DAT_parameter3::param_id_type& DAT_parameter3::
  param_id ()
  {
    return this->param_id_.get ();
  }

  void DAT_parameter3::
  param_id (const param_id_type& x)
  {
    this->param_id_.set (x);
  }


  // AvailablePortRange
  // 

  const AvailablePortRange::from_type& AvailablePortRange::
  from () const
  {
    return this->from_.get ();
  }

  AvailablePortRange::from_type& AvailablePortRange::
  from ()
  {
    return this->from_.get ();
  }

  void AvailablePortRange::
  from (const from_type& x)
  {
    this->from_.set (x);
  }

  const AvailablePortRange::to_type& AvailablePortRange::
  to () const
  {
    return this->to_.get ();
  }

  AvailablePortRange::to_type& AvailablePortRange::
  to ()
  {
    return this->to_.get ();
  }

  void AvailablePortRange::
  to (const to_type& x)
  {
    this->to_.set (x);
  }


  // AvailablePort
  // 

  const AvailablePort::port_type& AvailablePort::
  port () const
  {
    return this->port_.get ();
  }

  AvailablePort::port_type& AvailablePort::
  port ()
  {
    return this->port_.get ();
  }

  void AvailablePort::
  port (const port_type& x)
  {
    this->port_.set (x);
  }


  // direction
  // 

  direction::
  direction (value v)
  : ::xml_schema::string (_xsd_direction_literals_[v])
  {
  }

  direction::
  direction (const char* v)
  : ::xml_schema::string (v)
  {
  }

  direction::
  direction (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  direction::
  direction (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  direction::
  direction (const direction& v,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  direction& direction::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_direction_literals_[v]);

    return *this;
  }


  // bd_addr
  // 


  // port
  // 


  // slave_uuid
  // 


  // Payload
  // 

  const Payload::Int8_optional& Payload::
  Int8 () const
  {
    return this->Int8_;
  }

  Payload::Int8_optional& Payload::
  Int8 ()
  {
    return this->Int8_;
  }

  void Payload::
  Int8 (const Int8_type& x)
  {
    this->Int8_.set (x);
  }

  void Payload::
  Int8 (const Int8_optional& x)
  {
    this->Int8_ = x;
  }

  void Payload::
  Int8 (::std::auto_ptr< Int8_type > x)
  {
    this->Int8_.set (x);
  }

  const Payload::Int16_optional& Payload::
  Int16 () const
  {
    return this->Int16_;
  }

  Payload::Int16_optional& Payload::
  Int16 ()
  {
    return this->Int16_;
  }

  void Payload::
  Int16 (const Int16_type& x)
  {
    this->Int16_.set (x);
  }

  void Payload::
  Int16 (const Int16_optional& x)
  {
    this->Int16_ = x;
  }

  void Payload::
  Int16 (::std::auto_ptr< Int16_type > x)
  {
    this->Int16_.set (x);
  }

  const Payload::Int32_optional& Payload::
  Int32 () const
  {
    return this->Int32_;
  }

  Payload::Int32_optional& Payload::
  Int32 ()
  {
    return this->Int32_;
  }

  void Payload::
  Int32 (const Int32_type& x)
  {
    this->Int32_.set (x);
  }

  void Payload::
  Int32 (const Int32_optional& x)
  {
    this->Int32_ = x;
  }

  void Payload::
  Int32 (::std::auto_ptr< Int32_type > x)
  {
    this->Int32_.set (x);
  }

  const Payload::Int64_optional& Payload::
  Int64 () const
  {
    return this->Int64_;
  }

  Payload::Int64_optional& Payload::
  Int64 ()
  {
    return this->Int64_;
  }

  void Payload::
  Int64 (const Int64_type& x)
  {
    this->Int64_.set (x);
  }

  void Payload::
  Int64 (const Int64_optional& x)
  {
    this->Int64_ = x;
  }

  void Payload::
  Int64 (::std::auto_ptr< Int64_type > x)
  {
    this->Int64_.set (x);
  }

  const Payload::Uint8_optional& Payload::
  Uint8 () const
  {
    return this->Uint8_;
  }

  Payload::Uint8_optional& Payload::
  Uint8 ()
  {
    return this->Uint8_;
  }

  void Payload::
  Uint8 (const Uint8_type& x)
  {
    this->Uint8_.set (x);
  }

  void Payload::
  Uint8 (const Uint8_optional& x)
  {
    this->Uint8_ = x;
  }

  void Payload::
  Uint8 (::std::auto_ptr< Uint8_type > x)
  {
    this->Uint8_.set (x);
  }

  const Payload::Uint16_optional& Payload::
  Uint16 () const
  {
    return this->Uint16_;
  }

  Payload::Uint16_optional& Payload::
  Uint16 ()
  {
    return this->Uint16_;
  }

  void Payload::
  Uint16 (const Uint16_type& x)
  {
    this->Uint16_.set (x);
  }

  void Payload::
  Uint16 (const Uint16_optional& x)
  {
    this->Uint16_ = x;
  }

  void Payload::
  Uint16 (::std::auto_ptr< Uint16_type > x)
  {
    this->Uint16_.set (x);
  }

  const Payload::Uint32_optional& Payload::
  Uint32 () const
  {
    return this->Uint32_;
  }

  Payload::Uint32_optional& Payload::
  Uint32 ()
  {
    return this->Uint32_;
  }

  void Payload::
  Uint32 (const Uint32_type& x)
  {
    this->Uint32_.set (x);
  }

  void Payload::
  Uint32 (const Uint32_optional& x)
  {
    this->Uint32_ = x;
  }

  void Payload::
  Uint32 (::std::auto_ptr< Uint32_type > x)
  {
    this->Uint32_.set (x);
  }

  const Payload::Uint64_optional& Payload::
  Uint64 () const
  {
    return this->Uint64_;
  }

  Payload::Uint64_optional& Payload::
  Uint64 ()
  {
    return this->Uint64_;
  }

  void Payload::
  Uint64 (const Uint64_type& x)
  {
    this->Uint64_.set (x);
  }

  void Payload::
  Uint64 (const Uint64_optional& x)
  {
    this->Uint64_ = x;
  }

  void Payload::
  Uint64 (::std::auto_ptr< Uint64_type > x)
  {
    this->Uint64_.set (x);
  }

  const Payload::Float32_optional& Payload::
  Float32 () const
  {
    return this->Float32_;
  }

  Payload::Float32_optional& Payload::
  Float32 ()
  {
    return this->Float32_;
  }

  void Payload::
  Float32 (const Float32_type& x)
  {
    this->Float32_.set (x);
  }

  void Payload::
  Float32 (const Float32_optional& x)
  {
    this->Float32_ = x;
  }

  void Payload::
  Float32 (::std::auto_ptr< Float32_type > x)
  {
    this->Float32_.set (x);
  }

  const Payload::Float64_optional& Payload::
  Float64 () const
  {
    return this->Float64_;
  }

  Payload::Float64_optional& Payload::
  Float64 ()
  {
    return this->Float64_;
  }

  void Payload::
  Float64 (const Float64_type& x)
  {
    this->Float64_.set (x);
  }

  void Payload::
  Float64 (const Float64_optional& x)
  {
    this->Float64_ = x;
  }

  void Payload::
  Float64 (::std::auto_ptr< Float64_type > x)
  {
    this->Float64_.set (x);
  }

  const Payload::String_optional& Payload::
  String () const
  {
    return this->String_;
  }

  Payload::String_optional& Payload::
  String ()
  {
    return this->String_;
  }

  void Payload::
  String (const String_type& x)
  {
    this->String_.set (x);
  }

  void Payload::
  String (const String_optional& x)
  {
    this->String_ = x;
  }

  void Payload::
  String (::std::auto_ptr< String_type > x)
  {
    this->String_.set (x);
  }

  const Payload::Binary_optional& Payload::
  Binary () const
  {
    return this->Binary_;
  }

  Payload::Binary_optional& Payload::
  Binary ()
  {
    return this->Binary_;
  }

  void Payload::
  Binary (const Binary_type& x)
  {
    this->Binary_.set (x);
  }

  void Payload::
  Binary (const Binary_optional& x)
  {
    this->Binary_ = x;
  }

  void Payload::
  Binary (::std::auto_ptr< Binary_type > x)
  {
    this->Binary_.set (x);
  }


  // Int82
  // 

  const Int82::value_type& Int82::
  value () const
  {
    return this->value_.get ();
  }

  Int82::value_type& Int82::
  value ()
  {
    return this->value_.get ();
  }

  void Int82::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void Int82::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }


  // Int162
  // 

  const Int162::value_type& Int162::
  value () const
  {
    return this->value_.get ();
  }

  Int162::value_type& Int162::
  value ()
  {
    return this->value_.get ();
  }

  void Int162::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void Int162::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }


  // Int322
  // 

  const Int322::value_type& Int322::
  value () const
  {
    return this->value_.get ();
  }

  Int322::value_type& Int322::
  value ()
  {
    return this->value_.get ();
  }

  void Int322::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void Int322::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }


  // Int642
  // 

  const Int642::value_type& Int642::
  value () const
  {
    return this->value_.get ();
  }

  Int642::value_type& Int642::
  value ()
  {
    return this->value_.get ();
  }

  void Int642::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void Int642::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }


  // Uint82
  // 

  const Uint82::value_type& Uint82::
  value () const
  {
    return this->value_.get ();
  }

  Uint82::value_type& Uint82::
  value ()
  {
    return this->value_.get ();
  }

  void Uint82::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void Uint82::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }


  // Uint162
  // 

  const Uint162::value_type& Uint162::
  value () const
  {
    return this->value_.get ();
  }

  Uint162::value_type& Uint162::
  value ()
  {
    return this->value_.get ();
  }

  void Uint162::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void Uint162::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }


  // Uint322
  // 

  const Uint322::value_type& Uint322::
  value () const
  {
    return this->value_.get ();
  }

  Uint322::value_type& Uint322::
  value ()
  {
    return this->value_.get ();
  }

  void Uint322::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void Uint322::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }


  // Uint642
  // 

  const Uint642::value_type& Uint642::
  value () const
  {
    return this->value_.get ();
  }

  Uint642::value_type& Uint642::
  value ()
  {
    return this->value_.get ();
  }

  void Uint642::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void Uint642::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }


  // Float322
  // 

  const Float322::value_type& Float322::
  value () const
  {
    return this->value_.get ();
  }

  Float322::value_type& Float322::
  value ()
  {
    return this->value_.get ();
  }

  void Float322::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void Float322::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }


  // Float642
  // 

  const Float642::value_type& Float642::
  value () const
  {
    return this->value_.get ();
  }

  Float642::value_type& Float642::
  value ()
  {
    return this->value_.get ();
  }

  void Float642::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void Float642::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }


  // value20
  //

  value20::
  value20 ()
  : ::xsd::cxx::tree::list< ::xml_schema::byte, char > (this)
  {
  }

  value20::
  value20 (size_type n, const ::xml_schema::byte& x)
  : ::xsd::cxx::tree::list< ::xml_schema::byte, char > (n, x, this)
  {
  }

  value20::
  value20 (const value20& o,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::byte, char > (o, f, this)
  {
  }

  // value21
  //

  value21::
  value21 ()
  : ::xsd::cxx::tree::list< ::xml_schema::short_, char > (this)
  {
  }

  value21::
  value21 (size_type n, const ::xml_schema::short_& x)
  : ::xsd::cxx::tree::list< ::xml_schema::short_, char > (n, x, this)
  {
  }

  value21::
  value21 (const value21& o,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::short_, char > (o, f, this)
  {
  }

  // value22
  //

  value22::
  value22 ()
  : ::xsd::cxx::tree::list< ::xml_schema::int_, char > (this)
  {
  }

  value22::
  value22 (size_type n, const ::xml_schema::int_& x)
  : ::xsd::cxx::tree::list< ::xml_schema::int_, char > (n, x, this)
  {
  }

  value22::
  value22 (const value22& o,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::int_, char > (o, f, this)
  {
  }

  // value23
  //

  value23::
  value23 ()
  : ::xsd::cxx::tree::list< ::xml_schema::long_, char > (this)
  {
  }

  value23::
  value23 (size_type n, const ::xml_schema::long_& x)
  : ::xsd::cxx::tree::list< ::xml_schema::long_, char > (n, x, this)
  {
  }

  value23::
  value23 (const value23& o,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::long_, char > (o, f, this)
  {
  }

  // value24
  //

  value24::
  value24 ()
  : ::xsd::cxx::tree::list< ::xml_schema::unsigned_byte, char > (this)
  {
  }

  value24::
  value24 (size_type n, const ::xml_schema::unsigned_byte& x)
  : ::xsd::cxx::tree::list< ::xml_schema::unsigned_byte, char > (n, x, this)
  {
  }

  value24::
  value24 (const value24& o,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_byte, char > (o, f, this)
  {
  }

  // value25
  //

  value25::
  value25 ()
  : ::xsd::cxx::tree::list< ::xml_schema::unsigned_short, char > (this)
  {
  }

  value25::
  value25 (size_type n, const ::xml_schema::unsigned_short& x)
  : ::xsd::cxx::tree::list< ::xml_schema::unsigned_short, char > (n, x, this)
  {
  }

  value25::
  value25 (const value25& o,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_short, char > (o, f, this)
  {
  }

  // value26
  //

  value26::
  value26 ()
  : ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char > (this)
  {
  }

  value26::
  value26 (size_type n, const ::xml_schema::unsigned_int& x)
  : ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char > (n, x, this)
  {
  }

  value26::
  value26 (const value26& o,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char > (o, f, this)
  {
  }

  // value27
  //

  value27::
  value27 ()
  : ::xsd::cxx::tree::list< ::xml_schema::unsigned_long, char > (this)
  {
  }

  value27::
  value27 (size_type n, const ::xml_schema::unsigned_long& x)
  : ::xsd::cxx::tree::list< ::xml_schema::unsigned_long, char > (n, x, this)
  {
  }

  value27::
  value27 (const value27& o,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_long, char > (o, f, this)
  {
  }

  // value28
  //

  value28::
  value28 ()
  : ::xsd::cxx::tree::list< ::xml_schema::float_, char > (this)
  {
  }

  value28::
  value28 (size_type n, const ::xml_schema::float_& x)
  : ::xsd::cxx::tree::list< ::xml_schema::float_, char > (n, x, this)
  {
  }

  value28::
  value28 (const value28& o,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::float_, char > (o, f, this)
  {
  }

  // value29
  //

  value29::
  value29 ()
  : ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (this)
  {
  }

  value29::
  value29 (size_type n, const ::xml_schema::double_& x)
  : ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (n, x, this)
  {
  }

  value29::
  value29 (const value29& o,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (o, f, this)
  {
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace DcpTestSuite
{
  // DcpTestProcedure
  //

  DcpTestProcedure::
  DcpTestProcedure (const TransportProtocols_type& TransportProtocols,
                    const version_type& version)
  : ::xml_schema::type (),
    TransportProtocols_ (TransportProtocols, this),
    Transition_ (this),
    version_ (version, this),
    name_ (this),
    acceptingSteps_ (this)
  {
  }

  DcpTestProcedure::
  DcpTestProcedure (::std::auto_ptr< TransportProtocols_type > TransportProtocols,
                    const version_type& version)
  : ::xml_schema::type (),
    TransportProtocols_ (TransportProtocols, this),
    Transition_ (this),
    version_ (version, this),
    name_ (this),
    acceptingSteps_ (this)
  {
  }

  DcpTestProcedure::
  DcpTestProcedure (const DcpTestProcedure& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    TransportProtocols_ (x.TransportProtocols_, f, this),
    Transition_ (x.Transition_, f, this),
    version_ (x.version_, f, this),
    name_ (x.name_, f, this),
    acceptingSteps_ (x.acceptingSteps_, f, this)
  {
  }

  DcpTestProcedure::
  DcpTestProcedure (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    TransportProtocols_ (this),
    Transition_ (this),
    version_ (this),
    name_ (this),
    acceptingSteps_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void DcpTestProcedure::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // TransportProtocols
      //
      if (n.name () == "TransportProtocols" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< TransportProtocols_type > r (
          TransportProtocols_traits::create (i, f, this));

        if (!TransportProtocols_.present ())
        {
          this->TransportProtocols_.set (r);
          continue;
        }
      }

      // Transition
      //
      if (n.name () == "Transition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Transition_type > r (
          Transition_traits::create (i, f, this));

        this->Transition_.push_back (r);
        continue;
      }

      break;
    }

    if (!TransportProtocols_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "TransportProtocols",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "version" && n.namespace_ ().empty ())
      {
        this->version_.set (version_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "acceptingSteps" && n.namespace_ ().empty ())
      {
        this->acceptingSteps_.set (acceptingSteps_traits::create (i, f, this));
        continue;
      }
    }

    if (!version_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "version",
        "");
    }
  }

  DcpTestProcedure* DcpTestProcedure::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DcpTestProcedure (*this, f, c);
  }

  DcpTestProcedure& DcpTestProcedure::
  operator= (const DcpTestProcedure& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->TransportProtocols_ = x.TransportProtocols_;
      this->Transition_ = x.Transition_;
      this->version_ = x.version_;
      this->name_ = x.name_;
      this->acceptingSteps_ = x.acceptingSteps_;
    }

    return *this;
  }

  DcpTestProcedure::
  ~DcpTestProcedure ()
  {
  }

  // SendingPayloadField
  //

  SendingPayloadField::
  SendingPayloadField (const pos_type& pos)
  : ::xml_schema::type (),
    Int8_ (this),
    Int16_ (this),
    Int32_ (this),
    Int64_ (this),
    Uint8_ (this),
    Uint16_ (this),
    Uint32_ (this),
    Uint64_ (this),
    Float32_ (this),
    Float64_ (this),
    String_ (this),
    Binary_ (this),
    pos_ (pos, this)
  {
  }

  SendingPayloadField::
  SendingPayloadField (const SendingPayloadField& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Int8_ (x.Int8_, f, this),
    Int16_ (x.Int16_, f, this),
    Int32_ (x.Int32_, f, this),
    Int64_ (x.Int64_, f, this),
    Uint8_ (x.Uint8_, f, this),
    Uint16_ (x.Uint16_, f, this),
    Uint32_ (x.Uint32_, f, this),
    Uint64_ (x.Uint64_, f, this),
    Float32_ (x.Float32_, f, this),
    Float64_ (x.Float64_, f, this),
    String_ (x.String_, f, this),
    Binary_ (x.Binary_, f, this),
    pos_ (x.pos_, f, this)
  {
  }

  SendingPayloadField::
  SendingPayloadField (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Int8_ (this),
    Int16_ (this),
    Int32_ (this),
    Int64_ (this),
    Uint8_ (this),
    Uint16_ (this),
    Uint32_ (this),
    Uint64_ (this),
    Float32_ (this),
    Float64_ (this),
    String_ (this),
    Binary_ (this),
    pos_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SendingPayloadField::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Int8
      //
      if (n.name () == "Int8" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Int8_type > r (
          Int8_traits::create (i, f, this));

        if (!this->Int8_)
        {
          this->Int8_.set (r);
          continue;
        }
      }

      // Int16
      //
      if (n.name () == "Int16" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Int16_type > r (
          Int16_traits::create (i, f, this));

        if (!this->Int16_)
        {
          this->Int16_.set (r);
          continue;
        }
      }

      // Int32
      //
      if (n.name () == "Int32" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Int32_type > r (
          Int32_traits::create (i, f, this));

        if (!this->Int32_)
        {
          this->Int32_.set (r);
          continue;
        }
      }

      // Int64
      //
      if (n.name () == "Int64" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Int64_type > r (
          Int64_traits::create (i, f, this));

        if (!this->Int64_)
        {
          this->Int64_.set (r);
          continue;
        }
      }

      // Uint8
      //
      if (n.name () == "Uint8" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Uint8_type > r (
          Uint8_traits::create (i, f, this));

        if (!this->Uint8_)
        {
          this->Uint8_.set (r);
          continue;
        }
      }

      // Uint16
      //
      if (n.name () == "Uint16" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Uint16_type > r (
          Uint16_traits::create (i, f, this));

        if (!this->Uint16_)
        {
          this->Uint16_.set (r);
          continue;
        }
      }

      // Uint32
      //
      if (n.name () == "Uint32" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Uint32_type > r (
          Uint32_traits::create (i, f, this));

        if (!this->Uint32_)
        {
          this->Uint32_.set (r);
          continue;
        }
      }

      // Uint64
      //
      if (n.name () == "Uint64" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Uint64_type > r (
          Uint64_traits::create (i, f, this));

        if (!this->Uint64_)
        {
          this->Uint64_.set (r);
          continue;
        }
      }

      // Float32
      //
      if (n.name () == "Float32" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Float32_type > r (
          Float32_traits::create (i, f, this));

        if (!this->Float32_)
        {
          this->Float32_.set (r);
          continue;
        }
      }

      // Float64
      //
      if (n.name () == "Float64" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Float64_type > r (
          Float64_traits::create (i, f, this));

        if (!this->Float64_)
        {
          this->Float64_.set (r);
          continue;
        }
      }

      // String
      //
      if (n.name () == "String" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< String_type > r (
          String_traits::create (i, f, this));

        if (!this->String_)
        {
          this->String_.set (r);
          continue;
        }
      }

      // Binary
      //
      if (n.name () == "Binary" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Binary_type > r (
          Binary_traits::create (i, f, this));

        if (!this->Binary_)
        {
          this->Binary_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "pos" && n.namespace_ ().empty ())
      {
        this->pos_.set (pos_traits::create (i, f, this));
        continue;
      }
    }

    if (!pos_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "pos",
        "");
    }
  }

  SendingPayloadField* SendingPayloadField::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SendingPayloadField (*this, f, c);
  }

  SendingPayloadField& SendingPayloadField::
  operator= (const SendingPayloadField& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Int8_ = x.Int8_;
      this->Int16_ = x.Int16_;
      this->Int32_ = x.Int32_;
      this->Int64_ = x.Int64_;
      this->Uint8_ = x.Uint8_;
      this->Uint16_ = x.Uint16_;
      this->Uint32_ = x.Uint32_;
      this->Uint64_ = x.Uint64_;
      this->Float32_ = x.Float32_;
      this->Float64_ = x.Float64_;
      this->String_ = x.String_;
      this->Binary_ = x.Binary_;
      this->pos_ = x.pos_;
    }

    return *this;
  }

  SendingPayloadField::
  ~SendingPayloadField ()
  {
  }

  // ReceivingPayloadField
  //

  ReceivingPayloadField::
  ReceivingPayloadField (const pos_type& pos)
  : ::xml_schema::type (),
    Int8_ (this),
    Int16_ (this),
    Int32_ (this),
    Int64_ (this),
    Uint8_ (this),
    Uint16_ (this),
    Uint32_ (this),
    Uint64_ (this),
    Float32_ (this),
    Float64_ (this),
    String_ (this),
    Binary_ (this),
    pos_ (pos, this)
  {
  }

  ReceivingPayloadField::
  ReceivingPayloadField (const ReceivingPayloadField& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Int8_ (x.Int8_, f, this),
    Int16_ (x.Int16_, f, this),
    Int32_ (x.Int32_, f, this),
    Int64_ (x.Int64_, f, this),
    Uint8_ (x.Uint8_, f, this),
    Uint16_ (x.Uint16_, f, this),
    Uint32_ (x.Uint32_, f, this),
    Uint64_ (x.Uint64_, f, this),
    Float32_ (x.Float32_, f, this),
    Float64_ (x.Float64_, f, this),
    String_ (x.String_, f, this),
    Binary_ (x.Binary_, f, this),
    pos_ (x.pos_, f, this)
  {
  }

  ReceivingPayloadField::
  ReceivingPayloadField (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Int8_ (this),
    Int16_ (this),
    Int32_ (this),
    Int64_ (this),
    Uint8_ (this),
    Uint16_ (this),
    Uint32_ (this),
    Uint64_ (this),
    Float32_ (this),
    Float64_ (this),
    String_ (this),
    Binary_ (this),
    pos_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ReceivingPayloadField::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Int8
      //
      if (n.name () == "Int8" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Int8_type > r (
          Int8_traits::create (i, f, this));

        if (!this->Int8_)
        {
          this->Int8_.set (r);
          continue;
        }
      }

      // Int16
      //
      if (n.name () == "Int16" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Int16_type > r (
          Int16_traits::create (i, f, this));

        if (!this->Int16_)
        {
          this->Int16_.set (r);
          continue;
        }
      }

      // Int32
      //
      if (n.name () == "Int32" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Int32_type > r (
          Int32_traits::create (i, f, this));

        if (!this->Int32_)
        {
          this->Int32_.set (r);
          continue;
        }
      }

      // Int64
      //
      if (n.name () == "Int64" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Int64_type > r (
          Int64_traits::create (i, f, this));

        if (!this->Int64_)
        {
          this->Int64_.set (r);
          continue;
        }
      }

      // Uint8
      //
      if (n.name () == "Uint8" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Uint8_type > r (
          Uint8_traits::create (i, f, this));

        if (!this->Uint8_)
        {
          this->Uint8_.set (r);
          continue;
        }
      }

      // Uint16
      //
      if (n.name () == "Uint16" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Uint16_type > r (
          Uint16_traits::create (i, f, this));

        if (!this->Uint16_)
        {
          this->Uint16_.set (r);
          continue;
        }
      }

      // Uint32
      //
      if (n.name () == "Uint32" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Uint32_type > r (
          Uint32_traits::create (i, f, this));

        if (!this->Uint32_)
        {
          this->Uint32_.set (r);
          continue;
        }
      }

      // Uint64
      //
      if (n.name () == "Uint64" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Uint64_type > r (
          Uint64_traits::create (i, f, this));

        if (!this->Uint64_)
        {
          this->Uint64_.set (r);
          continue;
        }
      }

      // Float32
      //
      if (n.name () == "Float32" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Float32_type > r (
          Float32_traits::create (i, f, this));

        if (!this->Float32_)
        {
          this->Float32_.set (r);
          continue;
        }
      }

      // Float64
      //
      if (n.name () == "Float64" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Float64_type > r (
          Float64_traits::create (i, f, this));

        if (!this->Float64_)
        {
          this->Float64_.set (r);
          continue;
        }
      }

      // String
      //
      if (n.name () == "String" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< String_type > r (
          String_traits::create (i, f, this));

        if (!this->String_)
        {
          this->String_.set (r);
          continue;
        }
      }

      // Binary
      //
      if (n.name () == "Binary" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Binary_type > r (
          Binary_traits::create (i, f, this));

        if (!this->Binary_)
        {
          this->Binary_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "pos" && n.namespace_ ().empty ())
      {
        this->pos_.set (pos_traits::create (i, f, this));
        continue;
      }
    }

    if (!pos_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "pos",
        "");
    }
  }

  ReceivingPayloadField* ReceivingPayloadField::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ReceivingPayloadField (*this, f, c);
  }

  ReceivingPayloadField& ReceivingPayloadField::
  operator= (const ReceivingPayloadField& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Int8_ = x.Int8_;
      this->Int16_ = x.Int16_;
      this->Int32_ = x.Int32_;
      this->Int64_ = x.Int64_;
      this->Uint8_ = x.Uint8_;
      this->Uint16_ = x.Uint16_;
      this->Uint32_ = x.Uint32_;
      this->Uint64_ = x.Uint64_;
      this->Float32_ = x.Float32_;
      this->Float64_ = x.Float64_;
      this->String_ = x.String_;
      this->Binary_ = x.Binary_;
      this->pos_ = x.pos_;
    }

    return *this;
  }

  ReceivingPayloadField::
  ~ReceivingPayloadField ()
  {
  }

  // TransportProtocols
  //

  TransportProtocols::
  TransportProtocols ()
  : ::xml_schema::type (),
    UDP_IPv4_ (this),
    CAN_ (this),
    USB_ (this),
    Bluetooth_ (this),
    TCP_IPv4_ (this)
  {
  }

  TransportProtocols::
  TransportProtocols (const TransportProtocols& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    UDP_IPv4_ (x.UDP_IPv4_, f, this),
    CAN_ (x.CAN_, f, this),
    USB_ (x.USB_, f, this),
    Bluetooth_ (x.Bluetooth_, f, this),
    TCP_IPv4_ (x.TCP_IPv4_, f, this)
  {
  }

  TransportProtocols::
  TransportProtocols (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    UDP_IPv4_ (this),
    CAN_ (this),
    USB_ (this),
    Bluetooth_ (this),
    TCP_IPv4_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void TransportProtocols::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // UDP_IPv4
      //
      if (n.name () == "UDP_IPv4" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< UDP_IPv4_type > r (
          UDP_IPv4_traits::create (i, f, this));

        if (!this->UDP_IPv4_)
        {
          this->UDP_IPv4_.set (r);
          continue;
        }
      }

      // CAN
      //
      if (n.name () == "CAN" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< CAN_type > r (
          CAN_traits::create (i, f, this));

        if (!this->CAN_)
        {
          this->CAN_.set (r);
          continue;
        }
      }

      // USB
      //
      if (n.name () == "USB" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< USB_type > r (
          USB_traits::create (i, f, this));

        if (!this->USB_)
        {
          this->USB_.set (r);
          continue;
        }
      }

      // Bluetooth
      //
      if (n.name () == "Bluetooth" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Bluetooth_type > r (
          Bluetooth_traits::create (i, f, this));

        if (!this->Bluetooth_)
        {
          this->Bluetooth_.set (r);
          continue;
        }
      }

      // TCP_IPv4
      //
      if (n.name () == "TCP_IPv4" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< TCP_IPv4_type > r (
          TCP_IPv4_traits::create (i, f, this));

        if (!this->TCP_IPv4_)
        {
          this->TCP_IPv4_.set (r);
          continue;
        }
      }

      break;
    }
  }

  TransportProtocols* TransportProtocols::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TransportProtocols (*this, f, c);
  }

  TransportProtocols& TransportProtocols::
  operator= (const TransportProtocols& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->UDP_IPv4_ = x.UDP_IPv4_;
      this->CAN_ = x.CAN_;
      this->USB_ = x.USB_;
      this->Bluetooth_ = x.Bluetooth_;
      this->TCP_IPv4_ = x.TCP_IPv4_;
    }

    return *this;
  }

  TransportProtocols::
  ~TransportProtocols ()
  {
  }

  // Transition
  //

  Transition::
  Transition (const from_type& from,
              const to_type& to)
  : ::xml_schema::type (),
    Sending_ (this),
    Receiving_ (this),
    from_ (from, this),
    to_ (to, this),
    log_ (log_default_value (), this)
  {
  }

  Transition::
  Transition (const Transition& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Sending_ (x.Sending_, f, this),
    Receiving_ (x.Receiving_, f, this),
    from_ (x.from_, f, this),
    to_ (x.to_, f, this),
    log_ (x.log_, f, this)
  {
  }

  Transition::
  Transition (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Sending_ (this),
    Receiving_ (this),
    from_ (this),
    to_ (this),
    log_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Transition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Sending
      //
      if (n.name () == "Sending" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Sending_type > r (
          Sending_traits::create (i, f, this));

        if (!this->Sending_)
        {
          this->Sending_.set (r);
          continue;
        }
      }

      // Receiving
      //
      if (n.name () == "Receiving" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Receiving_type > r (
          Receiving_traits::create (i, f, this));

        if (!this->Receiving_)
        {
          this->Receiving_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "from" && n.namespace_ ().empty ())
      {
        this->from_.set (from_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "to" && n.namespace_ ().empty ())
      {
        this->to_.set (to_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "log" && n.namespace_ ().empty ())
      {
        this->log_.set (log_traits::create (i, f, this));
        continue;
      }
    }

    if (!from_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "from",
        "");
    }

    if (!to_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "to",
        "");
    }

    if (!log_.present ())
    {
      this->log_.set (log_default_value ());
    }
  }

  Transition* Transition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Transition (*this, f, c);
  }

  Transition& Transition::
  operator= (const Transition& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Sending_ = x.Sending_;
      this->Receiving_ = x.Receiving_;
      this->from_ = x.from_;
      this->to_ = x.to_;
      this->log_ = x.log_;
    }

    return *this;
  }

  Transition::
  ~Transition ()
  {
  }

  // acceptingSteps
  //

  acceptingSteps::
  acceptingSteps (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char > (e, f, this)
  {
  }

  acceptingSteps::
  acceptingSteps (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char > (a, f, this)
  {
  }

  acceptingSteps::
  acceptingSteps (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char > (s, e, f, this)
  {
  }

  acceptingSteps* acceptingSteps::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class acceptingSteps (*this, f, c);
  }

  acceptingSteps::
  ~acceptingSteps ()
  {
  }

  // Int8
  //

  Int8::
  Int8 (const value_type& value)
  : ::xml_schema::type (),
    value_ (value, this)
  {
  }

  Int8::
  Int8 (const Int8& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    value_ (x.value_, f, this)
  {
  }

  Int8::
  Int8 (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    value_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Int8::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  Int8* Int8::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Int8 (*this, f, c);
  }

  Int8& Int8::
  operator= (const Int8& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->value_ = x.value_;
    }

    return *this;
  }

  Int8::
  ~Int8 ()
  {
  }

  // Int16
  //

  Int16::
  Int16 (const value_type& value)
  : ::xml_schema::type (),
    value_ (value, this)
  {
  }

  Int16::
  Int16 (const Int16& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    value_ (x.value_, f, this)
  {
  }

  Int16::
  Int16 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    value_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Int16::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  Int16* Int16::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Int16 (*this, f, c);
  }

  Int16& Int16::
  operator= (const Int16& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->value_ = x.value_;
    }

    return *this;
  }

  Int16::
  ~Int16 ()
  {
  }

  // Int32
  //

  Int32::
  Int32 (const value_type& value)
  : ::xml_schema::type (),
    value_ (value, this)
  {
  }

  Int32::
  Int32 (const Int32& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    value_ (x.value_, f, this)
  {
  }

  Int32::
  Int32 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    value_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Int32::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  Int32* Int32::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Int32 (*this, f, c);
  }

  Int32& Int32::
  operator= (const Int32& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->value_ = x.value_;
    }

    return *this;
  }

  Int32::
  ~Int32 ()
  {
  }

  // Int64
  //

  Int64::
  Int64 (const value_type& value)
  : ::xml_schema::type (),
    value_ (value, this)
  {
  }

  Int64::
  Int64 (const Int64& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    value_ (x.value_, f, this)
  {
  }

  Int64::
  Int64 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    value_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Int64::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  Int64* Int64::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Int64 (*this, f, c);
  }

  Int64& Int64::
  operator= (const Int64& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->value_ = x.value_;
    }

    return *this;
  }

  Int64::
  ~Int64 ()
  {
  }

  // Uint8
  //

  Uint8::
  Uint8 (const value_type& value)
  : ::xml_schema::type (),
    value_ (value, this)
  {
  }

  Uint8::
  Uint8 (const Uint8& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    value_ (x.value_, f, this)
  {
  }

  Uint8::
  Uint8 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    value_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Uint8::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  Uint8* Uint8::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Uint8 (*this, f, c);
  }

  Uint8& Uint8::
  operator= (const Uint8& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->value_ = x.value_;
    }

    return *this;
  }

  Uint8::
  ~Uint8 ()
  {
  }

  // Uint16
  //

  Uint16::
  Uint16 (const value_type& value)
  : ::xml_schema::type (),
    value_ (value, this)
  {
  }

  Uint16::
  Uint16 (const Uint16& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    value_ (x.value_, f, this)
  {
  }

  Uint16::
  Uint16 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    value_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Uint16::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  Uint16* Uint16::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Uint16 (*this, f, c);
  }

  Uint16& Uint16::
  operator= (const Uint16& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->value_ = x.value_;
    }

    return *this;
  }

  Uint16::
  ~Uint16 ()
  {
  }

  // Uint32
  //

  Uint32::
  Uint32 (const value_type& value)
  : ::xml_schema::type (),
    value_ (value, this)
  {
  }

  Uint32::
  Uint32 (const Uint32& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    value_ (x.value_, f, this)
  {
  }

  Uint32::
  Uint32 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    value_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Uint32::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  Uint32* Uint32::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Uint32 (*this, f, c);
  }

  Uint32& Uint32::
  operator= (const Uint32& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->value_ = x.value_;
    }

    return *this;
  }

  Uint32::
  ~Uint32 ()
  {
  }

  // Uint64
  //

  Uint64::
  Uint64 (const value_type& value)
  : ::xml_schema::type (),
    value_ (value, this)
  {
  }

  Uint64::
  Uint64 (const Uint64& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    value_ (x.value_, f, this)
  {
  }

  Uint64::
  Uint64 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    value_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Uint64::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  Uint64* Uint64::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Uint64 (*this, f, c);
  }

  Uint64& Uint64::
  operator= (const Uint64& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->value_ = x.value_;
    }

    return *this;
  }

  Uint64::
  ~Uint64 ()
  {
  }

  // Float32
  //

  Float32::
  Float32 (const value_type& value)
  : ::xml_schema::type (),
    value_ (value, this)
  {
  }

  Float32::
  Float32 (const Float32& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    value_ (x.value_, f, this)
  {
  }

  Float32::
  Float32 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    value_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Float32::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  Float32* Float32::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Float32 (*this, f, c);
  }

  Float32& Float32::
  operator= (const Float32& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->value_ = x.value_;
    }

    return *this;
  }

  Float32::
  ~Float32 ()
  {
  }

  // Float64
  //

  Float64::
  Float64 (const value_type& value)
  : ::xml_schema::type (),
    value_ (value, this)
  {
  }

  Float64::
  Float64 (const Float64& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    value_ (x.value_, f, this)
  {
  }

  Float64::
  Float64 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    value_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Float64::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  Float64* Float64::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Float64 (*this, f, c);
  }

  Float64& Float64::
  operator= (const Float64& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->value_ = x.value_;
    }

    return *this;
  }

  Float64::
  ~Float64 ()
  {
  }

  // String
  //

  String::
  String (const value_type& value)
  : ::xml_schema::type (),
    value_ (value, this)
  {
  }

  String::
  String (const String& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    value_ (x.value_, f, this)
  {
  }

  String::
  String (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    value_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void String::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  String* String::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class String (*this, f, c);
  }

  String& String::
  operator= (const String& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->value_ = x.value_;
    }

    return *this;
  }

  String::
  ~String ()
  {
  }

  // Binary
  //

  Binary::
  Binary (const value_type& value)
  : ::xml_schema::type (),
    value_ (value, this)
  {
  }

  Binary::
  Binary (const Binary& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    value_ (x.value_, f, this)
  {
  }

  Binary::
  Binary (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    value_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Binary::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  Binary* Binary::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Binary (*this, f, c);
  }

  Binary& Binary::
  operator= (const Binary& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->value_ = x.value_;
    }

    return *this;
  }

  Binary::
  ~Binary ()
  {
  }

  // Int81
  //

  Int81::
  Int81 ()
  : ::xml_schema::type (),
    min_ (this),
    max_ (this),
    value_ (this),
    dimensionSize_ (dimensionSize_default_value (), this)
  {
  }

  Int81::
  Int81 (const Int81& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    min_ (x.min_, f, this),
    max_ (x.max_, f, this),
    value_ (x.value_, f, this),
    dimensionSize_ (x.dimensionSize_, f, this)
  {
  }

  Int81::
  Int81 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    min_ (this),
    max_ (this),
    value_ (this),
    dimensionSize_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Int81::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "min" && n.namespace_ ().empty ())
      {
        this->min_.set (min_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "max" && n.namespace_ ().empty ())
      {
        this->max_.set (max_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dimensionSize" && n.namespace_ ().empty ())
      {
        this->dimensionSize_.set (dimensionSize_traits::create (i, f, this));
        continue;
      }
    }

    if (!dimensionSize_.present ())
    {
      this->dimensionSize_.set (dimensionSize_default_value ());
    }
  }

  Int81* Int81::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Int81 (*this, f, c);
  }

  Int81& Int81::
  operator= (const Int81& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->min_ = x.min_;
      this->max_ = x.max_;
      this->value_ = x.value_;
      this->dimensionSize_ = x.dimensionSize_;
    }

    return *this;
  }

  Int81::
  ~Int81 ()
  {
  }

  // Int161
  //

  Int161::
  Int161 ()
  : ::xml_schema::type (),
    min_ (this),
    max_ (this),
    value_ (this),
    dimensionSize_ (dimensionSize_default_value (), this)
  {
  }

  Int161::
  Int161 (const Int161& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    min_ (x.min_, f, this),
    max_ (x.max_, f, this),
    value_ (x.value_, f, this),
    dimensionSize_ (x.dimensionSize_, f, this)
  {
  }

  Int161::
  Int161 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    min_ (this),
    max_ (this),
    value_ (this),
    dimensionSize_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Int161::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "min" && n.namespace_ ().empty ())
      {
        this->min_.set (min_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "max" && n.namespace_ ().empty ())
      {
        this->max_.set (max_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dimensionSize" && n.namespace_ ().empty ())
      {
        this->dimensionSize_.set (dimensionSize_traits::create (i, f, this));
        continue;
      }
    }

    if (!dimensionSize_.present ())
    {
      this->dimensionSize_.set (dimensionSize_default_value ());
    }
  }

  Int161* Int161::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Int161 (*this, f, c);
  }

  Int161& Int161::
  operator= (const Int161& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->min_ = x.min_;
      this->max_ = x.max_;
      this->value_ = x.value_;
      this->dimensionSize_ = x.dimensionSize_;
    }

    return *this;
  }

  Int161::
  ~Int161 ()
  {
  }

  // Int321
  //

  Int321::
  Int321 ()
  : ::xml_schema::type (),
    min_ (this),
    max_ (this),
    value_ (this),
    dimensionSize_ (dimensionSize_default_value (), this)
  {
  }

  Int321::
  Int321 (const Int321& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    min_ (x.min_, f, this),
    max_ (x.max_, f, this),
    value_ (x.value_, f, this),
    dimensionSize_ (x.dimensionSize_, f, this)
  {
  }

  Int321::
  Int321 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    min_ (this),
    max_ (this),
    value_ (this),
    dimensionSize_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Int321::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "min" && n.namespace_ ().empty ())
      {
        this->min_.set (min_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "max" && n.namespace_ ().empty ())
      {
        this->max_.set (max_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dimensionSize" && n.namespace_ ().empty ())
      {
        this->dimensionSize_.set (dimensionSize_traits::create (i, f, this));
        continue;
      }
    }

    if (!dimensionSize_.present ())
    {
      this->dimensionSize_.set (dimensionSize_default_value ());
    }
  }

  Int321* Int321::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Int321 (*this, f, c);
  }

  Int321& Int321::
  operator= (const Int321& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->min_ = x.min_;
      this->max_ = x.max_;
      this->value_ = x.value_;
      this->dimensionSize_ = x.dimensionSize_;
    }

    return *this;
  }

  Int321::
  ~Int321 ()
  {
  }

  // Int641
  //

  Int641::
  Int641 ()
  : ::xml_schema::type (),
    min_ (this),
    max_ (this),
    value_ (this),
    dimensionSize_ (dimensionSize_default_value (), this)
  {
  }

  Int641::
  Int641 (const Int641& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    min_ (x.min_, f, this),
    max_ (x.max_, f, this),
    value_ (x.value_, f, this),
    dimensionSize_ (x.dimensionSize_, f, this)
  {
  }

  Int641::
  Int641 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    min_ (this),
    max_ (this),
    value_ (this),
    dimensionSize_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Int641::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "min" && n.namespace_ ().empty ())
      {
        this->min_.set (min_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "max" && n.namespace_ ().empty ())
      {
        this->max_.set (max_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dimensionSize" && n.namespace_ ().empty ())
      {
        this->dimensionSize_.set (dimensionSize_traits::create (i, f, this));
        continue;
      }
    }

    if (!dimensionSize_.present ())
    {
      this->dimensionSize_.set (dimensionSize_default_value ());
    }
  }

  Int641* Int641::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Int641 (*this, f, c);
  }

  Int641& Int641::
  operator= (const Int641& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->min_ = x.min_;
      this->max_ = x.max_;
      this->value_ = x.value_;
      this->dimensionSize_ = x.dimensionSize_;
    }

    return *this;
  }

  Int641::
  ~Int641 ()
  {
  }

  // Uint81
  //

  Uint81::
  Uint81 ()
  : ::xml_schema::type (),
    min_ (this),
    max_ (this),
    value_ (this),
    dimensionSize_ (dimensionSize_default_value (), this)
  {
  }

  Uint81::
  Uint81 (const Uint81& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    min_ (x.min_, f, this),
    max_ (x.max_, f, this),
    value_ (x.value_, f, this),
    dimensionSize_ (x.dimensionSize_, f, this)
  {
  }

  Uint81::
  Uint81 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    min_ (this),
    max_ (this),
    value_ (this),
    dimensionSize_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Uint81::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "min" && n.namespace_ ().empty ())
      {
        this->min_.set (min_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "max" && n.namespace_ ().empty ())
      {
        this->max_.set (max_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dimensionSize" && n.namespace_ ().empty ())
      {
        this->dimensionSize_.set (dimensionSize_traits::create (i, f, this));
        continue;
      }
    }

    if (!dimensionSize_.present ())
    {
      this->dimensionSize_.set (dimensionSize_default_value ());
    }
  }

  Uint81* Uint81::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Uint81 (*this, f, c);
  }

  Uint81& Uint81::
  operator= (const Uint81& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->min_ = x.min_;
      this->max_ = x.max_;
      this->value_ = x.value_;
      this->dimensionSize_ = x.dimensionSize_;
    }

    return *this;
  }

  Uint81::
  ~Uint81 ()
  {
  }

  // Uint161
  //

  Uint161::
  Uint161 ()
  : ::xml_schema::type (),
    min_ (this),
    max_ (this),
    value_ (this),
    dimensionSize_ (dimensionSize_default_value (), this)
  {
  }

  Uint161::
  Uint161 (const Uint161& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    min_ (x.min_, f, this),
    max_ (x.max_, f, this),
    value_ (x.value_, f, this),
    dimensionSize_ (x.dimensionSize_, f, this)
  {
  }

  Uint161::
  Uint161 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    min_ (this),
    max_ (this),
    value_ (this),
    dimensionSize_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Uint161::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "min" && n.namespace_ ().empty ())
      {
        this->min_.set (min_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "max" && n.namespace_ ().empty ())
      {
        this->max_.set (max_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dimensionSize" && n.namespace_ ().empty ())
      {
        this->dimensionSize_.set (dimensionSize_traits::create (i, f, this));
        continue;
      }
    }

    if (!dimensionSize_.present ())
    {
      this->dimensionSize_.set (dimensionSize_default_value ());
    }
  }

  Uint161* Uint161::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Uint161 (*this, f, c);
  }

  Uint161& Uint161::
  operator= (const Uint161& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->min_ = x.min_;
      this->max_ = x.max_;
      this->value_ = x.value_;
      this->dimensionSize_ = x.dimensionSize_;
    }

    return *this;
  }

  Uint161::
  ~Uint161 ()
  {
  }

  // Uint321
  //

  Uint321::
  Uint321 ()
  : ::xml_schema::type (),
    min_ (this),
    max_ (this),
    value_ (this),
    dimensionSize_ (dimensionSize_default_value (), this)
  {
  }

  Uint321::
  Uint321 (const Uint321& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    min_ (x.min_, f, this),
    max_ (x.max_, f, this),
    value_ (x.value_, f, this),
    dimensionSize_ (x.dimensionSize_, f, this)
  {
  }

  Uint321::
  Uint321 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    min_ (this),
    max_ (this),
    value_ (this),
    dimensionSize_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Uint321::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "min" && n.namespace_ ().empty ())
      {
        this->min_.set (min_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "max" && n.namespace_ ().empty ())
      {
        this->max_.set (max_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dimensionSize" && n.namespace_ ().empty ())
      {
        this->dimensionSize_.set (dimensionSize_traits::create (i, f, this));
        continue;
      }
    }

    if (!dimensionSize_.present ())
    {
      this->dimensionSize_.set (dimensionSize_default_value ());
    }
  }

  Uint321* Uint321::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Uint321 (*this, f, c);
  }

  Uint321& Uint321::
  operator= (const Uint321& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->min_ = x.min_;
      this->max_ = x.max_;
      this->value_ = x.value_;
      this->dimensionSize_ = x.dimensionSize_;
    }

    return *this;
  }

  Uint321::
  ~Uint321 ()
  {
  }

  // Uint641
  //

  Uint641::
  Uint641 ()
  : ::xml_schema::type (),
    min_ (this),
    max_ (this),
    value_ (this),
    dimensionSize_ (dimensionSize_default_value (), this)
  {
  }

  Uint641::
  Uint641 (const Uint641& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    min_ (x.min_, f, this),
    max_ (x.max_, f, this),
    value_ (x.value_, f, this),
    dimensionSize_ (x.dimensionSize_, f, this)
  {
  }

  Uint641::
  Uint641 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    min_ (this),
    max_ (this),
    value_ (this),
    dimensionSize_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Uint641::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "min" && n.namespace_ ().empty ())
      {
        this->min_.set (min_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "max" && n.namespace_ ().empty ())
      {
        this->max_.set (max_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dimensionSize" && n.namespace_ ().empty ())
      {
        this->dimensionSize_.set (dimensionSize_traits::create (i, f, this));
        continue;
      }
    }

    if (!dimensionSize_.present ())
    {
      this->dimensionSize_.set (dimensionSize_default_value ());
    }
  }

  Uint641* Uint641::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Uint641 (*this, f, c);
  }

  Uint641& Uint641::
  operator= (const Uint641& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->min_ = x.min_;
      this->max_ = x.max_;
      this->value_ = x.value_;
      this->dimensionSize_ = x.dimensionSize_;
    }

    return *this;
  }

  Uint641::
  ~Uint641 ()
  {
  }

  // Float321
  //

  Float321::
  Float321 ()
  : ::xml_schema::type (),
    min_ (this),
    max_ (this),
    value_ (this),
    dimensionSize_ (dimensionSize_default_value (), this)
  {
  }

  Float321::
  Float321 (const Float321& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    min_ (x.min_, f, this),
    max_ (x.max_, f, this),
    value_ (x.value_, f, this),
    dimensionSize_ (x.dimensionSize_, f, this)
  {
  }

  Float321::
  Float321 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    min_ (this),
    max_ (this),
    value_ (this),
    dimensionSize_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Float321::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "min" && n.namespace_ ().empty ())
      {
        this->min_.set (min_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "max" && n.namespace_ ().empty ())
      {
        this->max_.set (max_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dimensionSize" && n.namespace_ ().empty ())
      {
        this->dimensionSize_.set (dimensionSize_traits::create (i, f, this));
        continue;
      }
    }

    if (!dimensionSize_.present ())
    {
      this->dimensionSize_.set (dimensionSize_default_value ());
    }
  }

  Float321* Float321::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Float321 (*this, f, c);
  }

  Float321& Float321::
  operator= (const Float321& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->min_ = x.min_;
      this->max_ = x.max_;
      this->value_ = x.value_;
      this->dimensionSize_ = x.dimensionSize_;
    }

    return *this;
  }

  Float321::
  ~Float321 ()
  {
  }

  // Float641
  //

  Float641::
  Float641 ()
  : ::xml_schema::type (),
    min_ (this),
    max_ (this),
    value_ (this),
    dimensionSize_ (dimensionSize_default_value (), this)
  {
  }

  Float641::
  Float641 (const Float641& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    min_ (x.min_, f, this),
    max_ (x.max_, f, this),
    value_ (x.value_, f, this),
    dimensionSize_ (x.dimensionSize_, f, this)
  {
  }

  Float641::
  Float641 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    min_ (this),
    max_ (this),
    value_ (this),
    dimensionSize_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Float641::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "min" && n.namespace_ ().empty ())
      {
        this->min_.set (min_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "max" && n.namespace_ ().empty ())
      {
        this->max_.set (max_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dimensionSize" && n.namespace_ ().empty ())
      {
        this->dimensionSize_.set (dimensionSize_traits::create (i, f, this));
        continue;
      }
    }

    if (!dimensionSize_.present ())
    {
      this->dimensionSize_.set (dimensionSize_default_value ());
    }
  }

  Float641* Float641::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Float641 (*this, f, c);
  }

  Float641& Float641::
  operator= (const Float641& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->min_ = x.min_;
      this->max_ = x.max_;
      this->value_ = x.value_;
      this->dimensionSize_ = x.dimensionSize_;
    }

    return *this;
  }

  Float641::
  ~Float641 ()
  {
  }

  // String1
  //

  const String1::dimensionSize_type String1::dimensionSize_default_value_ (
    ::xml_schema::simple_type ("1"));

  String1::
  String1 ()
  : ::xml_schema::type (),
    value_ (this),
    dimensionSize_ (dimensionSize_default_value (), this)
  {
  }

  String1::
  String1 (const String1& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    value_ (x.value_, f, this),
    dimensionSize_ (x.dimensionSize_, f, this)
  {
  }

  String1::
  String1 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    value_ (this),
    dimensionSize_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void String1::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dimensionSize" && n.namespace_ ().empty ())
      {
        this->dimensionSize_.set (dimensionSize_traits::create (i, f, this));
        continue;
      }
    }

    if (!dimensionSize_.present ())
    {
      this->dimensionSize_.set (dimensionSize_default_value ());
    }
  }

  String1* String1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class String1 (*this, f, c);
  }

  String1& String1::
  operator= (const String1& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->value_ = x.value_;
      this->dimensionSize_ = x.dimensionSize_;
    }

    return *this;
  }

  String1::
  ~String1 ()
  {
  }

  // Binary1
  //

  const Binary1::dimensionSize_type Binary1::dimensionSize_default_value_ (
    ::xml_schema::simple_type ("1"));

  Binary1::
  Binary1 ()
  : ::xml_schema::type (),
    value_ (this),
    dimensionSize_ (dimensionSize_default_value (), this)
  {
  }

  Binary1::
  Binary1 (const Binary1& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    value_ (x.value_, f, this),
    dimensionSize_ (x.dimensionSize_, f, this)
  {
  }

  Binary1::
  Binary1 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    value_ (this),
    dimensionSize_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Binary1::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dimensionSize" && n.namespace_ ().empty ())
      {
        this->dimensionSize_.set (dimensionSize_traits::create (i, f, this));
        continue;
      }
    }

    if (!dimensionSize_.present ())
    {
      this->dimensionSize_.set (dimensionSize_default_value ());
    }
  }

  Binary1* Binary1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Binary1 (*this, f, c);
  }

  Binary1& Binary1::
  operator= (const Binary1& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->value_ = x.value_;
      this->dimensionSize_ = x.dimensionSize_;
    }

    return *this;
  }

  Binary1::
  ~Binary1 ()
  {
  }

  // UDP_IPv4
  //

  UDP_IPv4::
  UDP_IPv4 (const Control_type& Control)
  : ::xml_schema::type (),
    Control_ (Control, this),
    DAT_input_output_ (this),
    DAT_parameter_ (this)
  {
  }

  UDP_IPv4::
  UDP_IPv4 (::std::auto_ptr< Control_type > Control)
  : ::xml_schema::type (),
    Control_ (Control, this),
    DAT_input_output_ (this),
    DAT_parameter_ (this)
  {
  }

  UDP_IPv4::
  UDP_IPv4 (const UDP_IPv4& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Control_ (x.Control_, f, this),
    DAT_input_output_ (x.DAT_input_output_, f, this),
    DAT_parameter_ (x.DAT_parameter_, f, this)
  {
  }

  UDP_IPv4::
  UDP_IPv4 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Control_ (this),
    DAT_input_output_ (this),
    DAT_parameter_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void UDP_IPv4::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Control
      //
      if (n.name () == "Control" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Control_type > r (
          Control_traits::create (i, f, this));

        if (!Control_.present ())
        {
          this->Control_.set (r);
          continue;
        }
      }

      // DAT_input_output
      //
      if (n.name () == "DAT_input_output" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< DAT_input_output_type > r (
          DAT_input_output_traits::create (i, f, this));

        if (!this->DAT_input_output_)
        {
          this->DAT_input_output_.set (r);
          continue;
        }
      }

      // DAT_parameter
      //
      if (n.name () == "DAT_parameter" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< DAT_parameter_type > r (
          DAT_parameter_traits::create (i, f, this));

        if (!this->DAT_parameter_)
        {
          this->DAT_parameter_.set (r);
          continue;
        }
      }

      break;
    }

    if (!Control_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Control",
        "");
    }
  }

  UDP_IPv4* UDP_IPv4::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class UDP_IPv4 (*this, f, c);
  }

  UDP_IPv4& UDP_IPv4::
  operator= (const UDP_IPv4& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Control_ = x.Control_;
      this->DAT_input_output_ = x.DAT_input_output_;
      this->DAT_parameter_ = x.DAT_parameter_;
    }

    return *this;
  }

  UDP_IPv4::
  ~UDP_IPv4 ()
  {
  }

  // USB
  //

  USB::
  USB ()
  : ::xml_schema::type (),
    DataPipe_ (this)
  {
  }

  USB::
  USB (const USB& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    DataPipe_ (x.DataPipe_, f, this)
  {
  }

  USB::
  USB (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    DataPipe_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void USB::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DataPipe
      //
      if (n.name () == "DataPipe" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< DataPipe_type > r (
          DataPipe_traits::create (i, f, this));

        this->DataPipe_.push_back (r);
        continue;
      }

      break;
    }
  }

  USB* USB::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class USB (*this, f, c);
  }

  USB& USB::
  operator= (const USB& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->DataPipe_ = x.DataPipe_;
    }

    return *this;
  }

  USB::
  ~USB ()
  {
  }

  // Bluetooth
  //

  Bluetooth::
  Bluetooth (const Address_type& Address)
  : ::xml_schema::type (),
    Address_ (Address, this)
  {
  }

  Bluetooth::
  Bluetooth (::std::auto_ptr< Address_type > Address)
  : ::xml_schema::type (),
    Address_ (Address, this)
  {
  }

  Bluetooth::
  Bluetooth (const Bluetooth& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Address_ (x.Address_, f, this)
  {
  }

  Bluetooth::
  Bluetooth (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Address_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Bluetooth::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Address
      //
      if (n.name () == "Address" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Address_type > r (
          Address_traits::create (i, f, this));

        if (!Address_.present ())
        {
          this->Address_.set (r);
          continue;
        }
      }

      break;
    }

    if (!Address_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Address",
        "");
    }
  }

  Bluetooth* Bluetooth::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Bluetooth (*this, f, c);
  }

  Bluetooth& Bluetooth::
  operator= (const Bluetooth& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Address_ = x.Address_;
    }

    return *this;
  }

  Bluetooth::
  ~Bluetooth ()
  {
  }

  // TCP_IPv4
  //

  TCP_IPv4::
  TCP_IPv4 (const Control_type& Control)
  : ::xml_schema::type (),
    Control_ (Control, this),
    DAT_input_output_ (this),
    DAT_parameter_ (this)
  {
  }

  TCP_IPv4::
  TCP_IPv4 (::std::auto_ptr< Control_type > Control)
  : ::xml_schema::type (),
    Control_ (Control, this),
    DAT_input_output_ (this),
    DAT_parameter_ (this)
  {
  }

  TCP_IPv4::
  TCP_IPv4 (const TCP_IPv4& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Control_ (x.Control_, f, this),
    DAT_input_output_ (x.DAT_input_output_, f, this),
    DAT_parameter_ (x.DAT_parameter_, f, this)
  {
  }

  TCP_IPv4::
  TCP_IPv4 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Control_ (this),
    DAT_input_output_ (this),
    DAT_parameter_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void TCP_IPv4::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Control
      //
      if (n.name () == "Control" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Control_type > r (
          Control_traits::create (i, f, this));

        if (!Control_.present ())
        {
          this->Control_.set (r);
          continue;
        }
      }

      // DAT_input_output
      //
      if (n.name () == "DAT_input_output" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< DAT_input_output_type > r (
          DAT_input_output_traits::create (i, f, this));

        if (!this->DAT_input_output_)
        {
          this->DAT_input_output_.set (r);
          continue;
        }
      }

      // DAT_parameter
      //
      if (n.name () == "DAT_parameter" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< DAT_parameter_type > r (
          DAT_parameter_traits::create (i, f, this));

        if (!this->DAT_parameter_)
        {
          this->DAT_parameter_.set (r);
          continue;
        }
      }

      break;
    }

    if (!Control_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Control",
        "");
    }
  }

  TCP_IPv4* TCP_IPv4::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TCP_IPv4 (*this, f, c);
  }

  TCP_IPv4& TCP_IPv4::
  operator= (const TCP_IPv4& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Control_ = x.Control_;
      this->DAT_input_output_ = x.DAT_input_output_;
      this->DAT_parameter_ = x.DAT_parameter_;
    }

    return *this;
  }

  TCP_IPv4::
  ~TCP_IPv4 ()
  {
  }

  // Sending
  //

  Sending::
  Sending ()
  : ::xml_schema::type (),
    ClockTime_ (this),
    CFG_time_res_ (this),
    CFG_steps_ (this),
    CFG_input_ (this),
    CFG_output_ (this),
    CFG_source_network_information_ (this),
    CFG_source_network_information_UDP_IPv4_ (this),
    CFG_source_network_information_USB_ (this),
    CFG_source_network_information_Bluetooth_ (this),
    CFG_source_network_information_TCP_IPv4_ (this),
    CFG_target_network_information_ (this),
    CFG_target_network_information_UDP_IPv4_ (this),
    CFG_target_network_information_USB_ (this),
    CFG_target_network_information_Bluetooth_ (this),
    CFG_target_network_information_TCP_IPv4_ (this),
    CFG_clear_ (this),
    CFG_parameter_ (this),
    CFG_tunable_parameter_ (this),
    CFG_param_network_information_ (this),
    CFG_param_network_information_UDP_IPv4_ (this),
    CFG_param_network_information_USB_ (this),
    CFG_param_network_information_Bluetooth_ (this),
    CFG_param_network_information_TCP_IPv4_ (this),
    CFG_logging_ (this),
    CFG_scope_ (this),
    STC_register_ (this),
    STC_deregister_ (this),
    STC_prepare_ (this),
    STC_configure_ (this),
    STC_initialize_ (this),
    STC_run_ (this),
    STC_do_step_ (this),
    STC_send_outputs_ (this),
    STC_stop_ (this),
    STC_reset_ (this),
    INF_state_ (this),
    INF_error_ (this),
    INF_log_ (this),
    DAT_input_output_ (this),
    DAT_parameter_ (this)
  {
  }

  Sending::
  Sending (const Sending& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ClockTime_ (x.ClockTime_, f, this),
    CFG_time_res_ (x.CFG_time_res_, f, this),
    CFG_steps_ (x.CFG_steps_, f, this),
    CFG_input_ (x.CFG_input_, f, this),
    CFG_output_ (x.CFG_output_, f, this),
    CFG_source_network_information_ (x.CFG_source_network_information_, f, this),
    CFG_source_network_information_UDP_IPv4_ (x.CFG_source_network_information_UDP_IPv4_, f, this),
    CFG_source_network_information_USB_ (x.CFG_source_network_information_USB_, f, this),
    CFG_source_network_information_Bluetooth_ (x.CFG_source_network_information_Bluetooth_, f, this),
    CFG_source_network_information_TCP_IPv4_ (x.CFG_source_network_information_TCP_IPv4_, f, this),
    CFG_target_network_information_ (x.CFG_target_network_information_, f, this),
    CFG_target_network_information_UDP_IPv4_ (x.CFG_target_network_information_UDP_IPv4_, f, this),
    CFG_target_network_information_USB_ (x.CFG_target_network_information_USB_, f, this),
    CFG_target_network_information_Bluetooth_ (x.CFG_target_network_information_Bluetooth_, f, this),
    CFG_target_network_information_TCP_IPv4_ (x.CFG_target_network_information_TCP_IPv4_, f, this),
    CFG_clear_ (x.CFG_clear_, f, this),
    CFG_parameter_ (x.CFG_parameter_, f, this),
    CFG_tunable_parameter_ (x.CFG_tunable_parameter_, f, this),
    CFG_param_network_information_ (x.CFG_param_network_information_, f, this),
    CFG_param_network_information_UDP_IPv4_ (x.CFG_param_network_information_UDP_IPv4_, f, this),
    CFG_param_network_information_USB_ (x.CFG_param_network_information_USB_, f, this),
    CFG_param_network_information_Bluetooth_ (x.CFG_param_network_information_Bluetooth_, f, this),
    CFG_param_network_information_TCP_IPv4_ (x.CFG_param_network_information_TCP_IPv4_, f, this),
    CFG_logging_ (x.CFG_logging_, f, this),
    CFG_scope_ (x.CFG_scope_, f, this),
    STC_register_ (x.STC_register_, f, this),
    STC_deregister_ (x.STC_deregister_, f, this),
    STC_prepare_ (x.STC_prepare_, f, this),
    STC_configure_ (x.STC_configure_, f, this),
    STC_initialize_ (x.STC_initialize_, f, this),
    STC_run_ (x.STC_run_, f, this),
    STC_do_step_ (x.STC_do_step_, f, this),
    STC_send_outputs_ (x.STC_send_outputs_, f, this),
    STC_stop_ (x.STC_stop_, f, this),
    STC_reset_ (x.STC_reset_, f, this),
    INF_state_ (x.INF_state_, f, this),
    INF_error_ (x.INF_error_, f, this),
    INF_log_ (x.INF_log_, f, this),
    DAT_input_output_ (x.DAT_input_output_, f, this),
    DAT_parameter_ (x.DAT_parameter_, f, this)
  {
  }

  Sending::
  Sending (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ClockTime_ (this),
    CFG_time_res_ (this),
    CFG_steps_ (this),
    CFG_input_ (this),
    CFG_output_ (this),
    CFG_source_network_information_ (this),
    CFG_source_network_information_UDP_IPv4_ (this),
    CFG_source_network_information_USB_ (this),
    CFG_source_network_information_Bluetooth_ (this),
    CFG_source_network_information_TCP_IPv4_ (this),
    CFG_target_network_information_ (this),
    CFG_target_network_information_UDP_IPv4_ (this),
    CFG_target_network_information_USB_ (this),
    CFG_target_network_information_Bluetooth_ (this),
    CFG_target_network_information_TCP_IPv4_ (this),
    CFG_clear_ (this),
    CFG_parameter_ (this),
    CFG_tunable_parameter_ (this),
    CFG_param_network_information_ (this),
    CFG_param_network_information_UDP_IPv4_ (this),
    CFG_param_network_information_USB_ (this),
    CFG_param_network_information_Bluetooth_ (this),
    CFG_param_network_information_TCP_IPv4_ (this),
    CFG_logging_ (this),
    CFG_scope_ (this),
    STC_register_ (this),
    STC_deregister_ (this),
    STC_prepare_ (this),
    STC_configure_ (this),
    STC_initialize_ (this),
    STC_run_ (this),
    STC_do_step_ (this),
    STC_send_outputs_ (this),
    STC_stop_ (this),
    STC_reset_ (this),
    INF_state_ (this),
    INF_error_ (this),
    INF_log_ (this),
    DAT_input_output_ (this),
    DAT_parameter_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Sending::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ClockTime
      //
      if (n.name () == "ClockTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ClockTime_type > r (
          ClockTime_traits::create (i, f, this));

        if (!this->ClockTime_)
        {
          this->ClockTime_.set (r);
          continue;
        }
      }

      // CFG_time_res
      //
      if (n.name () == "CFG_time_res" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< CFG_time_res_type > r (
          CFG_time_res_traits::create (i, f, this));

        if (!this->CFG_time_res_)
        {
          this->CFG_time_res_.set (r);
          continue;
        }
      }

      // CFG_steps
      //
      if (n.name () == "CFG_steps" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< CFG_steps_type > r (
          CFG_steps_traits::create (i, f, this));

        if (!this->CFG_steps_)
        {
          this->CFG_steps_.set (r);
          continue;
        }
      }

      // CFG_input
      //
      if (n.name () == "CFG_input" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< CFG_input_type > r (
          CFG_input_traits::create (i, f, this));

        if (!this->CFG_input_)
        {
          this->CFG_input_.set (r);
          continue;
        }
      }

      // CFG_output
      //
      if (n.name () == "CFG_output" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< CFG_output_type > r (
          CFG_output_traits::create (i, f, this));

        if (!this->CFG_output_)
        {
          this->CFG_output_.set (r);
          continue;
        }
      }

      // CFG_source_network_information
      //
      if (n.name () == "CFG_source_network_information" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< CFG_source_network_information_type > r (
          CFG_source_network_information_traits::create (i, f, this));

        if (!this->CFG_source_network_information_)
        {
          this->CFG_source_network_information_.set (r);
          continue;
        }
      }

      // CFG_source_network_information_UDP_IPv4
      //
      if (n.name () == "CFG_source_network_information_UDP_IPv4" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< CFG_source_network_information_UDP_IPv4_type > r (
          CFG_source_network_information_UDP_IPv4_traits::create (i, f, this));

        if (!this->CFG_source_network_information_UDP_IPv4_)
        {
          this->CFG_source_network_information_UDP_IPv4_.set (r);
          continue;
        }
      }

      // CFG_source_network_information_USB
      //
      if (n.name () == "CFG_source_network_information_USB" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< CFG_source_network_information_USB_type > r (
          CFG_source_network_information_USB_traits::create (i, f, this));

        if (!this->CFG_source_network_information_USB_)
        {
          this->CFG_source_network_information_USB_.set (r);
          continue;
        }
      }

      // CFG_source_network_information_Bluetooth
      //
      if (n.name () == "CFG_source_network_information_Bluetooth" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< CFG_source_network_information_Bluetooth_type > r (
          CFG_source_network_information_Bluetooth_traits::create (i, f, this));

        if (!this->CFG_source_network_information_Bluetooth_)
        {
          this->CFG_source_network_information_Bluetooth_.set (r);
          continue;
        }
      }

      // CFG_source_network_information_TCP_IPv4
      //
      if (n.name () == "CFG_source_network_information_TCP_IPv4" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< CFG_source_network_information_TCP_IPv4_type > r (
          CFG_source_network_information_TCP_IPv4_traits::create (i, f, this));

        if (!this->CFG_source_network_information_TCP_IPv4_)
        {
          this->CFG_source_network_information_TCP_IPv4_.set (r);
          continue;
        }
      }

      // CFG_target_network_information
      //
      if (n.name () == "CFG_target_network_information" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< CFG_target_network_information_type > r (
          CFG_target_network_information_traits::create (i, f, this));

        if (!this->CFG_target_network_information_)
        {
          this->CFG_target_network_information_.set (r);
          continue;
        }
      }

      // CFG_target_network_information_UDP_IPv4
      //
      if (n.name () == "CFG_target_network_information_UDP_IPv4" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< CFG_target_network_information_UDP_IPv4_type > r (
          CFG_target_network_information_UDP_IPv4_traits::create (i, f, this));

        if (!this->CFG_target_network_information_UDP_IPv4_)
        {
          this->CFG_target_network_information_UDP_IPv4_.set (r);
          continue;
        }
      }

      // CFG_target_network_information_USB
      //
      if (n.name () == "CFG_target_network_information_USB" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< CFG_target_network_information_USB_type > r (
          CFG_target_network_information_USB_traits::create (i, f, this));

        if (!this->CFG_target_network_information_USB_)
        {
          this->CFG_target_network_information_USB_.set (r);
          continue;
        }
      }

      // CFG_target_network_information_Bluetooth
      //
      if (n.name () == "CFG_target_network_information_Bluetooth" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< CFG_target_network_information_Bluetooth_type > r (
          CFG_target_network_information_Bluetooth_traits::create (i, f, this));

        if (!this->CFG_target_network_information_Bluetooth_)
        {
          this->CFG_target_network_information_Bluetooth_.set (r);
          continue;
        }
      }

      // CFG_target_network_information_TCP_IPv4
      //
      if (n.name () == "CFG_target_network_information_TCP_IPv4" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< CFG_target_network_information_TCP_IPv4_type > r (
          CFG_target_network_information_TCP_IPv4_traits::create (i, f, this));

        if (!this->CFG_target_network_information_TCP_IPv4_)
        {
          this->CFG_target_network_information_TCP_IPv4_.set (r);
          continue;
        }
      }

      // CFG_clear
      //
      if (n.name () == "CFG_clear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< CFG_clear_type > r (
          CFG_clear_traits::create (i, f, this));

        if (!this->CFG_clear_)
        {
          this->CFG_clear_.set (r);
          continue;
        }
      }

      // CFG_parameter
      //
      if (n.name () == "CFG_parameter" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< CFG_parameter_type > r (
          CFG_parameter_traits::create (i, f, this));

        if (!this->CFG_parameter_)
        {
          this->CFG_parameter_.set (r);
          continue;
        }
      }

      // CFG_tunable_parameter
      //
      if (n.name () == "CFG_tunable_parameter" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< CFG_tunable_parameter_type > r (
          CFG_tunable_parameter_traits::create (i, f, this));

        if (!this->CFG_tunable_parameter_)
        {
          this->CFG_tunable_parameter_.set (r);
          continue;
        }
      }

      // CFG_param_network_information
      //
      if (n.name () == "CFG_param_network_information" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< CFG_param_network_information_type > r (
          CFG_param_network_information_traits::create (i, f, this));

        if (!this->CFG_param_network_information_)
        {
          this->CFG_param_network_information_.set (r);
          continue;
        }
      }

      // CFG_param_network_information_UDP_IPv4
      //
      if (n.name () == "CFG_param_network_information_UDP_IPv4" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< CFG_param_network_information_UDP_IPv4_type > r (
          CFG_param_network_information_UDP_IPv4_traits::create (i, f, this));

        if (!this->CFG_param_network_information_UDP_IPv4_)
        {
          this->CFG_param_network_information_UDP_IPv4_.set (r);
          continue;
        }
      }

      // CFG_param_network_information_USB
      //
      if (n.name () == "CFG_param_network_information_USB" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< CFG_param_network_information_USB_type > r (
          CFG_param_network_information_USB_traits::create (i, f, this));

        if (!this->CFG_param_network_information_USB_)
        {
          this->CFG_param_network_information_USB_.set (r);
          continue;
        }
      }

      // CFG_param_network_information_Bluetooth
      //
      if (n.name () == "CFG_param_network_information_Bluetooth" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< CFG_param_network_information_Bluetooth_type > r (
          CFG_param_network_information_Bluetooth_traits::create (i, f, this));

        if (!this->CFG_param_network_information_Bluetooth_)
        {
          this->CFG_param_network_information_Bluetooth_.set (r);
          continue;
        }
      }

      // CFG_param_network_information_TCP_IPv4
      //
      if (n.name () == "CFG_param_network_information_TCP_IPv4" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< CFG_param_network_information_TCP_IPv4_type > r (
          CFG_param_network_information_TCP_IPv4_traits::create (i, f, this));

        if (!this->CFG_param_network_information_TCP_IPv4_)
        {
          this->CFG_param_network_information_TCP_IPv4_.set (r);
          continue;
        }
      }

      // CFG_logging
      //
      if (n.name () == "CFG_logging" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< CFG_logging_type > r (
          CFG_logging_traits::create (i, f, this));

        if (!this->CFG_logging_)
        {
          this->CFG_logging_.set (r);
          continue;
        }
      }

      // CFG_scope
      //
      if (n.name () == "CFG_scope" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< CFG_scope_type > r (
          CFG_scope_traits::create (i, f, this));

        if (!this->CFG_scope_)
        {
          this->CFG_scope_.set (r);
          continue;
        }
      }

      // STC_register
      //
      if (n.name () == "STC_register" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< STC_register_type > r (
          STC_register_traits::create (i, f, this));

        if (!this->STC_register_)
        {
          this->STC_register_.set (r);
          continue;
        }
      }

      // STC_deregister
      //
      if (n.name () == "STC_deregister" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< STC_deregister_type > r (
          STC_deregister_traits::create (i, f, this));

        if (!this->STC_deregister_)
        {
          this->STC_deregister_.set (r);
          continue;
        }
      }

      // STC_prepare
      //
      if (n.name () == "STC_prepare" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< STC_prepare_type > r (
          STC_prepare_traits::create (i, f, this));

        if (!this->STC_prepare_)
        {
          this->STC_prepare_.set (r);
          continue;
        }
      }

      // STC_configure
      //
      if (n.name () == "STC_configure" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< STC_configure_type > r (
          STC_configure_traits::create (i, f, this));

        if (!this->STC_configure_)
        {
          this->STC_configure_.set (r);
          continue;
        }
      }

      // STC_initialize
      //
      if (n.name () == "STC_initialize" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< STC_initialize_type > r (
          STC_initialize_traits::create (i, f, this));

        if (!this->STC_initialize_)
        {
          this->STC_initialize_.set (r);
          continue;
        }
      }

      // STC_run
      //
      if (n.name () == "STC_run" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< STC_run_type > r (
          STC_run_traits::create (i, f, this));

        if (!this->STC_run_)
        {
          this->STC_run_.set (r);
          continue;
        }
      }

      // STC_do_step
      //
      if (n.name () == "STC_do_step" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< STC_do_step_type > r (
          STC_do_step_traits::create (i, f, this));

        if (!this->STC_do_step_)
        {
          this->STC_do_step_.set (r);
          continue;
        }
      }

      // STC_send_outputs
      //
      if (n.name () == "STC_send_outputs" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< STC_send_outputs_type > r (
          STC_send_outputs_traits::create (i, f, this));

        if (!this->STC_send_outputs_)
        {
          this->STC_send_outputs_.set (r);
          continue;
        }
      }

      // STC_stop
      //
      if (n.name () == "STC_stop" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< STC_stop_type > r (
          STC_stop_traits::create (i, f, this));

        if (!this->STC_stop_)
        {
          this->STC_stop_.set (r);
          continue;
        }
      }

      // STC_reset
      //
      if (n.name () == "STC_reset" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< STC_reset_type > r (
          STC_reset_traits::create (i, f, this));

        if (!this->STC_reset_)
        {
          this->STC_reset_.set (r);
          continue;
        }
      }

      // INF_state
      //
      if (n.name () == "INF_state" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< INF_state_type > r (
          INF_state_traits::create (i, f, this));

        if (!this->INF_state_)
        {
          this->INF_state_.set (r);
          continue;
        }
      }

      // INF_error
      //
      if (n.name () == "INF_error" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< INF_error_type > r (
          INF_error_traits::create (i, f, this));

        if (!this->INF_error_)
        {
          this->INF_error_.set (r);
          continue;
        }
      }

      // INF_log
      //
      if (n.name () == "INF_log" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< INF_log_type > r (
          INF_log_traits::create (i, f, this));

        if (!this->INF_log_)
        {
          this->INF_log_.set (r);
          continue;
        }
      }

      // DAT_input_output
      //
      if (n.name () == "DAT_input_output" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< DAT_input_output_type > r (
          DAT_input_output_traits::create (i, f, this));

        if (!this->DAT_input_output_)
        {
          this->DAT_input_output_.set (r);
          continue;
        }
      }

      // DAT_parameter
      //
      if (n.name () == "DAT_parameter" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< DAT_parameter_type > r (
          DAT_parameter_traits::create (i, f, this));

        if (!this->DAT_parameter_)
        {
          this->DAT_parameter_.set (r);
          continue;
        }
      }

      break;
    }
  }

  Sending* Sending::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Sending (*this, f, c);
  }

  Sending& Sending::
  operator= (const Sending& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->ClockTime_ = x.ClockTime_;
      this->CFG_time_res_ = x.CFG_time_res_;
      this->CFG_steps_ = x.CFG_steps_;
      this->CFG_input_ = x.CFG_input_;
      this->CFG_output_ = x.CFG_output_;
      this->CFG_source_network_information_ = x.CFG_source_network_information_;
      this->CFG_source_network_information_UDP_IPv4_ = x.CFG_source_network_information_UDP_IPv4_;
      this->CFG_source_network_information_USB_ = x.CFG_source_network_information_USB_;
      this->CFG_source_network_information_Bluetooth_ = x.CFG_source_network_information_Bluetooth_;
      this->CFG_source_network_information_TCP_IPv4_ = x.CFG_source_network_information_TCP_IPv4_;
      this->CFG_target_network_information_ = x.CFG_target_network_information_;
      this->CFG_target_network_information_UDP_IPv4_ = x.CFG_target_network_information_UDP_IPv4_;
      this->CFG_target_network_information_USB_ = x.CFG_target_network_information_USB_;
      this->CFG_target_network_information_Bluetooth_ = x.CFG_target_network_information_Bluetooth_;
      this->CFG_target_network_information_TCP_IPv4_ = x.CFG_target_network_information_TCP_IPv4_;
      this->CFG_clear_ = x.CFG_clear_;
      this->CFG_parameter_ = x.CFG_parameter_;
      this->CFG_tunable_parameter_ = x.CFG_tunable_parameter_;
      this->CFG_param_network_information_ = x.CFG_param_network_information_;
      this->CFG_param_network_information_UDP_IPv4_ = x.CFG_param_network_information_UDP_IPv4_;
      this->CFG_param_network_information_USB_ = x.CFG_param_network_information_USB_;
      this->CFG_param_network_information_Bluetooth_ = x.CFG_param_network_information_Bluetooth_;
      this->CFG_param_network_information_TCP_IPv4_ = x.CFG_param_network_information_TCP_IPv4_;
      this->CFG_logging_ = x.CFG_logging_;
      this->CFG_scope_ = x.CFG_scope_;
      this->STC_register_ = x.STC_register_;
      this->STC_deregister_ = x.STC_deregister_;
      this->STC_prepare_ = x.STC_prepare_;
      this->STC_configure_ = x.STC_configure_;
      this->STC_initialize_ = x.STC_initialize_;
      this->STC_run_ = x.STC_run_;
      this->STC_do_step_ = x.STC_do_step_;
      this->STC_send_outputs_ = x.STC_send_outputs_;
      this->STC_stop_ = x.STC_stop_;
      this->STC_reset_ = x.STC_reset_;
      this->INF_state_ = x.INF_state_;
      this->INF_error_ = x.INF_error_;
      this->INF_log_ = x.INF_log_;
      this->DAT_input_output_ = x.DAT_input_output_;
      this->DAT_parameter_ = x.DAT_parameter_;
    }

    return *this;
  }

  Sending::
  ~Sending ()
  {
  }

  // Receiving
  //

  Receiving::
  Receiving ()
  : ::xml_schema::type (),
    RSP_ack_ (this),
    RSP_error_ack_ (this),
    RSP_nack_ (this),
    RSP_state_ack_ (this),
    NTF_state_changed_ (this),
    RSP_log_ack_ (this),
    NTF_log_ (this),
    DAT_input_output_ (this),
    DAT_parameter_ (this)
  {
  }

  Receiving::
  Receiving (const Receiving& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    RSP_ack_ (x.RSP_ack_, f, this),
    RSP_error_ack_ (x.RSP_error_ack_, f, this),
    RSP_nack_ (x.RSP_nack_, f, this),
    RSP_state_ack_ (x.RSP_state_ack_, f, this),
    NTF_state_changed_ (x.NTF_state_changed_, f, this),
    RSP_log_ack_ (x.RSP_log_ack_, f, this),
    NTF_log_ (x.NTF_log_, f, this),
    DAT_input_output_ (x.DAT_input_output_, f, this),
    DAT_parameter_ (x.DAT_parameter_, f, this)
  {
  }

  Receiving::
  Receiving (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    RSP_ack_ (this),
    RSP_error_ack_ (this),
    RSP_nack_ (this),
    RSP_state_ack_ (this),
    NTF_state_changed_ (this),
    RSP_log_ack_ (this),
    NTF_log_ (this),
    DAT_input_output_ (this),
    DAT_parameter_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Receiving::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // RSP_ack
      //
      if (n.name () == "RSP_ack" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< RSP_ack_type > r (
          RSP_ack_traits::create (i, f, this));

        if (!this->RSP_ack_)
        {
          this->RSP_ack_.set (r);
          continue;
        }
      }

      // RSP_error_ack
      //
      if (n.name () == "RSP_error_ack" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< RSP_error_ack_type > r (
          RSP_error_ack_traits::create (i, f, this));

        if (!this->RSP_error_ack_)
        {
          this->RSP_error_ack_.set (r);
          continue;
        }
      }

      // RSP_nack
      //
      if (n.name () == "RSP_nack" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< RSP_nack_type > r (
          RSP_nack_traits::create (i, f, this));

        if (!this->RSP_nack_)
        {
          this->RSP_nack_.set (r);
          continue;
        }
      }

      // RSP_state_ack
      //
      if (n.name () == "RSP_state_ack" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< RSP_state_ack_type > r (
          RSP_state_ack_traits::create (i, f, this));

        if (!this->RSP_state_ack_)
        {
          this->RSP_state_ack_.set (r);
          continue;
        }
      }

      // NTF_state_changed
      //
      if (n.name () == "NTF_state_changed" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NTF_state_changed_type > r (
          NTF_state_changed_traits::create (i, f, this));

        if (!this->NTF_state_changed_)
        {
          this->NTF_state_changed_.set (r);
          continue;
        }
      }

      // RSP_log_ack
      //
      if (n.name () == "RSP_log_ack" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< RSP_log_ack_type > r (
          RSP_log_ack_traits::create (i, f, this));

        if (!this->RSP_log_ack_)
        {
          this->RSP_log_ack_.set (r);
          continue;
        }
      }

      // NTF_log
      //
      if (n.name () == "NTF_log" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NTF_log_type > r (
          NTF_log_traits::create (i, f, this));

        if (!this->NTF_log_)
        {
          this->NTF_log_.set (r);
          continue;
        }
      }

      // DAT_input_output
      //
      if (n.name () == "DAT_input_output" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< DAT_input_output_type > r (
          DAT_input_output_traits::create (i, f, this));

        if (!this->DAT_input_output_)
        {
          this->DAT_input_output_.set (r);
          continue;
        }
      }

      // DAT_parameter
      //
      if (n.name () == "DAT_parameter" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< DAT_parameter_type > r (
          DAT_parameter_traits::create (i, f, this));

        if (!this->DAT_parameter_)
        {
          this->DAT_parameter_.set (r);
          continue;
        }
      }

      break;
    }
  }

  Receiving* Receiving::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Receiving (*this, f, c);
  }

  Receiving& Receiving::
  operator= (const Receiving& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->RSP_ack_ = x.RSP_ack_;
      this->RSP_error_ack_ = x.RSP_error_ack_;
      this->RSP_nack_ = x.RSP_nack_;
      this->RSP_state_ack_ = x.RSP_state_ack_;
      this->NTF_state_changed_ = x.NTF_state_changed_;
      this->RSP_log_ack_ = x.RSP_log_ack_;
      this->NTF_log_ = x.NTF_log_;
      this->DAT_input_output_ = x.DAT_input_output_;
      this->DAT_parameter_ = x.DAT_parameter_;
    }

    return *this;
  }

  Receiving::
  ~Receiving ()
  {
  }

  // value
  //

  value::
  value (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::byte, char > (e, f, this)
  {
  }

  value::
  value (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::byte, char > (a, f, this)
  {
  }

  value::
  value (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::byte, char > (s, e, f, this)
  {
  }

  value* value::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class value (*this, f, c);
  }

  value::
  ~value ()
  {
  }

  // value1
  //

  value1::
  value1 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::short_, char > (e, f, this)
  {
  }

  value1::
  value1 (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::short_, char > (a, f, this)
  {
  }

  value1::
  value1 (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::short_, char > (s, e, f, this)
  {
  }

  value1* value1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class value1 (*this, f, c);
  }

  value1::
  ~value1 ()
  {
  }

  // value2
  //

  value2::
  value2 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::int_, char > (e, f, this)
  {
  }

  value2::
  value2 (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::int_, char > (a, f, this)
  {
  }

  value2::
  value2 (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::int_, char > (s, e, f, this)
  {
  }

  value2* value2::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class value2 (*this, f, c);
  }

  value2::
  ~value2 ()
  {
  }

  // value3
  //

  value3::
  value3 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::long_, char > (e, f, this)
  {
  }

  value3::
  value3 (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::long_, char > (a, f, this)
  {
  }

  value3::
  value3 (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::long_, char > (s, e, f, this)
  {
  }

  value3* value3::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class value3 (*this, f, c);
  }

  value3::
  ~value3 ()
  {
  }

  // value4
  //

  value4::
  value4 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_byte, char > (e, f, this)
  {
  }

  value4::
  value4 (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_byte, char > (a, f, this)
  {
  }

  value4::
  value4 (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_byte, char > (s, e, f, this)
  {
  }

  value4* value4::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class value4 (*this, f, c);
  }

  value4::
  ~value4 ()
  {
  }

  // value5
  //

  value5::
  value5 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_short, char > (e, f, this)
  {
  }

  value5::
  value5 (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_short, char > (a, f, this)
  {
  }

  value5::
  value5 (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_short, char > (s, e, f, this)
  {
  }

  value5* value5::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class value5 (*this, f, c);
  }

  value5::
  ~value5 ()
  {
  }

  // value6
  //

  value6::
  value6 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char > (e, f, this)
  {
  }

  value6::
  value6 (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char > (a, f, this)
  {
  }

  value6::
  value6 (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char > (s, e, f, this)
  {
  }

  value6* value6::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class value6 (*this, f, c);
  }

  value6::
  ~value6 ()
  {
  }

  // value7
  //

  value7::
  value7 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_long, char > (e, f, this)
  {
  }

  value7::
  value7 (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_long, char > (a, f, this)
  {
  }

  value7::
  value7 (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_long, char > (s, e, f, this)
  {
  }

  value7* value7::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class value7 (*this, f, c);
  }

  value7::
  ~value7 ()
  {
  }

  // value8
  //

  value8::
  value8 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::float_, char > (e, f, this)
  {
  }

  value8::
  value8 (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::float_, char > (a, f, this)
  {
  }

  value8::
  value8 (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::float_, char > (s, e, f, this)
  {
  }

  value8* value8::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class value8 (*this, f, c);
  }

  value8::
  ~value8 ()
  {
  }

  // value9
  //

  value9::
  value9 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (e, f, this)
  {
  }

  value9::
  value9 (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (a, f, this)
  {
  }

  value9::
  value9 (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, this)
  {
  }

  value9* value9::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class value9 (*this, f, c);
  }

  value9::
  ~value9 ()
  {
  }

  // value10
  //

  value10::
  value10 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::byte, char > (e, f, this)
  {
  }

  value10::
  value10 (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::byte, char > (a, f, this)
  {
  }

  value10::
  value10 (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::byte, char > (s, e, f, this)
  {
  }

  value10* value10::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class value10 (*this, f, c);
  }

  value10::
  ~value10 ()
  {
  }

  // value11
  //

  value11::
  value11 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::short_, char > (e, f, this)
  {
  }

  value11::
  value11 (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::short_, char > (a, f, this)
  {
  }

  value11::
  value11 (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::short_, char > (s, e, f, this)
  {
  }

  value11* value11::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class value11 (*this, f, c);
  }

  value11::
  ~value11 ()
  {
  }

  // value12
  //

  value12::
  value12 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::int_, char > (e, f, this)
  {
  }

  value12::
  value12 (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::int_, char > (a, f, this)
  {
  }

  value12::
  value12 (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::int_, char > (s, e, f, this)
  {
  }

  value12* value12::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class value12 (*this, f, c);
  }

  value12::
  ~value12 ()
  {
  }

  // value13
  //

  value13::
  value13 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::long_, char > (e, f, this)
  {
  }

  value13::
  value13 (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::long_, char > (a, f, this)
  {
  }

  value13::
  value13 (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::long_, char > (s, e, f, this)
  {
  }

  value13* value13::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class value13 (*this, f, c);
  }

  value13::
  ~value13 ()
  {
  }

  // value14
  //

  value14::
  value14 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_byte, char > (e, f, this)
  {
  }

  value14::
  value14 (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_byte, char > (a, f, this)
  {
  }

  value14::
  value14 (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_byte, char > (s, e, f, this)
  {
  }

  value14* value14::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class value14 (*this, f, c);
  }

  value14::
  ~value14 ()
  {
  }

  // value15
  //

  value15::
  value15 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_short, char > (e, f, this)
  {
  }

  value15::
  value15 (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_short, char > (a, f, this)
  {
  }

  value15::
  value15 (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_short, char > (s, e, f, this)
  {
  }

  value15* value15::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class value15 (*this, f, c);
  }

  value15::
  ~value15 ()
  {
  }

  // value16
  //

  value16::
  value16 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char > (e, f, this)
  {
  }

  value16::
  value16 (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char > (a, f, this)
  {
  }

  value16::
  value16 (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char > (s, e, f, this)
  {
  }

  value16* value16::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class value16 (*this, f, c);
  }

  value16::
  ~value16 ()
  {
  }

  // value17
  //

  value17::
  value17 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_long, char > (e, f, this)
  {
  }

  value17::
  value17 (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_long, char > (a, f, this)
  {
  }

  value17::
  value17 (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_long, char > (s, e, f, this)
  {
  }

  value17* value17::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class value17 (*this, f, c);
  }

  value17::
  ~value17 ()
  {
  }

  // value18
  //

  value18::
  value18 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::float_, char > (e, f, this)
  {
  }

  value18::
  value18 (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::float_, char > (a, f, this)
  {
  }

  value18::
  value18 (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::float_, char > (s, e, f, this)
  {
  }

  value18* value18::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class value18 (*this, f, c);
  }

  value18::
  ~value18 ()
  {
  }

  // value19
  //

  value19::
  value19 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (e, f, this)
  {
  }

  value19::
  value19 (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (a, f, this)
  {
  }

  value19::
  value19 (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, this)
  {
  }

  value19* value19::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class value19 (*this, f, c);
  }

  value19::
  ~value19 ()
  {
  }

  // Control
  //

  Control::
  Control (const port_type& port)
  : ::xml_schema::type (),
    host_ (this),
    port_ (port, this)
  {
  }

  Control::
  Control (const Control& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    host_ (x.host_, f, this),
    port_ (x.port_, f, this)
  {
  }

  Control::
  Control (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    host_ (this),
    port_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Control::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "host" && n.namespace_ ().empty ())
      {
        this->host_.set (host_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "port" && n.namespace_ ().empty ())
      {
        this->port_.set (port_traits::create (i, f, this));
        continue;
      }
    }

    if (!port_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "port",
        "");
    }
  }

  Control* Control::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Control (*this, f, c);
  }

  Control& Control::
  operator= (const Control& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->host_ = x.host_;
      this->port_ = x.port_;
    }

    return *this;
  }

  Control::
  ~Control ()
  {
  }

  // DAT_input_output
  //

  DAT_input_output::
  DAT_input_output ()
  : ::xml_schema::type (),
    AvailablePortRange_ (this),
    AvailablePort_ (this),
    host_ (this)
  {
  }

  DAT_input_output::
  DAT_input_output (const DAT_input_output& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    AvailablePortRange_ (x.AvailablePortRange_, f, this),
    AvailablePort_ (x.AvailablePort_, f, this),
    host_ (x.host_, f, this)
  {
  }

  DAT_input_output::
  DAT_input_output (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    AvailablePortRange_ (this),
    AvailablePort_ (this),
    host_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void DAT_input_output::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AvailablePortRange
      //
      if (n.name () == "AvailablePortRange" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< AvailablePortRange_type > r (
          AvailablePortRange_traits::create (i, f, this));

        if (!this->AvailablePortRange_)
        {
          this->AvailablePortRange_.set (r);
          continue;
        }
      }

      // AvailablePort
      //
      if (n.name () == "AvailablePort" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< AvailablePort_type > r (
          AvailablePort_traits::create (i, f, this));

        if (!this->AvailablePort_)
        {
          this->AvailablePort_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "host" && n.namespace_ ().empty ())
      {
        this->host_.set (host_traits::create (i, f, this));
        continue;
      }
    }
  }

  DAT_input_output* DAT_input_output::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DAT_input_output (*this, f, c);
  }

  DAT_input_output& DAT_input_output::
  operator= (const DAT_input_output& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->AvailablePortRange_ = x.AvailablePortRange_;
      this->AvailablePort_ = x.AvailablePort_;
      this->host_ = x.host_;
    }

    return *this;
  }

  DAT_input_output::
  ~DAT_input_output ()
  {
  }

  // DAT_parameter
  //

  DAT_parameter::
  DAT_parameter ()
  : ::xml_schema::type (),
    AvailablePortRange_ (this),
    AvailablePort_ (this),
    host_ (this)
  {
  }

  DAT_parameter::
  DAT_parameter (const DAT_parameter& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    AvailablePortRange_ (x.AvailablePortRange_, f, this),
    AvailablePort_ (x.AvailablePort_, f, this),
    host_ (x.host_, f, this)
  {
  }

  DAT_parameter::
  DAT_parameter (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    AvailablePortRange_ (this),
    AvailablePort_ (this),
    host_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void DAT_parameter::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AvailablePortRange
      //
      if (n.name () == "AvailablePortRange" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< AvailablePortRange_type > r (
          AvailablePortRange_traits::create (i, f, this));

        if (!this->AvailablePortRange_)
        {
          this->AvailablePortRange_.set (r);
          continue;
        }
      }

      // AvailablePort
      //
      if (n.name () == "AvailablePort" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< AvailablePort_type > r (
          AvailablePort_traits::create (i, f, this));

        if (!this->AvailablePort_)
        {
          this->AvailablePort_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "host" && n.namespace_ ().empty ())
      {
        this->host_.set (host_traits::create (i, f, this));
        continue;
      }
    }
  }

  DAT_parameter* DAT_parameter::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DAT_parameter (*this, f, c);
  }

  DAT_parameter& DAT_parameter::
  operator= (const DAT_parameter& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->AvailablePortRange_ = x.AvailablePortRange_;
      this->AvailablePort_ = x.AvailablePort_;
      this->host_ = x.host_;
    }

    return *this;
  }

  DAT_parameter::
  ~DAT_parameter ()
  {
  }

  // DataPipe
  //

  DataPipe::
  DataPipe (const endpointAddress_type& endpointAddress,
            const intervall_type& intervall)
  : ::xml_schema::type (),
    direction_ (this),
    endpointAddress_ (endpointAddress, this),
    intervall_ (intervall, this)
  {
  }

  DataPipe::
  DataPipe (const DataPipe& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    direction_ (x.direction_, f, this),
    endpointAddress_ (x.endpointAddress_, f, this),
    intervall_ (x.intervall_, f, this)
  {
  }

  DataPipe::
  DataPipe (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    direction_ (this),
    endpointAddress_ (this),
    intervall_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void DataPipe::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "direction" && n.namespace_ ().empty ())
      {
        this->direction_.set (direction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "endpointAddress" && n.namespace_ ().empty ())
      {
        this->endpointAddress_.set (endpointAddress_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "intervall" && n.namespace_ ().empty ())
      {
        this->intervall_.set (intervall_traits::create (i, f, this));
        continue;
      }
    }

    if (!endpointAddress_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "endpointAddress",
        "");
    }

    if (!intervall_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "intervall",
        "");
    }
  }

  DataPipe* DataPipe::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DataPipe (*this, f, c);
  }

  DataPipe& DataPipe::
  operator= (const DataPipe& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->direction_ = x.direction_;
      this->endpointAddress_ = x.endpointAddress_;
      this->intervall_ = x.intervall_;
    }

    return *this;
  }

  DataPipe::
  ~DataPipe ()
  {
  }

  // Address
  //

  Address::
  Address (const bd_addr_type& bd_addr,
           const port_type& port)
  : ::xml_schema::type (),
    bd_addr_ (bd_addr, this),
    port_ (port, this),
    alias_ (this)
  {
  }

  Address::
  Address (const Address& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    bd_addr_ (x.bd_addr_, f, this),
    port_ (x.port_, f, this),
    alias_ (x.alias_, f, this)
  {
  }

  Address::
  Address (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    bd_addr_ (this),
    port_ (this),
    alias_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Address::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "bd_addr" && n.namespace_ ().empty ())
      {
        this->bd_addr_.set (bd_addr_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "port" && n.namespace_ ().empty ())
      {
        this->port_.set (port_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "alias" && n.namespace_ ().empty ())
      {
        this->alias_.set (alias_traits::create (i, f, this));
        continue;
      }
    }

    if (!bd_addr_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "bd_addr",
        "");
    }

    if (!port_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "port",
        "");
    }
  }

  Address* Address::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Address (*this, f, c);
  }

  Address& Address::
  operator= (const Address& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->bd_addr_ = x.bd_addr_;
      this->port_ = x.port_;
      this->alias_ = x.alias_;
    }

    return *this;
  }

  Address::
  ~Address ()
  {
  }

  // DAT_input_output1
  //

  DAT_input_output1::
  DAT_input_output1 ()
  : ::xml_schema::type (),
    AvailablePortRange_ (this),
    AvailablePort_ (this),
    host_ (this)
  {
  }

  DAT_input_output1::
  DAT_input_output1 (const DAT_input_output1& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    AvailablePortRange_ (x.AvailablePortRange_, f, this),
    AvailablePort_ (x.AvailablePort_, f, this),
    host_ (x.host_, f, this)
  {
  }

  DAT_input_output1::
  DAT_input_output1 (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    AvailablePortRange_ (this),
    AvailablePort_ (this),
    host_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void DAT_input_output1::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AvailablePortRange
      //
      if (n.name () == "AvailablePortRange" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< AvailablePortRange_type > r (
          AvailablePortRange_traits::create (i, f, this));

        if (!this->AvailablePortRange_)
        {
          this->AvailablePortRange_.set (r);
          continue;
        }
      }

      // AvailablePort
      //
      if (n.name () == "AvailablePort" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< AvailablePort_type > r (
          AvailablePort_traits::create (i, f, this));

        if (!this->AvailablePort_)
        {
          this->AvailablePort_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "host" && n.namespace_ ().empty ())
      {
        this->host_.set (host_traits::create (i, f, this));
        continue;
      }
    }
  }

  DAT_input_output1* DAT_input_output1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DAT_input_output1 (*this, f, c);
  }

  DAT_input_output1& DAT_input_output1::
  operator= (const DAT_input_output1& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->AvailablePortRange_ = x.AvailablePortRange_;
      this->AvailablePort_ = x.AvailablePort_;
      this->host_ = x.host_;
    }

    return *this;
  }

  DAT_input_output1::
  ~DAT_input_output1 ()
  {
  }

  // DAT_parameter1
  //

  DAT_parameter1::
  DAT_parameter1 ()
  : ::xml_schema::type (),
    AvailablePortRange_ (this),
    AvailablePort_ (this),
    host_ (this)
  {
  }

  DAT_parameter1::
  DAT_parameter1 (const DAT_parameter1& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    AvailablePortRange_ (x.AvailablePortRange_, f, this),
    AvailablePort_ (x.AvailablePort_, f, this),
    host_ (x.host_, f, this)
  {
  }

  DAT_parameter1::
  DAT_parameter1 (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    AvailablePortRange_ (this),
    AvailablePort_ (this),
    host_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void DAT_parameter1::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AvailablePortRange
      //
      if (n.name () == "AvailablePortRange" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< AvailablePortRange_type > r (
          AvailablePortRange_traits::create (i, f, this));

        if (!this->AvailablePortRange_)
        {
          this->AvailablePortRange_.set (r);
          continue;
        }
      }

      // AvailablePort
      //
      if (n.name () == "AvailablePort" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< AvailablePort_type > r (
          AvailablePort_traits::create (i, f, this));

        if (!this->AvailablePort_)
        {
          this->AvailablePort_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "host" && n.namespace_ ().empty ())
      {
        this->host_.set (host_traits::create (i, f, this));
        continue;
      }
    }
  }

  DAT_parameter1* DAT_parameter1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DAT_parameter1 (*this, f, c);
  }

  DAT_parameter1& DAT_parameter1::
  operator= (const DAT_parameter1& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->AvailablePortRange_ = x.AvailablePortRange_;
      this->AvailablePort_ = x.AvailablePort_;
      this->host_ = x.host_;
    }

    return *this;
  }

  DAT_parameter1::
  ~DAT_parameter1 ()
  {
  }

  // ClockTime
  //

  ClockTime::
  ClockTime (const numerator_type& numerator,
             const denominator_type& denominator)
  : ::xml_schema::type (),
    numerator_ (numerator, this),
    denominator_ (denominator, this)
  {
  }

  ClockTime::
  ClockTime (const ClockTime& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    numerator_ (x.numerator_, f, this),
    denominator_ (x.denominator_, f, this)
  {
  }

  ClockTime::
  ClockTime (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    numerator_ (this),
    denominator_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ClockTime::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "numerator" && n.namespace_ ().empty ())
      {
        this->numerator_.set (numerator_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "denominator" && n.namespace_ ().empty ())
      {
        this->denominator_.set (denominator_traits::create (i, f, this));
        continue;
      }
    }

    if (!numerator_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "numerator",
        "");
    }

    if (!denominator_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "denominator",
        "");
    }
  }

  ClockTime* ClockTime::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ClockTime (*this, f, c);
  }

  ClockTime& ClockTime::
  operator= (const ClockTime& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->numerator_ = x.numerator_;
      this->denominator_ = x.denominator_;
    }

    return *this;
  }

  ClockTime::
  ~ClockTime ()
  {
  }

  // CFG_time_res
  //

  CFG_time_res::
  CFG_time_res (const receiver_type& receiver,
                const numerator_type& numerator,
                const denominator_type& denominator)
  : ::xml_schema::type (),
    receiver_ (receiver, this),
    numerator_ (numerator, this),
    denominator_ (denominator, this)
  {
  }

  CFG_time_res::
  CFG_time_res (const CFG_time_res& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    receiver_ (x.receiver_, f, this),
    numerator_ (x.numerator_, f, this),
    denominator_ (x.denominator_, f, this)
  {
  }

  CFG_time_res::
  CFG_time_res (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    receiver_ (this),
    numerator_ (this),
    denominator_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void CFG_time_res::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "receiver" && n.namespace_ ().empty ())
      {
        this->receiver_.set (receiver_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "numerator" && n.namespace_ ().empty ())
      {
        this->numerator_.set (numerator_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "denominator" && n.namespace_ ().empty ())
      {
        this->denominator_.set (denominator_traits::create (i, f, this));
        continue;
      }
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "receiver",
        "");
    }

    if (!numerator_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "numerator",
        "");
    }

    if (!denominator_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "denominator",
        "");
    }
  }

  CFG_time_res* CFG_time_res::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CFG_time_res (*this, f, c);
  }

  CFG_time_res& CFG_time_res::
  operator= (const CFG_time_res& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->receiver_ = x.receiver_;
      this->numerator_ = x.numerator_;
      this->denominator_ = x.denominator_;
    }

    return *this;
  }

  CFG_time_res::
  ~CFG_time_res ()
  {
  }

  // CFG_steps
  //

  CFG_steps::
  CFG_steps (const receiver_type& receiver,
             const data_id_type& data_id,
             const steps_type& steps)
  : ::xml_schema::type (),
    receiver_ (receiver, this),
    data_id_ (data_id, this),
    steps_ (steps, this)
  {
  }

  CFG_steps::
  CFG_steps (const CFG_steps& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    receiver_ (x.receiver_, f, this),
    data_id_ (x.data_id_, f, this),
    steps_ (x.steps_, f, this)
  {
  }

  CFG_steps::
  CFG_steps (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    receiver_ (this),
    data_id_ (this),
    steps_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void CFG_steps::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "receiver" && n.namespace_ ().empty ())
      {
        this->receiver_.set (receiver_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "data_id" && n.namespace_ ().empty ())
      {
        this->data_id_.set (data_id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "steps" && n.namespace_ ().empty ())
      {
        this->steps_.set (steps_traits::create (i, f, this));
        continue;
      }
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "receiver",
        "");
    }

    if (!data_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "data_id",
        "");
    }

    if (!steps_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "steps",
        "");
    }
  }

  CFG_steps* CFG_steps::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CFG_steps (*this, f, c);
  }

  CFG_steps& CFG_steps::
  operator= (const CFG_steps& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->receiver_ = x.receiver_;
      this->data_id_ = x.data_id_;
      this->steps_ = x.steps_;
    }

    return *this;
  }

  CFG_steps::
  ~CFG_steps ()
  {
  }

  // CFG_input
  //

  CFG_input::
  CFG_input (const receiver_type& receiver,
             const data_id_type& data_id,
             const pos_type& pos,
             const target_vr_type& target_vr,
             const source_data_type_type& source_data_type)
  : ::xml_schema::type (),
    receiver_ (receiver, this),
    data_id_ (data_id, this),
    pos_ (pos, this),
    target_vr_ (target_vr, this),
    source_data_type_ (source_data_type, this)
  {
  }

  CFG_input::
  CFG_input (const CFG_input& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    receiver_ (x.receiver_, f, this),
    data_id_ (x.data_id_, f, this),
    pos_ (x.pos_, f, this),
    target_vr_ (x.target_vr_, f, this),
    source_data_type_ (x.source_data_type_, f, this)
  {
  }

  CFG_input::
  CFG_input (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    receiver_ (this),
    data_id_ (this),
    pos_ (this),
    target_vr_ (this),
    source_data_type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void CFG_input::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "receiver" && n.namespace_ ().empty ())
      {
        this->receiver_.set (receiver_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "data_id" && n.namespace_ ().empty ())
      {
        this->data_id_.set (data_id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "pos" && n.namespace_ ().empty ())
      {
        this->pos_.set (pos_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "target_vr" && n.namespace_ ().empty ())
      {
        this->target_vr_.set (target_vr_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "source_data_type" && n.namespace_ ().empty ())
      {
        this->source_data_type_.set (source_data_type_traits::create (i, f, this));
        continue;
      }
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "receiver",
        "");
    }

    if (!data_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "data_id",
        "");
    }

    if (!pos_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "pos",
        "");
    }

    if (!target_vr_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "target_vr",
        "");
    }

    if (!source_data_type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "source_data_type",
        "");
    }
  }

  CFG_input* CFG_input::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CFG_input (*this, f, c);
  }

  CFG_input& CFG_input::
  operator= (const CFG_input& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->receiver_ = x.receiver_;
      this->data_id_ = x.data_id_;
      this->pos_ = x.pos_;
      this->target_vr_ = x.target_vr_;
      this->source_data_type_ = x.source_data_type_;
    }

    return *this;
  }

  CFG_input::
  ~CFG_input ()
  {
  }

  // CFG_output
  //

  CFG_output::
  CFG_output (const receiver_type& receiver,
              const data_id_type& data_id,
              const pos_type& pos,
              const source_vr_type& source_vr)
  : ::xml_schema::type (),
    receiver_ (receiver, this),
    data_id_ (data_id, this),
    pos_ (pos, this),
    source_vr_ (source_vr, this)
  {
  }

  CFG_output::
  CFG_output (const CFG_output& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    receiver_ (x.receiver_, f, this),
    data_id_ (x.data_id_, f, this),
    pos_ (x.pos_, f, this),
    source_vr_ (x.source_vr_, f, this)
  {
  }

  CFG_output::
  CFG_output (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    receiver_ (this),
    data_id_ (this),
    pos_ (this),
    source_vr_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void CFG_output::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "receiver" && n.namespace_ ().empty ())
      {
        this->receiver_.set (receiver_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "data_id" && n.namespace_ ().empty ())
      {
        this->data_id_.set (data_id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "pos" && n.namespace_ ().empty ())
      {
        this->pos_.set (pos_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "source_vr" && n.namespace_ ().empty ())
      {
        this->source_vr_.set (source_vr_traits::create (i, f, this));
        continue;
      }
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "receiver",
        "");
    }

    if (!data_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "data_id",
        "");
    }

    if (!pos_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "pos",
        "");
    }

    if (!source_vr_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "source_vr",
        "");
    }
  }

  CFG_output* CFG_output::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CFG_output (*this, f, c);
  }

  CFG_output& CFG_output::
  operator= (const CFG_output& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->receiver_ = x.receiver_;
      this->data_id_ = x.data_id_;
      this->pos_ = x.pos_;
      this->source_vr_ = x.source_vr_;
    }

    return *this;
  }

  CFG_output::
  ~CFG_output ()
  {
  }

  // CFG_source_network_information
  //

  CFG_source_network_information::
  CFG_source_network_information (const receiver_type& receiver,
                                  const data_id_type& data_id,
                                  const transport_protocol_type& transport_protocol)
  : ::xml_schema::type (),
    receiver_ (receiver, this),
    data_id_ (data_id, this),
    transport_protocol_ (transport_protocol, this)
  {
  }

  CFG_source_network_information::
  CFG_source_network_information (const CFG_source_network_information& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    receiver_ (x.receiver_, f, this),
    data_id_ (x.data_id_, f, this),
    transport_protocol_ (x.transport_protocol_, f, this)
  {
  }

  CFG_source_network_information::
  CFG_source_network_information (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    receiver_ (this),
    data_id_ (this),
    transport_protocol_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void CFG_source_network_information::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "receiver" && n.namespace_ ().empty ())
      {
        this->receiver_.set (receiver_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "data_id" && n.namespace_ ().empty ())
      {
        this->data_id_.set (data_id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "transport_protocol" && n.namespace_ ().empty ())
      {
        this->transport_protocol_.set (transport_protocol_traits::create (i, f, this));
        continue;
      }
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "receiver",
        "");
    }

    if (!data_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "data_id",
        "");
    }

    if (!transport_protocol_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "transport_protocol",
        "");
    }
  }

  CFG_source_network_information* CFG_source_network_information::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CFG_source_network_information (*this, f, c);
  }

  CFG_source_network_information& CFG_source_network_information::
  operator= (const CFG_source_network_information& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->receiver_ = x.receiver_;
      this->data_id_ = x.data_id_;
      this->transport_protocol_ = x.transport_protocol_;
    }

    return *this;
  }

  CFG_source_network_information::
  ~CFG_source_network_information ()
  {
  }

  // CFG_source_network_information_UDP_IPv4
  //

  CFG_source_network_information_UDP_IPv4::
  CFG_source_network_information_UDP_IPv4 (const receiver_type& receiver,
                                           const data_id_type& data_id,
                                           const transport_protocol_type& transport_protocol,
                                           const ip_address_type& ip_address,
                                           const port_type& port)
  : ::xml_schema::type (),
    receiver_ (receiver, this),
    data_id_ (data_id, this),
    transport_protocol_ (transport_protocol, this),
    ip_address_ (ip_address, this),
    port_ (port, this)
  {
  }

  CFG_source_network_information_UDP_IPv4::
  CFG_source_network_information_UDP_IPv4 (const CFG_source_network_information_UDP_IPv4& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    receiver_ (x.receiver_, f, this),
    data_id_ (x.data_id_, f, this),
    transport_protocol_ (x.transport_protocol_, f, this),
    ip_address_ (x.ip_address_, f, this),
    port_ (x.port_, f, this)
  {
  }

  CFG_source_network_information_UDP_IPv4::
  CFG_source_network_information_UDP_IPv4 (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    receiver_ (this),
    data_id_ (this),
    transport_protocol_ (this),
    ip_address_ (this),
    port_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void CFG_source_network_information_UDP_IPv4::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "receiver" && n.namespace_ ().empty ())
      {
        this->receiver_.set (receiver_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "data_id" && n.namespace_ ().empty ())
      {
        this->data_id_.set (data_id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "transport_protocol" && n.namespace_ ().empty ())
      {
        this->transport_protocol_.set (transport_protocol_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ip_address" && n.namespace_ ().empty ())
      {
        this->ip_address_.set (ip_address_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "port" && n.namespace_ ().empty ())
      {
        this->port_.set (port_traits::create (i, f, this));
        continue;
      }
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "receiver",
        "");
    }

    if (!data_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "data_id",
        "");
    }

    if (!transport_protocol_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "transport_protocol",
        "");
    }

    if (!ip_address_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ip_address",
        "");
    }

    if (!port_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "port",
        "");
    }
  }

  CFG_source_network_information_UDP_IPv4* CFG_source_network_information_UDP_IPv4::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CFG_source_network_information_UDP_IPv4 (*this, f, c);
  }

  CFG_source_network_information_UDP_IPv4& CFG_source_network_information_UDP_IPv4::
  operator= (const CFG_source_network_information_UDP_IPv4& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->receiver_ = x.receiver_;
      this->data_id_ = x.data_id_;
      this->transport_protocol_ = x.transport_protocol_;
      this->ip_address_ = x.ip_address_;
      this->port_ = x.port_;
    }

    return *this;
  }

  CFG_source_network_information_UDP_IPv4::
  ~CFG_source_network_information_UDP_IPv4 ()
  {
  }

  // CFG_source_network_information_USB
  //

  CFG_source_network_information_USB::
  CFG_source_network_information_USB (const receiver_type& receiver,
                                      const data_id_type& data_id,
                                      const transport_protocol_type& transport_protocol,
                                      const endpoint_address_type& endpoint_address)
  : ::xml_schema::type (),
    receiver_ (receiver, this),
    data_id_ (data_id, this),
    transport_protocol_ (transport_protocol, this),
    endpoint_address_ (endpoint_address, this)
  {
  }

  CFG_source_network_information_USB::
  CFG_source_network_information_USB (const CFG_source_network_information_USB& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    receiver_ (x.receiver_, f, this),
    data_id_ (x.data_id_, f, this),
    transport_protocol_ (x.transport_protocol_, f, this),
    endpoint_address_ (x.endpoint_address_, f, this)
  {
  }

  CFG_source_network_information_USB::
  CFG_source_network_information_USB (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    receiver_ (this),
    data_id_ (this),
    transport_protocol_ (this),
    endpoint_address_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void CFG_source_network_information_USB::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "receiver" && n.namespace_ ().empty ())
      {
        this->receiver_.set (receiver_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "data_id" && n.namespace_ ().empty ())
      {
        this->data_id_.set (data_id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "transport_protocol" && n.namespace_ ().empty ())
      {
        this->transport_protocol_.set (transport_protocol_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "endpoint_address" && n.namespace_ ().empty ())
      {
        this->endpoint_address_.set (endpoint_address_traits::create (i, f, this));
        continue;
      }
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "receiver",
        "");
    }

    if (!data_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "data_id",
        "");
    }

    if (!transport_protocol_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "transport_protocol",
        "");
    }

    if (!endpoint_address_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "endpoint_address",
        "");
    }
  }

  CFG_source_network_information_USB* CFG_source_network_information_USB::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CFG_source_network_information_USB (*this, f, c);
  }

  CFG_source_network_information_USB& CFG_source_network_information_USB::
  operator= (const CFG_source_network_information_USB& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->receiver_ = x.receiver_;
      this->data_id_ = x.data_id_;
      this->transport_protocol_ = x.transport_protocol_;
      this->endpoint_address_ = x.endpoint_address_;
    }

    return *this;
  }

  CFG_source_network_information_USB::
  ~CFG_source_network_information_USB ()
  {
  }

  // CFG_source_network_information_Bluetooth
  //

  CFG_source_network_information_Bluetooth::
  CFG_source_network_information_Bluetooth (const receiver_type& receiver,
                                            const data_id_type& data_id,
                                            const transport_protocol_type& transport_protocol,
                                            const port_type& port,
                                            const bd_addr_type& bd_addr)
  : ::xml_schema::type (),
    receiver_ (receiver, this),
    data_id_ (data_id, this),
    transport_protocol_ (transport_protocol, this),
    port_ (port, this),
    bd_addr_ (bd_addr, this)
  {
  }

  CFG_source_network_information_Bluetooth::
  CFG_source_network_information_Bluetooth (const CFG_source_network_information_Bluetooth& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    receiver_ (x.receiver_, f, this),
    data_id_ (x.data_id_, f, this),
    transport_protocol_ (x.transport_protocol_, f, this),
    port_ (x.port_, f, this),
    bd_addr_ (x.bd_addr_, f, this)
  {
  }

  CFG_source_network_information_Bluetooth::
  CFG_source_network_information_Bluetooth (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    receiver_ (this),
    data_id_ (this),
    transport_protocol_ (this),
    port_ (this),
    bd_addr_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void CFG_source_network_information_Bluetooth::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "receiver" && n.namespace_ ().empty ())
      {
        this->receiver_.set (receiver_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "data_id" && n.namespace_ ().empty ())
      {
        this->data_id_.set (data_id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "transport_protocol" && n.namespace_ ().empty ())
      {
        this->transport_protocol_.set (transport_protocol_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "port" && n.namespace_ ().empty ())
      {
        this->port_.set (port_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "bd_addr" && n.namespace_ ().empty ())
      {
        this->bd_addr_.set (bd_addr_traits::create (i, f, this));
        continue;
      }
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "receiver",
        "");
    }

    if (!data_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "data_id",
        "");
    }

    if (!transport_protocol_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "transport_protocol",
        "");
    }

    if (!port_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "port",
        "");
    }

    if (!bd_addr_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "bd_addr",
        "");
    }
  }

  CFG_source_network_information_Bluetooth* CFG_source_network_information_Bluetooth::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CFG_source_network_information_Bluetooth (*this, f, c);
  }

  CFG_source_network_information_Bluetooth& CFG_source_network_information_Bluetooth::
  operator= (const CFG_source_network_information_Bluetooth& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->receiver_ = x.receiver_;
      this->data_id_ = x.data_id_;
      this->transport_protocol_ = x.transport_protocol_;
      this->port_ = x.port_;
      this->bd_addr_ = x.bd_addr_;
    }

    return *this;
  }

  CFG_source_network_information_Bluetooth::
  ~CFG_source_network_information_Bluetooth ()
  {
  }

  // CFG_source_network_information_TCP_IPv4
  //

  CFG_source_network_information_TCP_IPv4::
  CFG_source_network_information_TCP_IPv4 (const receiver_type& receiver,
                                           const data_id_type& data_id,
                                           const transport_protocol_type& transport_protocol,
                                           const ip_address_type& ip_address,
                                           const port_type& port)
  : ::xml_schema::type (),
    receiver_ (receiver, this),
    data_id_ (data_id, this),
    transport_protocol_ (transport_protocol, this),
    ip_address_ (ip_address, this),
    port_ (port, this)
  {
  }

  CFG_source_network_information_TCP_IPv4::
  CFG_source_network_information_TCP_IPv4 (const CFG_source_network_information_TCP_IPv4& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    receiver_ (x.receiver_, f, this),
    data_id_ (x.data_id_, f, this),
    transport_protocol_ (x.transport_protocol_, f, this),
    ip_address_ (x.ip_address_, f, this),
    port_ (x.port_, f, this)
  {
  }

  CFG_source_network_information_TCP_IPv4::
  CFG_source_network_information_TCP_IPv4 (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    receiver_ (this),
    data_id_ (this),
    transport_protocol_ (this),
    ip_address_ (this),
    port_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void CFG_source_network_information_TCP_IPv4::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "receiver" && n.namespace_ ().empty ())
      {
        this->receiver_.set (receiver_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "data_id" && n.namespace_ ().empty ())
      {
        this->data_id_.set (data_id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "transport_protocol" && n.namespace_ ().empty ())
      {
        this->transport_protocol_.set (transport_protocol_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ip_address" && n.namespace_ ().empty ())
      {
        this->ip_address_.set (ip_address_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "port" && n.namespace_ ().empty ())
      {
        this->port_.set (port_traits::create (i, f, this));
        continue;
      }
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "receiver",
        "");
    }

    if (!data_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "data_id",
        "");
    }

    if (!transport_protocol_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "transport_protocol",
        "");
    }

    if (!ip_address_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ip_address",
        "");
    }

    if (!port_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "port",
        "");
    }
  }

  CFG_source_network_information_TCP_IPv4* CFG_source_network_information_TCP_IPv4::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CFG_source_network_information_TCP_IPv4 (*this, f, c);
  }

  CFG_source_network_information_TCP_IPv4& CFG_source_network_information_TCP_IPv4::
  operator= (const CFG_source_network_information_TCP_IPv4& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->receiver_ = x.receiver_;
      this->data_id_ = x.data_id_;
      this->transport_protocol_ = x.transport_protocol_;
      this->ip_address_ = x.ip_address_;
      this->port_ = x.port_;
    }

    return *this;
  }

  CFG_source_network_information_TCP_IPv4::
  ~CFG_source_network_information_TCP_IPv4 ()
  {
  }

  // CFG_target_network_information
  //

  CFG_target_network_information::
  CFG_target_network_information (const receiver_type& receiver,
                                  const data_id_type& data_id,
                                  const transport_protocol_type& transport_protocol)
  : ::xml_schema::type (),
    receiver_ (receiver, this),
    data_id_ (data_id, this),
    transport_protocol_ (transport_protocol, this)
  {
  }

  CFG_target_network_information::
  CFG_target_network_information (const CFG_target_network_information& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    receiver_ (x.receiver_, f, this),
    data_id_ (x.data_id_, f, this),
    transport_protocol_ (x.transport_protocol_, f, this)
  {
  }

  CFG_target_network_information::
  CFG_target_network_information (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    receiver_ (this),
    data_id_ (this),
    transport_protocol_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void CFG_target_network_information::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "receiver" && n.namespace_ ().empty ())
      {
        this->receiver_.set (receiver_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "data_id" && n.namespace_ ().empty ())
      {
        this->data_id_.set (data_id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "transport_protocol" && n.namespace_ ().empty ())
      {
        this->transport_protocol_.set (transport_protocol_traits::create (i, f, this));
        continue;
      }
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "receiver",
        "");
    }

    if (!data_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "data_id",
        "");
    }

    if (!transport_protocol_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "transport_protocol",
        "");
    }
  }

  CFG_target_network_information* CFG_target_network_information::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CFG_target_network_information (*this, f, c);
  }

  CFG_target_network_information& CFG_target_network_information::
  operator= (const CFG_target_network_information& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->receiver_ = x.receiver_;
      this->data_id_ = x.data_id_;
      this->transport_protocol_ = x.transport_protocol_;
    }

    return *this;
  }

  CFG_target_network_information::
  ~CFG_target_network_information ()
  {
  }

  // CFG_target_network_information_UDP_IPv4
  //

  CFG_target_network_information_UDP_IPv4::
  CFG_target_network_information_UDP_IPv4 (const receiver_type& receiver,
                                           const data_id_type& data_id,
                                           const transport_protocol_type& transport_protocol,
                                           const ip_address_type& ip_address,
                                           const port_type& port)
  : ::xml_schema::type (),
    receiver_ (receiver, this),
    data_id_ (data_id, this),
    transport_protocol_ (transport_protocol, this),
    ip_address_ (ip_address, this),
    port_ (port, this)
  {
  }

  CFG_target_network_information_UDP_IPv4::
  CFG_target_network_information_UDP_IPv4 (const CFG_target_network_information_UDP_IPv4& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    receiver_ (x.receiver_, f, this),
    data_id_ (x.data_id_, f, this),
    transport_protocol_ (x.transport_protocol_, f, this),
    ip_address_ (x.ip_address_, f, this),
    port_ (x.port_, f, this)
  {
  }

  CFG_target_network_information_UDP_IPv4::
  CFG_target_network_information_UDP_IPv4 (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    receiver_ (this),
    data_id_ (this),
    transport_protocol_ (this),
    ip_address_ (this),
    port_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void CFG_target_network_information_UDP_IPv4::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "receiver" && n.namespace_ ().empty ())
      {
        this->receiver_.set (receiver_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "data_id" && n.namespace_ ().empty ())
      {
        this->data_id_.set (data_id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "transport_protocol" && n.namespace_ ().empty ())
      {
        this->transport_protocol_.set (transport_protocol_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ip_address" && n.namespace_ ().empty ())
      {
        this->ip_address_.set (ip_address_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "port" && n.namespace_ ().empty ())
      {
        this->port_.set (port_traits::create (i, f, this));
        continue;
      }
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "receiver",
        "");
    }

    if (!data_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "data_id",
        "");
    }

    if (!transport_protocol_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "transport_protocol",
        "");
    }

    if (!ip_address_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ip_address",
        "");
    }

    if (!port_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "port",
        "");
    }
  }

  CFG_target_network_information_UDP_IPv4* CFG_target_network_information_UDP_IPv4::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CFG_target_network_information_UDP_IPv4 (*this, f, c);
  }

  CFG_target_network_information_UDP_IPv4& CFG_target_network_information_UDP_IPv4::
  operator= (const CFG_target_network_information_UDP_IPv4& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->receiver_ = x.receiver_;
      this->data_id_ = x.data_id_;
      this->transport_protocol_ = x.transport_protocol_;
      this->ip_address_ = x.ip_address_;
      this->port_ = x.port_;
    }

    return *this;
  }

  CFG_target_network_information_UDP_IPv4::
  ~CFG_target_network_information_UDP_IPv4 ()
  {
  }

  // CFG_target_network_information_USB
  //

  CFG_target_network_information_USB::
  CFG_target_network_information_USB (const receiver_type& receiver,
                                      const data_id_type& data_id,
                                      const transport_protocol_type& transport_protocol,
                                      const endpoint_address_type& endpoint_address,
                                      const slave_uuid_type& slave_uuid)
  : ::xml_schema::type (),
    receiver_ (receiver, this),
    data_id_ (data_id, this),
    transport_protocol_ (transport_protocol, this),
    endpoint_address_ (endpoint_address, this),
    slave_uuid_ (slave_uuid, this)
  {
  }

  CFG_target_network_information_USB::
  CFG_target_network_information_USB (const CFG_target_network_information_USB& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    receiver_ (x.receiver_, f, this),
    data_id_ (x.data_id_, f, this),
    transport_protocol_ (x.transport_protocol_, f, this),
    endpoint_address_ (x.endpoint_address_, f, this),
    slave_uuid_ (x.slave_uuid_, f, this)
  {
  }

  CFG_target_network_information_USB::
  CFG_target_network_information_USB (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    receiver_ (this),
    data_id_ (this),
    transport_protocol_ (this),
    endpoint_address_ (this),
    slave_uuid_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void CFG_target_network_information_USB::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "receiver" && n.namespace_ ().empty ())
      {
        this->receiver_.set (receiver_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "data_id" && n.namespace_ ().empty ())
      {
        this->data_id_.set (data_id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "transport_protocol" && n.namespace_ ().empty ())
      {
        this->transport_protocol_.set (transport_protocol_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "endpoint_address" && n.namespace_ ().empty ())
      {
        this->endpoint_address_.set (endpoint_address_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "slave_uuid" && n.namespace_ ().empty ())
      {
        this->slave_uuid_.set (slave_uuid_traits::create (i, f, this));
        continue;
      }
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "receiver",
        "");
    }

    if (!data_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "data_id",
        "");
    }

    if (!transport_protocol_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "transport_protocol",
        "");
    }

    if (!endpoint_address_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "endpoint_address",
        "");
    }

    if (!slave_uuid_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "slave_uuid",
        "");
    }
  }

  CFG_target_network_information_USB* CFG_target_network_information_USB::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CFG_target_network_information_USB (*this, f, c);
  }

  CFG_target_network_information_USB& CFG_target_network_information_USB::
  operator= (const CFG_target_network_information_USB& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->receiver_ = x.receiver_;
      this->data_id_ = x.data_id_;
      this->transport_protocol_ = x.transport_protocol_;
      this->endpoint_address_ = x.endpoint_address_;
      this->slave_uuid_ = x.slave_uuid_;
    }

    return *this;
  }

  CFG_target_network_information_USB::
  ~CFG_target_network_information_USB ()
  {
  }

  // CFG_target_network_information_Bluetooth
  //

  CFG_target_network_information_Bluetooth::
  CFG_target_network_information_Bluetooth (const receiver_type& receiver,
                                            const data_id_type& data_id,
                                            const transport_protocol_type& transport_protocol,
                                            const port_type& port,
                                            const bd_addr_type& bd_addr)
  : ::xml_schema::type (),
    receiver_ (receiver, this),
    data_id_ (data_id, this),
    transport_protocol_ (transport_protocol, this),
    port_ (port, this),
    bd_addr_ (bd_addr, this)
  {
  }

  CFG_target_network_information_Bluetooth::
  CFG_target_network_information_Bluetooth (const CFG_target_network_information_Bluetooth& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    receiver_ (x.receiver_, f, this),
    data_id_ (x.data_id_, f, this),
    transport_protocol_ (x.transport_protocol_, f, this),
    port_ (x.port_, f, this),
    bd_addr_ (x.bd_addr_, f, this)
  {
  }

  CFG_target_network_information_Bluetooth::
  CFG_target_network_information_Bluetooth (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    receiver_ (this),
    data_id_ (this),
    transport_protocol_ (this),
    port_ (this),
    bd_addr_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void CFG_target_network_information_Bluetooth::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "receiver" && n.namespace_ ().empty ())
      {
        this->receiver_.set (receiver_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "data_id" && n.namespace_ ().empty ())
      {
        this->data_id_.set (data_id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "transport_protocol" && n.namespace_ ().empty ())
      {
        this->transport_protocol_.set (transport_protocol_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "port" && n.namespace_ ().empty ())
      {
        this->port_.set (port_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "bd_addr" && n.namespace_ ().empty ())
      {
        this->bd_addr_.set (bd_addr_traits::create (i, f, this));
        continue;
      }
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "receiver",
        "");
    }

    if (!data_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "data_id",
        "");
    }

    if (!transport_protocol_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "transport_protocol",
        "");
    }

    if (!port_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "port",
        "");
    }

    if (!bd_addr_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "bd_addr",
        "");
    }
  }

  CFG_target_network_information_Bluetooth* CFG_target_network_information_Bluetooth::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CFG_target_network_information_Bluetooth (*this, f, c);
  }

  CFG_target_network_information_Bluetooth& CFG_target_network_information_Bluetooth::
  operator= (const CFG_target_network_information_Bluetooth& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->receiver_ = x.receiver_;
      this->data_id_ = x.data_id_;
      this->transport_protocol_ = x.transport_protocol_;
      this->port_ = x.port_;
      this->bd_addr_ = x.bd_addr_;
    }

    return *this;
  }

  CFG_target_network_information_Bluetooth::
  ~CFG_target_network_information_Bluetooth ()
  {
  }

  // CFG_target_network_information_TCP_IPv4
  //

  CFG_target_network_information_TCP_IPv4::
  CFG_target_network_information_TCP_IPv4 (const receiver_type& receiver,
                                           const data_id_type& data_id,
                                           const transport_protocol_type& transport_protocol,
                                           const ip_address_type& ip_address,
                                           const port_type& port)
  : ::xml_schema::type (),
    receiver_ (receiver, this),
    data_id_ (data_id, this),
    transport_protocol_ (transport_protocol, this),
    ip_address_ (ip_address, this),
    port_ (port, this)
  {
  }

  CFG_target_network_information_TCP_IPv4::
  CFG_target_network_information_TCP_IPv4 (const CFG_target_network_information_TCP_IPv4& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    receiver_ (x.receiver_, f, this),
    data_id_ (x.data_id_, f, this),
    transport_protocol_ (x.transport_protocol_, f, this),
    ip_address_ (x.ip_address_, f, this),
    port_ (x.port_, f, this)
  {
  }

  CFG_target_network_information_TCP_IPv4::
  CFG_target_network_information_TCP_IPv4 (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    receiver_ (this),
    data_id_ (this),
    transport_protocol_ (this),
    ip_address_ (this),
    port_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void CFG_target_network_information_TCP_IPv4::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "receiver" && n.namespace_ ().empty ())
      {
        this->receiver_.set (receiver_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "data_id" && n.namespace_ ().empty ())
      {
        this->data_id_.set (data_id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "transport_protocol" && n.namespace_ ().empty ())
      {
        this->transport_protocol_.set (transport_protocol_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ip_address" && n.namespace_ ().empty ())
      {
        this->ip_address_.set (ip_address_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "port" && n.namespace_ ().empty ())
      {
        this->port_.set (port_traits::create (i, f, this));
        continue;
      }
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "receiver",
        "");
    }

    if (!data_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "data_id",
        "");
    }

    if (!transport_protocol_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "transport_protocol",
        "");
    }

    if (!ip_address_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ip_address",
        "");
    }

    if (!port_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "port",
        "");
    }
  }

  CFG_target_network_information_TCP_IPv4* CFG_target_network_information_TCP_IPv4::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CFG_target_network_information_TCP_IPv4 (*this, f, c);
  }

  CFG_target_network_information_TCP_IPv4& CFG_target_network_information_TCP_IPv4::
  operator= (const CFG_target_network_information_TCP_IPv4& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->receiver_ = x.receiver_;
      this->data_id_ = x.data_id_;
      this->transport_protocol_ = x.transport_protocol_;
      this->ip_address_ = x.ip_address_;
      this->port_ = x.port_;
    }

    return *this;
  }

  CFG_target_network_information_TCP_IPv4::
  ~CFG_target_network_information_TCP_IPv4 ()
  {
  }

  // CFG_clear
  //

  CFG_clear::
  CFG_clear (const receiver_type& receiver)
  : ::xml_schema::type (),
    receiver_ (receiver, this)
  {
  }

  CFG_clear::
  CFG_clear (const CFG_clear& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    receiver_ (x.receiver_, f, this)
  {
  }

  CFG_clear::
  CFG_clear (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    receiver_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void CFG_clear::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "receiver" && n.namespace_ ().empty ())
      {
        this->receiver_.set (receiver_traits::create (i, f, this));
        continue;
      }
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "receiver",
        "");
    }
  }

  CFG_clear* CFG_clear::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CFG_clear (*this, f, c);
  }

  CFG_clear& CFG_clear::
  operator= (const CFG_clear& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->receiver_ = x.receiver_;
    }

    return *this;
  }

  CFG_clear::
  ~CFG_clear ()
  {
  }

  // CFG_parameter
  //

  CFG_parameter::
  CFG_parameter (const Payload_type& Payload,
                 const receiver_type& receiver,
                 const target_vr_type& target_vr,
                 const source_data_type_type& source_data_type)
  : ::xml_schema::type (),
    Payload_ (Payload, this),
    receiver_ (receiver, this),
    target_vr_ (target_vr, this),
    source_data_type_ (source_data_type, this)
  {
  }

  CFG_parameter::
  CFG_parameter (::std::auto_ptr< Payload_type > Payload,
                 const receiver_type& receiver,
                 const target_vr_type& target_vr,
                 const source_data_type_type& source_data_type)
  : ::xml_schema::type (),
    Payload_ (Payload, this),
    receiver_ (receiver, this),
    target_vr_ (target_vr, this),
    source_data_type_ (source_data_type, this)
  {
  }

  CFG_parameter::
  CFG_parameter (const CFG_parameter& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Payload_ (x.Payload_, f, this),
    receiver_ (x.receiver_, f, this),
    target_vr_ (x.target_vr_, f, this),
    source_data_type_ (x.source_data_type_, f, this)
  {
  }

  CFG_parameter::
  CFG_parameter (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Payload_ (this),
    receiver_ (this),
    target_vr_ (this),
    source_data_type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void CFG_parameter::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Payload
      //
      if (n.name () == "Payload" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Payload_type > r (
          Payload_traits::create (i, f, this));

        if (!Payload_.present ())
        {
          this->Payload_.set (r);
          continue;
        }
      }

      break;
    }

    if (!Payload_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Payload",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "receiver" && n.namespace_ ().empty ())
      {
        this->receiver_.set (receiver_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "target_vr" && n.namespace_ ().empty ())
      {
        this->target_vr_.set (target_vr_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "source_data_type" && n.namespace_ ().empty ())
      {
        this->source_data_type_.set (source_data_type_traits::create (i, f, this));
        continue;
      }
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "receiver",
        "");
    }

    if (!target_vr_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "target_vr",
        "");
    }

    if (!source_data_type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "source_data_type",
        "");
    }
  }

  CFG_parameter* CFG_parameter::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CFG_parameter (*this, f, c);
  }

  CFG_parameter& CFG_parameter::
  operator= (const CFG_parameter& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Payload_ = x.Payload_;
      this->receiver_ = x.receiver_;
      this->target_vr_ = x.target_vr_;
      this->source_data_type_ = x.source_data_type_;
    }

    return *this;
  }

  CFG_parameter::
  ~CFG_parameter ()
  {
  }

  // CFG_tunable_parameter
  //

  CFG_tunable_parameter::
  CFG_tunable_parameter (const receiver_type& receiver,
                         const param_id_type& param_id,
                         const pos_type& pos,
                         const target_vr_type& target_vr,
                         const source_data_type_type& source_data_type)
  : ::xml_schema::type (),
    receiver_ (receiver, this),
    param_id_ (param_id, this),
    pos_ (pos, this),
    target_vr_ (target_vr, this),
    source_data_type_ (source_data_type, this)
  {
  }

  CFG_tunable_parameter::
  CFG_tunable_parameter (const CFG_tunable_parameter& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    receiver_ (x.receiver_, f, this),
    param_id_ (x.param_id_, f, this),
    pos_ (x.pos_, f, this),
    target_vr_ (x.target_vr_, f, this),
    source_data_type_ (x.source_data_type_, f, this)
  {
  }

  CFG_tunable_parameter::
  CFG_tunable_parameter (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    receiver_ (this),
    param_id_ (this),
    pos_ (this),
    target_vr_ (this),
    source_data_type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void CFG_tunable_parameter::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "receiver" && n.namespace_ ().empty ())
      {
        this->receiver_.set (receiver_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "param_id" && n.namespace_ ().empty ())
      {
        this->param_id_.set (param_id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "pos" && n.namespace_ ().empty ())
      {
        this->pos_.set (pos_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "target_vr" && n.namespace_ ().empty ())
      {
        this->target_vr_.set (target_vr_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "source_data_type" && n.namespace_ ().empty ())
      {
        this->source_data_type_.set (source_data_type_traits::create (i, f, this));
        continue;
      }
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "receiver",
        "");
    }

    if (!param_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "param_id",
        "");
    }

    if (!pos_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "pos",
        "");
    }

    if (!target_vr_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "target_vr",
        "");
    }

    if (!source_data_type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "source_data_type",
        "");
    }
  }

  CFG_tunable_parameter* CFG_tunable_parameter::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CFG_tunable_parameter (*this, f, c);
  }

  CFG_tunable_parameter& CFG_tunable_parameter::
  operator= (const CFG_tunable_parameter& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->receiver_ = x.receiver_;
      this->param_id_ = x.param_id_;
      this->pos_ = x.pos_;
      this->target_vr_ = x.target_vr_;
      this->source_data_type_ = x.source_data_type_;
    }

    return *this;
  }

  CFG_tunable_parameter::
  ~CFG_tunable_parameter ()
  {
  }

  // CFG_param_network_information
  //

  CFG_param_network_information::
  CFG_param_network_information (const receiver_type& receiver,
                                 const param_id_type& param_id,
                                 const transport_protocol_type& transport_protocol)
  : ::xml_schema::type (),
    receiver_ (receiver, this),
    param_id_ (param_id, this),
    transport_protocol_ (transport_protocol, this)
  {
  }

  CFG_param_network_information::
  CFG_param_network_information (const CFG_param_network_information& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    receiver_ (x.receiver_, f, this),
    param_id_ (x.param_id_, f, this),
    transport_protocol_ (x.transport_protocol_, f, this)
  {
  }

  CFG_param_network_information::
  CFG_param_network_information (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    receiver_ (this),
    param_id_ (this),
    transport_protocol_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void CFG_param_network_information::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "receiver" && n.namespace_ ().empty ())
      {
        this->receiver_.set (receiver_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "param_id" && n.namespace_ ().empty ())
      {
        this->param_id_.set (param_id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "transport_protocol" && n.namespace_ ().empty ())
      {
        this->transport_protocol_.set (transport_protocol_traits::create (i, f, this));
        continue;
      }
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "receiver",
        "");
    }

    if (!param_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "param_id",
        "");
    }

    if (!transport_protocol_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "transport_protocol",
        "");
    }
  }

  CFG_param_network_information* CFG_param_network_information::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CFG_param_network_information (*this, f, c);
  }

  CFG_param_network_information& CFG_param_network_information::
  operator= (const CFG_param_network_information& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->receiver_ = x.receiver_;
      this->param_id_ = x.param_id_;
      this->transport_protocol_ = x.transport_protocol_;
    }

    return *this;
  }

  CFG_param_network_information::
  ~CFG_param_network_information ()
  {
  }

  // CFG_param_network_information_UDP_IPv4
  //

  CFG_param_network_information_UDP_IPv4::
  CFG_param_network_information_UDP_IPv4 (const receiver_type& receiver,
                                          const param_id_type& param_id,
                                          const transport_protocol_type& transport_protocol,
                                          const ip_address_type& ip_address,
                                          const port_type& port)
  : ::xml_schema::type (),
    receiver_ (receiver, this),
    param_id_ (param_id, this),
    transport_protocol_ (transport_protocol, this),
    ip_address_ (ip_address, this),
    port_ (port, this)
  {
  }

  CFG_param_network_information_UDP_IPv4::
  CFG_param_network_information_UDP_IPv4 (const CFG_param_network_information_UDP_IPv4& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    receiver_ (x.receiver_, f, this),
    param_id_ (x.param_id_, f, this),
    transport_protocol_ (x.transport_protocol_, f, this),
    ip_address_ (x.ip_address_, f, this),
    port_ (x.port_, f, this)
  {
  }

  CFG_param_network_information_UDP_IPv4::
  CFG_param_network_information_UDP_IPv4 (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    receiver_ (this),
    param_id_ (this),
    transport_protocol_ (this),
    ip_address_ (this),
    port_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void CFG_param_network_information_UDP_IPv4::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "receiver" && n.namespace_ ().empty ())
      {
        this->receiver_.set (receiver_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "param_id" && n.namespace_ ().empty ())
      {
        this->param_id_.set (param_id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "transport_protocol" && n.namespace_ ().empty ())
      {
        this->transport_protocol_.set (transport_protocol_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ip_address" && n.namespace_ ().empty ())
      {
        this->ip_address_.set (ip_address_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "port" && n.namespace_ ().empty ())
      {
        this->port_.set (port_traits::create (i, f, this));
        continue;
      }
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "receiver",
        "");
    }

    if (!param_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "param_id",
        "");
    }

    if (!transport_protocol_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "transport_protocol",
        "");
    }

    if (!ip_address_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ip_address",
        "");
    }

    if (!port_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "port",
        "");
    }
  }

  CFG_param_network_information_UDP_IPv4* CFG_param_network_information_UDP_IPv4::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CFG_param_network_information_UDP_IPv4 (*this, f, c);
  }

  CFG_param_network_information_UDP_IPv4& CFG_param_network_information_UDP_IPv4::
  operator= (const CFG_param_network_information_UDP_IPv4& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->receiver_ = x.receiver_;
      this->param_id_ = x.param_id_;
      this->transport_protocol_ = x.transport_protocol_;
      this->ip_address_ = x.ip_address_;
      this->port_ = x.port_;
    }

    return *this;
  }

  CFG_param_network_information_UDP_IPv4::
  ~CFG_param_network_information_UDP_IPv4 ()
  {
  }

  // CFG_param_network_information_USB
  //

  CFG_param_network_information_USB::
  CFG_param_network_information_USB (const receiver_type& receiver,
                                     const data_id_type& data_id,
                                     const transport_protocol_type& transport_protocol,
                                     const endpoint_address_type& endpoint_address)
  : ::xml_schema::type (),
    receiver_ (receiver, this),
    data_id_ (data_id, this),
    transport_protocol_ (transport_protocol, this),
    endpoint_address_ (endpoint_address, this)
  {
  }

  CFG_param_network_information_USB::
  CFG_param_network_information_USB (const CFG_param_network_information_USB& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    receiver_ (x.receiver_, f, this),
    data_id_ (x.data_id_, f, this),
    transport_protocol_ (x.transport_protocol_, f, this),
    endpoint_address_ (x.endpoint_address_, f, this)
  {
  }

  CFG_param_network_information_USB::
  CFG_param_network_information_USB (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    receiver_ (this),
    data_id_ (this),
    transport_protocol_ (this),
    endpoint_address_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void CFG_param_network_information_USB::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "receiver" && n.namespace_ ().empty ())
      {
        this->receiver_.set (receiver_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "data_id" && n.namespace_ ().empty ())
      {
        this->data_id_.set (data_id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "transport_protocol" && n.namespace_ ().empty ())
      {
        this->transport_protocol_.set (transport_protocol_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "endpoint_address" && n.namespace_ ().empty ())
      {
        this->endpoint_address_.set (endpoint_address_traits::create (i, f, this));
        continue;
      }
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "receiver",
        "");
    }

    if (!data_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "data_id",
        "");
    }

    if (!transport_protocol_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "transport_protocol",
        "");
    }

    if (!endpoint_address_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "endpoint_address",
        "");
    }
  }

  CFG_param_network_information_USB* CFG_param_network_information_USB::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CFG_param_network_information_USB (*this, f, c);
  }

  CFG_param_network_information_USB& CFG_param_network_information_USB::
  operator= (const CFG_param_network_information_USB& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->receiver_ = x.receiver_;
      this->data_id_ = x.data_id_;
      this->transport_protocol_ = x.transport_protocol_;
      this->endpoint_address_ = x.endpoint_address_;
    }

    return *this;
  }

  CFG_param_network_information_USB::
  ~CFG_param_network_information_USB ()
  {
  }

  // CFG_param_network_information_Bluetooth
  //

  CFG_param_network_information_Bluetooth::
  CFG_param_network_information_Bluetooth (const receiver_type& receiver,
                                           const data_id_type& data_id,
                                           const transport_protocol_type& transport_protocol,
                                           const port_type& port,
                                           const bd_addr_type& bd_addr)
  : ::xml_schema::type (),
    receiver_ (receiver, this),
    data_id_ (data_id, this),
    transport_protocol_ (transport_protocol, this),
    port_ (port, this),
    bd_addr_ (bd_addr, this)
  {
  }

  CFG_param_network_information_Bluetooth::
  CFG_param_network_information_Bluetooth (const CFG_param_network_information_Bluetooth& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    receiver_ (x.receiver_, f, this),
    data_id_ (x.data_id_, f, this),
    transport_protocol_ (x.transport_protocol_, f, this),
    port_ (x.port_, f, this),
    bd_addr_ (x.bd_addr_, f, this)
  {
  }

  CFG_param_network_information_Bluetooth::
  CFG_param_network_information_Bluetooth (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    receiver_ (this),
    data_id_ (this),
    transport_protocol_ (this),
    port_ (this),
    bd_addr_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void CFG_param_network_information_Bluetooth::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "receiver" && n.namespace_ ().empty ())
      {
        this->receiver_.set (receiver_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "data_id" && n.namespace_ ().empty ())
      {
        this->data_id_.set (data_id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "transport_protocol" && n.namespace_ ().empty ())
      {
        this->transport_protocol_.set (transport_protocol_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "port" && n.namespace_ ().empty ())
      {
        this->port_.set (port_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "bd_addr" && n.namespace_ ().empty ())
      {
        this->bd_addr_.set (bd_addr_traits::create (i, f, this));
        continue;
      }
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "receiver",
        "");
    }

    if (!data_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "data_id",
        "");
    }

    if (!transport_protocol_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "transport_protocol",
        "");
    }

    if (!port_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "port",
        "");
    }

    if (!bd_addr_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "bd_addr",
        "");
    }
  }

  CFG_param_network_information_Bluetooth* CFG_param_network_information_Bluetooth::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CFG_param_network_information_Bluetooth (*this, f, c);
  }

  CFG_param_network_information_Bluetooth& CFG_param_network_information_Bluetooth::
  operator= (const CFG_param_network_information_Bluetooth& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->receiver_ = x.receiver_;
      this->data_id_ = x.data_id_;
      this->transport_protocol_ = x.transport_protocol_;
      this->port_ = x.port_;
      this->bd_addr_ = x.bd_addr_;
    }

    return *this;
  }

  CFG_param_network_information_Bluetooth::
  ~CFG_param_network_information_Bluetooth ()
  {
  }

  // CFG_param_network_information_TCP_IPv4
  //

  CFG_param_network_information_TCP_IPv4::
  CFG_param_network_information_TCP_IPv4 (const receiver_type& receiver,
                                          const param_id_type& param_id,
                                          const transport_protocol_type& transport_protocol,
                                          const ip_address_type& ip_address,
                                          const port_type& port)
  : ::xml_schema::type (),
    receiver_ (receiver, this),
    param_id_ (param_id, this),
    transport_protocol_ (transport_protocol, this),
    ip_address_ (ip_address, this),
    port_ (port, this)
  {
  }

  CFG_param_network_information_TCP_IPv4::
  CFG_param_network_information_TCP_IPv4 (const CFG_param_network_information_TCP_IPv4& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    receiver_ (x.receiver_, f, this),
    param_id_ (x.param_id_, f, this),
    transport_protocol_ (x.transport_protocol_, f, this),
    ip_address_ (x.ip_address_, f, this),
    port_ (x.port_, f, this)
  {
  }

  CFG_param_network_information_TCP_IPv4::
  CFG_param_network_information_TCP_IPv4 (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    receiver_ (this),
    param_id_ (this),
    transport_protocol_ (this),
    ip_address_ (this),
    port_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void CFG_param_network_information_TCP_IPv4::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "receiver" && n.namespace_ ().empty ())
      {
        this->receiver_.set (receiver_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "param_id" && n.namespace_ ().empty ())
      {
        this->param_id_.set (param_id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "transport_protocol" && n.namespace_ ().empty ())
      {
        this->transport_protocol_.set (transport_protocol_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ip_address" && n.namespace_ ().empty ())
      {
        this->ip_address_.set (ip_address_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "port" && n.namespace_ ().empty ())
      {
        this->port_.set (port_traits::create (i, f, this));
        continue;
      }
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "receiver",
        "");
    }

    if (!param_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "param_id",
        "");
    }

    if (!transport_protocol_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "transport_protocol",
        "");
    }

    if (!ip_address_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ip_address",
        "");
    }

    if (!port_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "port",
        "");
    }
  }

  CFG_param_network_information_TCP_IPv4* CFG_param_network_information_TCP_IPv4::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CFG_param_network_information_TCP_IPv4 (*this, f, c);
  }

  CFG_param_network_information_TCP_IPv4& CFG_param_network_information_TCP_IPv4::
  operator= (const CFG_param_network_information_TCP_IPv4& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->receiver_ = x.receiver_;
      this->param_id_ = x.param_id_;
      this->transport_protocol_ = x.transport_protocol_;
      this->ip_address_ = x.ip_address_;
      this->port_ = x.port_;
    }

    return *this;
  }

  CFG_param_network_information_TCP_IPv4::
  ~CFG_param_network_information_TCP_IPv4 ()
  {
  }

  // CFG_logging
  //

  CFG_logging::
  CFG_logging (const receiver_type& receiver,
               const log_category_type& log_category,
               const log_level_type& log_level,
               const log_mode_type& log_mode)
  : ::xml_schema::type (),
    receiver_ (receiver, this),
    log_category_ (log_category, this),
    log_level_ (log_level, this),
    log_mode_ (log_mode, this)
  {
  }

  CFG_logging::
  CFG_logging (const CFG_logging& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    receiver_ (x.receiver_, f, this),
    log_category_ (x.log_category_, f, this),
    log_level_ (x.log_level_, f, this),
    log_mode_ (x.log_mode_, f, this)
  {
  }

  CFG_logging::
  CFG_logging (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    receiver_ (this),
    log_category_ (this),
    log_level_ (this),
    log_mode_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void CFG_logging::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "receiver" && n.namespace_ ().empty ())
      {
        this->receiver_.set (receiver_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "log_category" && n.namespace_ ().empty ())
      {
        this->log_category_.set (log_category_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "log_level" && n.namespace_ ().empty ())
      {
        this->log_level_.set (log_level_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "log_mode" && n.namespace_ ().empty ())
      {
        this->log_mode_.set (log_mode_traits::create (i, f, this));
        continue;
      }
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "receiver",
        "");
    }

    if (!log_category_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "log_category",
        "");
    }

    if (!log_level_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "log_level",
        "");
    }

    if (!log_mode_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "log_mode",
        "");
    }
  }

  CFG_logging* CFG_logging::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CFG_logging (*this, f, c);
  }

  CFG_logging& CFG_logging::
  operator= (const CFG_logging& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->receiver_ = x.receiver_;
      this->log_category_ = x.log_category_;
      this->log_level_ = x.log_level_;
      this->log_mode_ = x.log_mode_;
    }

    return *this;
  }

  CFG_logging::
  ~CFG_logging ()
  {
  }

  // CFG_scope
  //

  CFG_scope::
  CFG_scope (const receiver_type& receiver,
             const data_id_type& data_id,
             const scope_type& scope)
  : ::xml_schema::type (),
    receiver_ (receiver, this),
    data_id_ (data_id, this),
    scope_ (scope, this)
  {
  }

  CFG_scope::
  CFG_scope (const CFG_scope& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    receiver_ (x.receiver_, f, this),
    data_id_ (x.data_id_, f, this),
    scope_ (x.scope_, f, this)
  {
  }

  CFG_scope::
  CFG_scope (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    receiver_ (this),
    data_id_ (this),
    scope_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void CFG_scope::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "receiver" && n.namespace_ ().empty ())
      {
        this->receiver_.set (receiver_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "data_id" && n.namespace_ ().empty ())
      {
        this->data_id_.set (data_id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "scope" && n.namespace_ ().empty ())
      {
        this->scope_.set (scope_traits::create (i, f, this));
        continue;
      }
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "receiver",
        "");
    }

    if (!data_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "data_id",
        "");
    }

    if (!scope_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "scope",
        "");
    }
  }

  CFG_scope* CFG_scope::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CFG_scope (*this, f, c);
  }

  CFG_scope& CFG_scope::
  operator= (const CFG_scope& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->receiver_ = x.receiver_;
      this->data_id_ = x.data_id_;
      this->scope_ = x.scope_;
    }

    return *this;
  }

  CFG_scope::
  ~CFG_scope ()
  {
  }

  // STC_register
  //

  STC_register::
  STC_register (const receiver_type& receiver,
                const state_id_type& state_id,
                const op_mode_type& op_mode,
                const major_version_type& major_version,
                const minor_version_type& minor_version)
  : ::xml_schema::type (),
    receiver_ (receiver, this),
    state_id_ (state_id, this),
    slave_uuid_ (this),
    op_mode_ (op_mode, this),
    major_version_ (major_version, this),
    minor_version_ (minor_version, this)
  {
  }

  STC_register::
  STC_register (const STC_register& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    receiver_ (x.receiver_, f, this),
    state_id_ (x.state_id_, f, this),
    slave_uuid_ (x.slave_uuid_, f, this),
    op_mode_ (x.op_mode_, f, this),
    major_version_ (x.major_version_, f, this),
    minor_version_ (x.minor_version_, f, this)
  {
  }

  STC_register::
  STC_register (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    receiver_ (this),
    state_id_ (this),
    slave_uuid_ (this),
    op_mode_ (this),
    major_version_ (this),
    minor_version_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void STC_register::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "receiver" && n.namespace_ ().empty ())
      {
        this->receiver_.set (receiver_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "state_id" && n.namespace_ ().empty ())
      {
        this->state_id_.set (state_id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "slave_uuid" && n.namespace_ ().empty ())
      {
        this->slave_uuid_.set (slave_uuid_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "op_mode" && n.namespace_ ().empty ())
      {
        this->op_mode_.set (op_mode_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "major_version" && n.namespace_ ().empty ())
      {
        this->major_version_.set (major_version_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "minor_version" && n.namespace_ ().empty ())
      {
        this->minor_version_.set (minor_version_traits::create (i, f, this));
        continue;
      }
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "receiver",
        "");
    }

    if (!state_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "state_id",
        "");
    }

    if (!op_mode_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "op_mode",
        "");
    }

    if (!major_version_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "major_version",
        "");
    }

    if (!minor_version_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "minor_version",
        "");
    }
  }

  STC_register* STC_register::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class STC_register (*this, f, c);
  }

  STC_register& STC_register::
  operator= (const STC_register& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->receiver_ = x.receiver_;
      this->state_id_ = x.state_id_;
      this->slave_uuid_ = x.slave_uuid_;
      this->op_mode_ = x.op_mode_;
      this->major_version_ = x.major_version_;
      this->minor_version_ = x.minor_version_;
    }

    return *this;
  }

  STC_register::
  ~STC_register ()
  {
  }

  // STC_deregister
  //

  STC_deregister::
  STC_deregister (const receiver_type& receiver,
                  const state_id_type& state_id)
  : ::xml_schema::type (),
    receiver_ (receiver, this),
    state_id_ (state_id, this)
  {
  }

  STC_deregister::
  STC_deregister (const STC_deregister& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    receiver_ (x.receiver_, f, this),
    state_id_ (x.state_id_, f, this)
  {
  }

  STC_deregister::
  STC_deregister (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    receiver_ (this),
    state_id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void STC_deregister::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "receiver" && n.namespace_ ().empty ())
      {
        this->receiver_.set (receiver_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "state_id" && n.namespace_ ().empty ())
      {
        this->state_id_.set (state_id_traits::create (i, f, this));
        continue;
      }
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "receiver",
        "");
    }

    if (!state_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "state_id",
        "");
    }
  }

  STC_deregister* STC_deregister::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class STC_deregister (*this, f, c);
  }

  STC_deregister& STC_deregister::
  operator= (const STC_deregister& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->receiver_ = x.receiver_;
      this->state_id_ = x.state_id_;
    }

    return *this;
  }

  STC_deregister::
  ~STC_deregister ()
  {
  }

  // STC_prepare
  //

  STC_prepare::
  STC_prepare (const receiver_type& receiver,
               const state_id_type& state_id)
  : ::xml_schema::type (),
    receiver_ (receiver, this),
    state_id_ (state_id, this)
  {
  }

  STC_prepare::
  STC_prepare (const STC_prepare& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    receiver_ (x.receiver_, f, this),
    state_id_ (x.state_id_, f, this)
  {
  }

  STC_prepare::
  STC_prepare (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    receiver_ (this),
    state_id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void STC_prepare::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "receiver" && n.namespace_ ().empty ())
      {
        this->receiver_.set (receiver_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "state_id" && n.namespace_ ().empty ())
      {
        this->state_id_.set (state_id_traits::create (i, f, this));
        continue;
      }
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "receiver",
        "");
    }

    if (!state_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "state_id",
        "");
    }
  }

  STC_prepare* STC_prepare::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class STC_prepare (*this, f, c);
  }

  STC_prepare& STC_prepare::
  operator= (const STC_prepare& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->receiver_ = x.receiver_;
      this->state_id_ = x.state_id_;
    }

    return *this;
  }

  STC_prepare::
  ~STC_prepare ()
  {
  }

  // STC_configure
  //

  STC_configure::
  STC_configure (const receiver_type& receiver,
                 const state_id_type& state_id)
  : ::xml_schema::type (),
    receiver_ (receiver, this),
    state_id_ (state_id, this)
  {
  }

  STC_configure::
  STC_configure (const STC_configure& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    receiver_ (x.receiver_, f, this),
    state_id_ (x.state_id_, f, this)
  {
  }

  STC_configure::
  STC_configure (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    receiver_ (this),
    state_id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void STC_configure::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "receiver" && n.namespace_ ().empty ())
      {
        this->receiver_.set (receiver_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "state_id" && n.namespace_ ().empty ())
      {
        this->state_id_.set (state_id_traits::create (i, f, this));
        continue;
      }
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "receiver",
        "");
    }

    if (!state_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "state_id",
        "");
    }
  }

  STC_configure* STC_configure::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class STC_configure (*this, f, c);
  }

  STC_configure& STC_configure::
  operator= (const STC_configure& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->receiver_ = x.receiver_;
      this->state_id_ = x.state_id_;
    }

    return *this;
  }

  STC_configure::
  ~STC_configure ()
  {
  }

  // STC_initialize
  //

  STC_initialize::
  STC_initialize (const receiver_type& receiver,
                  const state_id_type& state_id)
  : ::xml_schema::type (),
    receiver_ (receiver, this),
    state_id_ (state_id, this)
  {
  }

  STC_initialize::
  STC_initialize (const STC_initialize& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    receiver_ (x.receiver_, f, this),
    state_id_ (x.state_id_, f, this)
  {
  }

  STC_initialize::
  STC_initialize (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    receiver_ (this),
    state_id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void STC_initialize::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "receiver" && n.namespace_ ().empty ())
      {
        this->receiver_.set (receiver_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "state_id" && n.namespace_ ().empty ())
      {
        this->state_id_.set (state_id_traits::create (i, f, this));
        continue;
      }
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "receiver",
        "");
    }

    if (!state_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "state_id",
        "");
    }
  }

  STC_initialize* STC_initialize::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class STC_initialize (*this, f, c);
  }

  STC_initialize& STC_initialize::
  operator= (const STC_initialize& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->receiver_ = x.receiver_;
      this->state_id_ = x.state_id_;
    }

    return *this;
  }

  STC_initialize::
  ~STC_initialize ()
  {
  }

  // STC_run
  //

  STC_run::
  STC_run (const receiver_type& receiver,
           const state_id_type& state_id)
  : ::xml_schema::type (),
    receiver_ (receiver, this),
    state_id_ (state_id, this),
    start_time_ (this)
  {
  }

  STC_run::
  STC_run (const STC_run& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    receiver_ (x.receiver_, f, this),
    state_id_ (x.state_id_, f, this),
    start_time_ (x.start_time_, f, this)
  {
  }

  STC_run::
  STC_run (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    receiver_ (this),
    state_id_ (this),
    start_time_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void STC_run::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "receiver" && n.namespace_ ().empty ())
      {
        this->receiver_.set (receiver_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "state_id" && n.namespace_ ().empty ())
      {
        this->state_id_.set (state_id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "start_time" && n.namespace_ ().empty ())
      {
        this->start_time_.set (start_time_traits::create (i, f, this));
        continue;
      }
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "receiver",
        "");
    }

    if (!state_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "state_id",
        "");
    }
  }

  STC_run* STC_run::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class STC_run (*this, f, c);
  }

  STC_run& STC_run::
  operator= (const STC_run& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->receiver_ = x.receiver_;
      this->state_id_ = x.state_id_;
      this->start_time_ = x.start_time_;
    }

    return *this;
  }

  STC_run::
  ~STC_run ()
  {
  }

  // STC_do_step
  //

  STC_do_step::
  STC_do_step (const receiver_type& receiver,
               const state_id_type& state_id,
               const steps_type& steps)
  : ::xml_schema::type (),
    receiver_ (receiver, this),
    state_id_ (state_id, this),
    steps_ (steps, this)
  {
  }

  STC_do_step::
  STC_do_step (const STC_do_step& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    receiver_ (x.receiver_, f, this),
    state_id_ (x.state_id_, f, this),
    steps_ (x.steps_, f, this)
  {
  }

  STC_do_step::
  STC_do_step (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    receiver_ (this),
    state_id_ (this),
    steps_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void STC_do_step::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "receiver" && n.namespace_ ().empty ())
      {
        this->receiver_.set (receiver_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "state_id" && n.namespace_ ().empty ())
      {
        this->state_id_.set (state_id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "steps" && n.namespace_ ().empty ())
      {
        this->steps_.set (steps_traits::create (i, f, this));
        continue;
      }
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "receiver",
        "");
    }

    if (!state_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "state_id",
        "");
    }

    if (!steps_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "steps",
        "");
    }
  }

  STC_do_step* STC_do_step::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class STC_do_step (*this, f, c);
  }

  STC_do_step& STC_do_step::
  operator= (const STC_do_step& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->receiver_ = x.receiver_;
      this->state_id_ = x.state_id_;
      this->steps_ = x.steps_;
    }

    return *this;
  }

  STC_do_step::
  ~STC_do_step ()
  {
  }

  // STC_send_outputs
  //

  STC_send_outputs::
  STC_send_outputs (const receiver_type& receiver,
                    const state_id_type& state_id)
  : ::xml_schema::type (),
    receiver_ (receiver, this),
    state_id_ (state_id, this)
  {
  }

  STC_send_outputs::
  STC_send_outputs (const STC_send_outputs& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    receiver_ (x.receiver_, f, this),
    state_id_ (x.state_id_, f, this)
  {
  }

  STC_send_outputs::
  STC_send_outputs (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    receiver_ (this),
    state_id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void STC_send_outputs::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "receiver" && n.namespace_ ().empty ())
      {
        this->receiver_.set (receiver_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "state_id" && n.namespace_ ().empty ())
      {
        this->state_id_.set (state_id_traits::create (i, f, this));
        continue;
      }
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "receiver",
        "");
    }

    if (!state_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "state_id",
        "");
    }
  }

  STC_send_outputs* STC_send_outputs::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class STC_send_outputs (*this, f, c);
  }

  STC_send_outputs& STC_send_outputs::
  operator= (const STC_send_outputs& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->receiver_ = x.receiver_;
      this->state_id_ = x.state_id_;
    }

    return *this;
  }

  STC_send_outputs::
  ~STC_send_outputs ()
  {
  }

  // STC_stop
  //

  STC_stop::
  STC_stop (const receiver_type& receiver,
            const state_id_type& state_id)
  : ::xml_schema::type (),
    receiver_ (receiver, this),
    state_id_ (state_id, this)
  {
  }

  STC_stop::
  STC_stop (const STC_stop& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    receiver_ (x.receiver_, f, this),
    state_id_ (x.state_id_, f, this)
  {
  }

  STC_stop::
  STC_stop (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    receiver_ (this),
    state_id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void STC_stop::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "receiver" && n.namespace_ ().empty ())
      {
        this->receiver_.set (receiver_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "state_id" && n.namespace_ ().empty ())
      {
        this->state_id_.set (state_id_traits::create (i, f, this));
        continue;
      }
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "receiver",
        "");
    }

    if (!state_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "state_id",
        "");
    }
  }

  STC_stop* STC_stop::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class STC_stop (*this, f, c);
  }

  STC_stop& STC_stop::
  operator= (const STC_stop& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->receiver_ = x.receiver_;
      this->state_id_ = x.state_id_;
    }

    return *this;
  }

  STC_stop::
  ~STC_stop ()
  {
  }

  // STC_reset
  //

  STC_reset::
  STC_reset (const receiver_type& receiver,
             const state_id_type& state_id)
  : ::xml_schema::type (),
    receiver_ (receiver, this),
    state_id_ (state_id, this)
  {
  }

  STC_reset::
  STC_reset (const STC_reset& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    receiver_ (x.receiver_, f, this),
    state_id_ (x.state_id_, f, this)
  {
  }

  STC_reset::
  STC_reset (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    receiver_ (this),
    state_id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void STC_reset::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "receiver" && n.namespace_ ().empty ())
      {
        this->receiver_.set (receiver_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "state_id" && n.namespace_ ().empty ())
      {
        this->state_id_.set (state_id_traits::create (i, f, this));
        continue;
      }
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "receiver",
        "");
    }

    if (!state_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "state_id",
        "");
    }
  }

  STC_reset* STC_reset::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class STC_reset (*this, f, c);
  }

  STC_reset& STC_reset::
  operator= (const STC_reset& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->receiver_ = x.receiver_;
      this->state_id_ = x.state_id_;
    }

    return *this;
  }

  STC_reset::
  ~STC_reset ()
  {
  }

  // INF_state
  //

  INF_state::
  INF_state (const receiver_type& receiver)
  : ::xml_schema::type (),
    receiver_ (receiver, this)
  {
  }

  INF_state::
  INF_state (const INF_state& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    receiver_ (x.receiver_, f, this)
  {
  }

  INF_state::
  INF_state (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    receiver_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void INF_state::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "receiver" && n.namespace_ ().empty ())
      {
        this->receiver_.set (receiver_traits::create (i, f, this));
        continue;
      }
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "receiver",
        "");
    }
  }

  INF_state* INF_state::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class INF_state (*this, f, c);
  }

  INF_state& INF_state::
  operator= (const INF_state& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->receiver_ = x.receiver_;
    }

    return *this;
  }

  INF_state::
  ~INF_state ()
  {
  }

  // INF_error
  //

  INF_error::
  INF_error (const receiver_type& receiver)
  : ::xml_schema::type (),
    receiver_ (receiver, this)
  {
  }

  INF_error::
  INF_error (const INF_error& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    receiver_ (x.receiver_, f, this)
  {
  }

  INF_error::
  INF_error (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    receiver_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void INF_error::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "receiver" && n.namespace_ ().empty ())
      {
        this->receiver_.set (receiver_traits::create (i, f, this));
        continue;
      }
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "receiver",
        "");
    }
  }

  INF_error* INF_error::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class INF_error (*this, f, c);
  }

  INF_error& INF_error::
  operator= (const INF_error& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->receiver_ = x.receiver_;
    }

    return *this;
  }

  INF_error::
  ~INF_error ()
  {
  }

  // INF_log
  //

  INF_log::
  INF_log (const receiver_type& receiver,
           const log_category_type& log_category,
           const log_max_num_type& log_max_num)
  : ::xml_schema::type (),
    receiver_ (receiver, this),
    log_category_ (log_category, this),
    log_max_num_ (log_max_num, this)
  {
  }

  INF_log::
  INF_log (const INF_log& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    receiver_ (x.receiver_, f, this),
    log_category_ (x.log_category_, f, this),
    log_max_num_ (x.log_max_num_, f, this)
  {
  }

  INF_log::
  INF_log (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    receiver_ (this),
    log_category_ (this),
    log_max_num_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void INF_log::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "receiver" && n.namespace_ ().empty ())
      {
        this->receiver_.set (receiver_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "log_category" && n.namespace_ ().empty ())
      {
        this->log_category_.set (log_category_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "log_max_num" && n.namespace_ ().empty ())
      {
        this->log_max_num_.set (log_max_num_traits::create (i, f, this));
        continue;
      }
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "receiver",
        "");
    }

    if (!log_category_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "log_category",
        "");
    }

    if (!log_max_num_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "log_max_num",
        "");
    }
  }

  INF_log* INF_log::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class INF_log (*this, f, c);
  }

  INF_log& INF_log::
  operator= (const INF_log& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->receiver_ = x.receiver_;
      this->log_category_ = x.log_category_;
      this->log_max_num_ = x.log_max_num_;
    }

    return *this;
  }

  INF_log::
  ~INF_log ()
  {
  }

  // DAT_input_output2
  //

  DAT_input_output2::
  DAT_input_output2 (const data_id_type& data_id)
  : ::xml_schema::type (),
    SendingPayloadField_ (this),
    data_id_ (data_id, this)
  {
  }

  DAT_input_output2::
  DAT_input_output2 (const DAT_input_output2& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    SendingPayloadField_ (x.SendingPayloadField_, f, this),
    data_id_ (x.data_id_, f, this)
  {
  }

  DAT_input_output2::
  DAT_input_output2 (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    SendingPayloadField_ (this),
    data_id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void DAT_input_output2::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SendingPayloadField
      //
      if (n.name () == "SendingPayloadField" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< SendingPayloadField_type > r (
          SendingPayloadField_traits::create (i, f, this));

        this->SendingPayloadField_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "data_id" && n.namespace_ ().empty ())
      {
        this->data_id_.set (data_id_traits::create (i, f, this));
        continue;
      }
    }

    if (!data_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "data_id",
        "");
    }
  }

  DAT_input_output2* DAT_input_output2::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DAT_input_output2 (*this, f, c);
  }

  DAT_input_output2& DAT_input_output2::
  operator= (const DAT_input_output2& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->SendingPayloadField_ = x.SendingPayloadField_;
      this->data_id_ = x.data_id_;
    }

    return *this;
  }

  DAT_input_output2::
  ~DAT_input_output2 ()
  {
  }

  // DAT_parameter2
  //

  DAT_parameter2::
  DAT_parameter2 (const param_id_type& param_id)
  : ::xml_schema::type (),
    SendingPayloadField_ (this),
    param_id_ (param_id, this)
  {
  }

  DAT_parameter2::
  DAT_parameter2 (const DAT_parameter2& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    SendingPayloadField_ (x.SendingPayloadField_, f, this),
    param_id_ (x.param_id_, f, this)
  {
  }

  DAT_parameter2::
  DAT_parameter2 (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    SendingPayloadField_ (this),
    param_id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void DAT_parameter2::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SendingPayloadField
      //
      if (n.name () == "SendingPayloadField" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< SendingPayloadField_type > r (
          SendingPayloadField_traits::create (i, f, this));

        this->SendingPayloadField_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "param_id" && n.namespace_ ().empty ())
      {
        this->param_id_.set (param_id_traits::create (i, f, this));
        continue;
      }
    }

    if (!param_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "param_id",
        "");
    }
  }

  DAT_parameter2* DAT_parameter2::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DAT_parameter2 (*this, f, c);
  }

  DAT_parameter2& DAT_parameter2::
  operator= (const DAT_parameter2& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->SendingPayloadField_ = x.SendingPayloadField_;
      this->param_id_ = x.param_id_;
    }

    return *this;
  }

  DAT_parameter2::
  ~DAT_parameter2 ()
  {
  }

  // RSP_ack
  //

  RSP_ack::
  RSP_ack (const sender_type& sender)
  : ::xml_schema::type (),
    sender_ (sender, this)
  {
  }

  RSP_ack::
  RSP_ack (const RSP_ack& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    sender_ (x.sender_, f, this)
  {
  }

  RSP_ack::
  RSP_ack (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    sender_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void RSP_ack::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "sender" && n.namespace_ ().empty ())
      {
        this->sender_.set (sender_traits::create (i, f, this));
        continue;
      }
    }

    if (!sender_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "sender",
        "");
    }
  }

  RSP_ack* RSP_ack::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RSP_ack (*this, f, c);
  }

  RSP_ack& RSP_ack::
  operator= (const RSP_ack& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->sender_ = x.sender_;
    }

    return *this;
  }

  RSP_ack::
  ~RSP_ack ()
  {
  }

  // RSP_error_ack
  //

  RSP_error_ack::
  RSP_error_ack (const sender_type& sender,
                 const error_code_type& error_code)
  : ::xml_schema::type (),
    sender_ (sender, this),
    error_code_ (error_code, this)
  {
  }

  RSP_error_ack::
  RSP_error_ack (const RSP_error_ack& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    sender_ (x.sender_, f, this),
    error_code_ (x.error_code_, f, this)
  {
  }

  RSP_error_ack::
  RSP_error_ack (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    sender_ (this),
    error_code_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void RSP_error_ack::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "sender" && n.namespace_ ().empty ())
      {
        this->sender_.set (sender_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "error_code" && n.namespace_ ().empty ())
      {
        this->error_code_.set (error_code_traits::create (i, f, this));
        continue;
      }
    }

    if (!sender_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "sender",
        "");
    }

    if (!error_code_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "error_code",
        "");
    }
  }

  RSP_error_ack* RSP_error_ack::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RSP_error_ack (*this, f, c);
  }

  RSP_error_ack& RSP_error_ack::
  operator= (const RSP_error_ack& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->sender_ = x.sender_;
      this->error_code_ = x.error_code_;
    }

    return *this;
  }

  RSP_error_ack::
  ~RSP_error_ack ()
  {
  }

  // RSP_nack
  //

  RSP_nack::
  RSP_nack (const sender_type& sender,
            const error_code_type& error_code)
  : ::xml_schema::type (),
    sender_ (sender, this),
    error_code_ (error_code, this),
    exp_pdu_seq_id_ (this)
  {
  }

  RSP_nack::
  RSP_nack (const RSP_nack& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    sender_ (x.sender_, f, this),
    error_code_ (x.error_code_, f, this),
    exp_pdu_seq_id_ (x.exp_pdu_seq_id_, f, this)
  {
  }

  RSP_nack::
  RSP_nack (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    sender_ (this),
    error_code_ (this),
    exp_pdu_seq_id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void RSP_nack::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "sender" && n.namespace_ ().empty ())
      {
        this->sender_.set (sender_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "error_code" && n.namespace_ ().empty ())
      {
        this->error_code_.set (error_code_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "exp_pdu_seq_id" && n.namespace_ ().empty ())
      {
        this->exp_pdu_seq_id_.set (exp_pdu_seq_id_traits::create (i, f, this));
        continue;
      }
    }

    if (!sender_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "sender",
        "");
    }

    if (!error_code_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "error_code",
        "");
    }
  }

  RSP_nack* RSP_nack::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RSP_nack (*this, f, c);
  }

  RSP_nack& RSP_nack::
  operator= (const RSP_nack& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->sender_ = x.sender_;
      this->error_code_ = x.error_code_;
      this->exp_pdu_seq_id_ = x.exp_pdu_seq_id_;
    }

    return *this;
  }

  RSP_nack::
  ~RSP_nack ()
  {
  }

  // RSP_state_ack
  //

  RSP_state_ack::
  RSP_state_ack (const sender_type& sender,
                 const state_id_type& state_id)
  : ::xml_schema::type (),
    sender_ (sender, this),
    state_id_ (state_id, this)
  {
  }

  RSP_state_ack::
  RSP_state_ack (const RSP_state_ack& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    sender_ (x.sender_, f, this),
    state_id_ (x.state_id_, f, this)
  {
  }

  RSP_state_ack::
  RSP_state_ack (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    sender_ (this),
    state_id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void RSP_state_ack::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "sender" && n.namespace_ ().empty ())
      {
        this->sender_.set (sender_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "state_id" && n.namespace_ ().empty ())
      {
        this->state_id_.set (state_id_traits::create (i, f, this));
        continue;
      }
    }

    if (!sender_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "sender",
        "");
    }

    if (!state_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "state_id",
        "");
    }
  }

  RSP_state_ack* RSP_state_ack::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RSP_state_ack (*this, f, c);
  }

  RSP_state_ack& RSP_state_ack::
  operator= (const RSP_state_ack& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->sender_ = x.sender_;
      this->state_id_ = x.state_id_;
    }

    return *this;
  }

  RSP_state_ack::
  ~RSP_state_ack ()
  {
  }

  // NTF_state_changed
  //

  NTF_state_changed::
  NTF_state_changed (const sender_type& sender,
                     const state_id_type& state_id)
  : ::xml_schema::type (),
    sender_ (sender, this),
    state_id_ (state_id, this)
  {
  }

  NTF_state_changed::
  NTF_state_changed (const NTF_state_changed& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    sender_ (x.sender_, f, this),
    state_id_ (x.state_id_, f, this)
  {
  }

  NTF_state_changed::
  NTF_state_changed (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    sender_ (this),
    state_id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void NTF_state_changed::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "sender" && n.namespace_ ().empty ())
      {
        this->sender_.set (sender_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "state_id" && n.namespace_ ().empty ())
      {
        this->state_id_.set (state_id_traits::create (i, f, this));
        continue;
      }
    }

    if (!sender_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "sender",
        "");
    }

    if (!state_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "state_id",
        "");
    }
  }

  NTF_state_changed* NTF_state_changed::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class NTF_state_changed (*this, f, c);
  }

  NTF_state_changed& NTF_state_changed::
  operator= (const NTF_state_changed& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->sender_ = x.sender_;
      this->state_id_ = x.state_id_;
    }

    return *this;
  }

  NTF_state_changed::
  ~NTF_state_changed ()
  {
  }

  // RSP_log_ack
  //

  RSP_log_ack::
  RSP_log_ack (const sender_type& sender,
               const length_type& length)
  : ::xml_schema::type (),
    sender_ (sender, this),
    length_ (length, this)
  {
  }

  RSP_log_ack::
  RSP_log_ack (const RSP_log_ack& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    sender_ (x.sender_, f, this),
    length_ (x.length_, f, this)
  {
  }

  RSP_log_ack::
  RSP_log_ack (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    sender_ (this),
    length_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void RSP_log_ack::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "sender" && n.namespace_ ().empty ())
      {
        this->sender_.set (sender_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "length" && n.namespace_ ().empty ())
      {
        this->length_.set (length_traits::create (i, f, this));
        continue;
      }
    }

    if (!sender_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "sender",
        "");
    }

    if (!length_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "length",
        "");
    }
  }

  RSP_log_ack* RSP_log_ack::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RSP_log_ack (*this, f, c);
  }

  RSP_log_ack& RSP_log_ack::
  operator= (const RSP_log_ack& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->sender_ = x.sender_;
      this->length_ = x.length_;
    }

    return *this;
  }

  RSP_log_ack::
  ~RSP_log_ack ()
  {
  }

  // NTF_log
  //

  NTF_log::
  NTF_log (const sender_type& sender,
           const length_type& length)
  : ::xml_schema::type (),
    sender_ (sender, this),
    length_ (length, this)
  {
  }

  NTF_log::
  NTF_log (const NTF_log& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    sender_ (x.sender_, f, this),
    length_ (x.length_, f, this)
  {
  }

  NTF_log::
  NTF_log (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    sender_ (this),
    length_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void NTF_log::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "sender" && n.namespace_ ().empty ())
      {
        this->sender_.set (sender_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "length" && n.namespace_ ().empty ())
      {
        this->length_.set (length_traits::create (i, f, this));
        continue;
      }
    }

    if (!sender_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "sender",
        "");
    }

    if (!length_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "length",
        "");
    }
  }

  NTF_log* NTF_log::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class NTF_log (*this, f, c);
  }

  NTF_log& NTF_log::
  operator= (const NTF_log& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->sender_ = x.sender_;
      this->length_ = x.length_;
    }

    return *this;
  }

  NTF_log::
  ~NTF_log ()
  {
  }

  // DAT_input_output3
  //

  DAT_input_output3::
  DAT_input_output3 (const data_id_type& data_id)
  : ::xml_schema::type (),
    ReceivingPayloadField_ (this),
    data_id_ (data_id, this)
  {
  }

  DAT_input_output3::
  DAT_input_output3 (const DAT_input_output3& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ReceivingPayloadField_ (x.ReceivingPayloadField_, f, this),
    data_id_ (x.data_id_, f, this)
  {
  }

  DAT_input_output3::
  DAT_input_output3 (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ReceivingPayloadField_ (this),
    data_id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void DAT_input_output3::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ReceivingPayloadField
      //
      if (n.name () == "ReceivingPayloadField" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ReceivingPayloadField_type > r (
          ReceivingPayloadField_traits::create (i, f, this));

        this->ReceivingPayloadField_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "data_id" && n.namespace_ ().empty ())
      {
        this->data_id_.set (data_id_traits::create (i, f, this));
        continue;
      }
    }

    if (!data_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "data_id",
        "");
    }
  }

  DAT_input_output3* DAT_input_output3::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DAT_input_output3 (*this, f, c);
  }

  DAT_input_output3& DAT_input_output3::
  operator= (const DAT_input_output3& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->ReceivingPayloadField_ = x.ReceivingPayloadField_;
      this->data_id_ = x.data_id_;
    }

    return *this;
  }

  DAT_input_output3::
  ~DAT_input_output3 ()
  {
  }

  // DAT_parameter3
  //

  DAT_parameter3::
  DAT_parameter3 (const param_id_type& param_id)
  : ::xml_schema::type (),
    ReceivingPayloadField_ (this),
    param_id_ (param_id, this)
  {
  }

  DAT_parameter3::
  DAT_parameter3 (const DAT_parameter3& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ReceivingPayloadField_ (x.ReceivingPayloadField_, f, this),
    param_id_ (x.param_id_, f, this)
  {
  }

  DAT_parameter3::
  DAT_parameter3 (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ReceivingPayloadField_ (this),
    param_id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void DAT_parameter3::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ReceivingPayloadField
      //
      if (n.name () == "ReceivingPayloadField" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ReceivingPayloadField_type > r (
          ReceivingPayloadField_traits::create (i, f, this));

        this->ReceivingPayloadField_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "param_id" && n.namespace_ ().empty ())
      {
        this->param_id_.set (param_id_traits::create (i, f, this));
        continue;
      }
    }

    if (!param_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "param_id",
        "");
    }
  }

  DAT_parameter3* DAT_parameter3::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DAT_parameter3 (*this, f, c);
  }

  DAT_parameter3& DAT_parameter3::
  operator= (const DAT_parameter3& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->ReceivingPayloadField_ = x.ReceivingPayloadField_;
      this->param_id_ = x.param_id_;
    }

    return *this;
  }

  DAT_parameter3::
  ~DAT_parameter3 ()
  {
  }

  // AvailablePortRange
  //

  AvailablePortRange::
  AvailablePortRange (const from_type& from,
                      const to_type& to)
  : ::xml_schema::type (),
    from_ (from, this),
    to_ (to, this)
  {
  }

  AvailablePortRange::
  AvailablePortRange (const AvailablePortRange& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    from_ (x.from_, f, this),
    to_ (x.to_, f, this)
  {
  }

  AvailablePortRange::
  AvailablePortRange (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    from_ (this),
    to_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void AvailablePortRange::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "from" && n.namespace_ ().empty ())
      {
        this->from_.set (from_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "to" && n.namespace_ ().empty ())
      {
        this->to_.set (to_traits::create (i, f, this));
        continue;
      }
    }

    if (!from_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "from",
        "");
    }

    if (!to_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "to",
        "");
    }
  }

  AvailablePortRange* AvailablePortRange::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AvailablePortRange (*this, f, c);
  }

  AvailablePortRange& AvailablePortRange::
  operator= (const AvailablePortRange& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->from_ = x.from_;
      this->to_ = x.to_;
    }

    return *this;
  }

  AvailablePortRange::
  ~AvailablePortRange ()
  {
  }

  // AvailablePort
  //

  AvailablePort::
  AvailablePort (const port_type& port)
  : ::xml_schema::type (),
    port_ (port, this)
  {
  }

  AvailablePort::
  AvailablePort (const AvailablePort& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    port_ (x.port_, f, this)
  {
  }

  AvailablePort::
  AvailablePort (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    port_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void AvailablePort::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "port" && n.namespace_ ().empty ())
      {
        this->port_.set (port_traits::create (i, f, this));
        continue;
      }
    }

    if (!port_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "port",
        "");
    }
  }

  AvailablePort* AvailablePort::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AvailablePort (*this, f, c);
  }

  AvailablePort& AvailablePort::
  operator= (const AvailablePort& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->port_ = x.port_;
    }

    return *this;
  }

  AvailablePort::
  ~AvailablePort ()
  {
  }

  // direction
  //

  direction::
  direction (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_direction_convert ();
  }

  direction::
  direction (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_direction_convert ();
  }

  direction::
  direction (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_direction_convert ();
  }

  direction* direction::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class direction (*this, f, c);
  }

  direction::value direction::
  _xsd_direction_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_direction_literals_);
    const value* i (::std::lower_bound (
                      _xsd_direction_indexes_,
                      _xsd_direction_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_direction_indexes_ + 2 || _xsd_direction_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const direction::
  _xsd_direction_literals_[2] =
  {
    "In",
    "Out"
  };

  const direction::value direction::
  _xsd_direction_indexes_[2] =
  {
    ::DcpTestSuite::direction::In,
    ::DcpTestSuite::direction::Out
  };

  // bd_addr
  //

  bd_addr::
  bd_addr ()
  : ::xml_schema::string ()
  {
  }

  bd_addr::
  bd_addr (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  bd_addr::
  bd_addr (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  bd_addr::
  bd_addr (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  bd_addr::
  bd_addr (const bd_addr& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  bd_addr::
  bd_addr (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  bd_addr::
  bd_addr (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  bd_addr::
  bd_addr (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  bd_addr* bd_addr::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class bd_addr (*this, f, c);
  }

  bd_addr::
  ~bd_addr ()
  {
  }

  // port
  //

  port::
  port (const ::xml_schema::unsigned_byte& _xsd_unsigned_byte_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_byte, char, ::xml_schema::simple_type > (_xsd_unsigned_byte_base)
  {
  }

  port::
  port (const port& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_byte, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  port::
  port (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_byte, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  port::
  port (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_byte, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  port::
  port (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_byte, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  port* port::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class port (*this, f, c);
  }

  port::
  ~port ()
  {
  }

  // slave_uuid
  //

  slave_uuid::
  slave_uuid ()
  : ::xml_schema::string ()
  {
  }

  slave_uuid::
  slave_uuid (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  slave_uuid::
  slave_uuid (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  slave_uuid::
  slave_uuid (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  slave_uuid::
  slave_uuid (const slave_uuid& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  slave_uuid::
  slave_uuid (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  slave_uuid::
  slave_uuid (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  slave_uuid::
  slave_uuid (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  slave_uuid* slave_uuid::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class slave_uuid (*this, f, c);
  }

  slave_uuid::
  ~slave_uuid ()
  {
  }

  // Payload
  //

  Payload::
  Payload ()
  : ::xml_schema::type (),
    Int8_ (this),
    Int16_ (this),
    Int32_ (this),
    Int64_ (this),
    Uint8_ (this),
    Uint16_ (this),
    Uint32_ (this),
    Uint64_ (this),
    Float32_ (this),
    Float64_ (this),
    String_ (this),
    Binary_ (this)
  {
  }

  Payload::
  Payload (const Payload& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Int8_ (x.Int8_, f, this),
    Int16_ (x.Int16_, f, this),
    Int32_ (x.Int32_, f, this),
    Int64_ (x.Int64_, f, this),
    Uint8_ (x.Uint8_, f, this),
    Uint16_ (x.Uint16_, f, this),
    Uint32_ (x.Uint32_, f, this),
    Uint64_ (x.Uint64_, f, this),
    Float32_ (x.Float32_, f, this),
    Float64_ (x.Float64_, f, this),
    String_ (x.String_, f, this),
    Binary_ (x.Binary_, f, this)
  {
  }

  Payload::
  Payload (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Int8_ (this),
    Int16_ (this),
    Int32_ (this),
    Int64_ (this),
    Uint8_ (this),
    Uint16_ (this),
    Uint32_ (this),
    Uint64_ (this),
    Float32_ (this),
    Float64_ (this),
    String_ (this),
    Binary_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Payload::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Int8
      //
      if (n.name () == "Int8" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Int8_type > r (
          Int8_traits::create (i, f, this));

        if (!this->Int8_)
        {
          this->Int8_.set (r);
          continue;
        }
      }

      // Int16
      //
      if (n.name () == "Int16" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Int16_type > r (
          Int16_traits::create (i, f, this));

        if (!this->Int16_)
        {
          this->Int16_.set (r);
          continue;
        }
      }

      // Int32
      //
      if (n.name () == "Int32" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Int32_type > r (
          Int32_traits::create (i, f, this));

        if (!this->Int32_)
        {
          this->Int32_.set (r);
          continue;
        }
      }

      // Int64
      //
      if (n.name () == "Int64" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Int64_type > r (
          Int64_traits::create (i, f, this));

        if (!this->Int64_)
        {
          this->Int64_.set (r);
          continue;
        }
      }

      // Uint8
      //
      if (n.name () == "Uint8" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Uint8_type > r (
          Uint8_traits::create (i, f, this));

        if (!this->Uint8_)
        {
          this->Uint8_.set (r);
          continue;
        }
      }

      // Uint16
      //
      if (n.name () == "Uint16" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Uint16_type > r (
          Uint16_traits::create (i, f, this));

        if (!this->Uint16_)
        {
          this->Uint16_.set (r);
          continue;
        }
      }

      // Uint32
      //
      if (n.name () == "Uint32" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Uint32_type > r (
          Uint32_traits::create (i, f, this));

        if (!this->Uint32_)
        {
          this->Uint32_.set (r);
          continue;
        }
      }

      // Uint64
      //
      if (n.name () == "Uint64" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Uint64_type > r (
          Uint64_traits::create (i, f, this));

        if (!this->Uint64_)
        {
          this->Uint64_.set (r);
          continue;
        }
      }

      // Float32
      //
      if (n.name () == "Float32" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Float32_type > r (
          Float32_traits::create (i, f, this));

        if (!this->Float32_)
        {
          this->Float32_.set (r);
          continue;
        }
      }

      // Float64
      //
      if (n.name () == "Float64" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Float64_type > r (
          Float64_traits::create (i, f, this));

        if (!this->Float64_)
        {
          this->Float64_.set (r);
          continue;
        }
      }

      // String
      //
      if (n.name () == "String" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< String_type > r (
          String_traits::create (i, f, this));

        if (!this->String_)
        {
          this->String_.set (r);
          continue;
        }
      }

      // Binary
      //
      if (n.name () == "Binary" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Binary_type > r (
          Binary_traits::create (i, f, this));

        if (!this->Binary_)
        {
          this->Binary_.set (r);
          continue;
        }
      }

      break;
    }
  }

  Payload* Payload::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Payload (*this, f, c);
  }

  Payload& Payload::
  operator= (const Payload& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Int8_ = x.Int8_;
      this->Int16_ = x.Int16_;
      this->Int32_ = x.Int32_;
      this->Int64_ = x.Int64_;
      this->Uint8_ = x.Uint8_;
      this->Uint16_ = x.Uint16_;
      this->Uint32_ = x.Uint32_;
      this->Uint64_ = x.Uint64_;
      this->Float32_ = x.Float32_;
      this->Float64_ = x.Float64_;
      this->String_ = x.String_;
      this->Binary_ = x.Binary_;
    }

    return *this;
  }

  Payload::
  ~Payload ()
  {
  }

  // Int82
  //

  Int82::
  Int82 (const value_type& value)
  : ::xml_schema::type (),
    value_ (value, this)
  {
  }

  Int82::
  Int82 (const Int82& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    value_ (x.value_, f, this)
  {
  }

  Int82::
  Int82 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    value_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Int82::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  Int82* Int82::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Int82 (*this, f, c);
  }

  Int82& Int82::
  operator= (const Int82& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->value_ = x.value_;
    }

    return *this;
  }

  Int82::
  ~Int82 ()
  {
  }

  // Int162
  //

  Int162::
  Int162 (const value_type& value)
  : ::xml_schema::type (),
    value_ (value, this)
  {
  }

  Int162::
  Int162 (const Int162& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    value_ (x.value_, f, this)
  {
  }

  Int162::
  Int162 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    value_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Int162::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  Int162* Int162::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Int162 (*this, f, c);
  }

  Int162& Int162::
  operator= (const Int162& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->value_ = x.value_;
    }

    return *this;
  }

  Int162::
  ~Int162 ()
  {
  }

  // Int322
  //

  Int322::
  Int322 (const value_type& value)
  : ::xml_schema::type (),
    value_ (value, this)
  {
  }

  Int322::
  Int322 (const Int322& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    value_ (x.value_, f, this)
  {
  }

  Int322::
  Int322 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    value_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Int322::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  Int322* Int322::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Int322 (*this, f, c);
  }

  Int322& Int322::
  operator= (const Int322& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->value_ = x.value_;
    }

    return *this;
  }

  Int322::
  ~Int322 ()
  {
  }

  // Int642
  //

  Int642::
  Int642 (const value_type& value)
  : ::xml_schema::type (),
    value_ (value, this)
  {
  }

  Int642::
  Int642 (const Int642& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    value_ (x.value_, f, this)
  {
  }

  Int642::
  Int642 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    value_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Int642::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  Int642* Int642::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Int642 (*this, f, c);
  }

  Int642& Int642::
  operator= (const Int642& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->value_ = x.value_;
    }

    return *this;
  }

  Int642::
  ~Int642 ()
  {
  }

  // Uint82
  //

  Uint82::
  Uint82 (const value_type& value)
  : ::xml_schema::type (),
    value_ (value, this)
  {
  }

  Uint82::
  Uint82 (const Uint82& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    value_ (x.value_, f, this)
  {
  }

  Uint82::
  Uint82 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    value_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Uint82::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  Uint82* Uint82::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Uint82 (*this, f, c);
  }

  Uint82& Uint82::
  operator= (const Uint82& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->value_ = x.value_;
    }

    return *this;
  }

  Uint82::
  ~Uint82 ()
  {
  }

  // Uint162
  //

  Uint162::
  Uint162 (const value_type& value)
  : ::xml_schema::type (),
    value_ (value, this)
  {
  }

  Uint162::
  Uint162 (const Uint162& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    value_ (x.value_, f, this)
  {
  }

  Uint162::
  Uint162 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    value_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Uint162::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  Uint162* Uint162::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Uint162 (*this, f, c);
  }

  Uint162& Uint162::
  operator= (const Uint162& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->value_ = x.value_;
    }

    return *this;
  }

  Uint162::
  ~Uint162 ()
  {
  }

  // Uint322
  //

  Uint322::
  Uint322 (const value_type& value)
  : ::xml_schema::type (),
    value_ (value, this)
  {
  }

  Uint322::
  Uint322 (const Uint322& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    value_ (x.value_, f, this)
  {
  }

  Uint322::
  Uint322 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    value_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Uint322::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  Uint322* Uint322::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Uint322 (*this, f, c);
  }

  Uint322& Uint322::
  operator= (const Uint322& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->value_ = x.value_;
    }

    return *this;
  }

  Uint322::
  ~Uint322 ()
  {
  }

  // Uint642
  //

  Uint642::
  Uint642 (const value_type& value)
  : ::xml_schema::type (),
    value_ (value, this)
  {
  }

  Uint642::
  Uint642 (const Uint642& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    value_ (x.value_, f, this)
  {
  }

  Uint642::
  Uint642 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    value_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Uint642::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  Uint642* Uint642::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Uint642 (*this, f, c);
  }

  Uint642& Uint642::
  operator= (const Uint642& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->value_ = x.value_;
    }

    return *this;
  }

  Uint642::
  ~Uint642 ()
  {
  }

  // Float322
  //

  Float322::
  Float322 (const value_type& value)
  : ::xml_schema::type (),
    value_ (value, this)
  {
  }

  Float322::
  Float322 (const Float322& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    value_ (x.value_, f, this)
  {
  }

  Float322::
  Float322 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    value_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Float322::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  Float322* Float322::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Float322 (*this, f, c);
  }

  Float322& Float322::
  operator= (const Float322& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->value_ = x.value_;
    }

    return *this;
  }

  Float322::
  ~Float322 ()
  {
  }

  // Float642
  //

  Float642::
  Float642 (const value_type& value)
  : ::xml_schema::type (),
    value_ (value, this)
  {
  }

  Float642::
  Float642 (const Float642& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    value_ (x.value_, f, this)
  {
  }

  Float642::
  Float642 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    value_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Float642::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  Float642* Float642::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Float642 (*this, f, c);
  }

  Float642& Float642::
  operator= (const Float642& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->value_ = x.value_;
    }

    return *this;
  }

  Float642::
  ~Float642 ()
  {
  }

  // value20
  //

  value20::
  value20 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::byte, char > (e, f, this)
  {
  }

  value20::
  value20 (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::byte, char > (a, f, this)
  {
  }

  value20::
  value20 (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::byte, char > (s, e, f, this)
  {
  }

  value20* value20::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class value20 (*this, f, c);
  }

  value20::
  ~value20 ()
  {
  }

  // value21
  //

  value21::
  value21 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::short_, char > (e, f, this)
  {
  }

  value21::
  value21 (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::short_, char > (a, f, this)
  {
  }

  value21::
  value21 (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::short_, char > (s, e, f, this)
  {
  }

  value21* value21::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class value21 (*this, f, c);
  }

  value21::
  ~value21 ()
  {
  }

  // value22
  //

  value22::
  value22 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::int_, char > (e, f, this)
  {
  }

  value22::
  value22 (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::int_, char > (a, f, this)
  {
  }

  value22::
  value22 (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::int_, char > (s, e, f, this)
  {
  }

  value22* value22::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class value22 (*this, f, c);
  }

  value22::
  ~value22 ()
  {
  }

  // value23
  //

  value23::
  value23 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::long_, char > (e, f, this)
  {
  }

  value23::
  value23 (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::long_, char > (a, f, this)
  {
  }

  value23::
  value23 (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::long_, char > (s, e, f, this)
  {
  }

  value23* value23::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class value23 (*this, f, c);
  }

  value23::
  ~value23 ()
  {
  }

  // value24
  //

  value24::
  value24 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_byte, char > (e, f, this)
  {
  }

  value24::
  value24 (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_byte, char > (a, f, this)
  {
  }

  value24::
  value24 (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_byte, char > (s, e, f, this)
  {
  }

  value24* value24::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class value24 (*this, f, c);
  }

  value24::
  ~value24 ()
  {
  }

  // value25
  //

  value25::
  value25 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_short, char > (e, f, this)
  {
  }

  value25::
  value25 (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_short, char > (a, f, this)
  {
  }

  value25::
  value25 (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_short, char > (s, e, f, this)
  {
  }

  value25* value25::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class value25 (*this, f, c);
  }

  value25::
  ~value25 ()
  {
  }

  // value26
  //

  value26::
  value26 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char > (e, f, this)
  {
  }

  value26::
  value26 (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char > (a, f, this)
  {
  }

  value26::
  value26 (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_int, char > (s, e, f, this)
  {
  }

  value26* value26::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class value26 (*this, f, c);
  }

  value26::
  ~value26 ()
  {
  }

  // value27
  //

  value27::
  value27 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_long, char > (e, f, this)
  {
  }

  value27::
  value27 (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_long, char > (a, f, this)
  {
  }

  value27::
  value27 (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::unsigned_long, char > (s, e, f, this)
  {
  }

  value27* value27::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class value27 (*this, f, c);
  }

  value27::
  ~value27 ()
  {
  }

  // value28
  //

  value28::
  value28 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::float_, char > (e, f, this)
  {
  }

  value28::
  value28 (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::float_, char > (a, f, this)
  {
  }

  value28::
  value28 (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::float_, char > (s, e, f, this)
  {
  }

  value28* value28::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class value28 (*this, f, c);
  }

  value28::
  ~value28 ()
  {
  }

  // value29
  //

  value29::
  value29 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (e, f, this)
  {
  }

  value29::
  value29 (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (a, f, this)
  {
  }

  value29::
  value29 (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, this)
  {
  }

  value29* value29::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class value29 (*this, f, c);
  }

  value29::
  ~value29 ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace DcpTestSuite
{
  ::std::auto_ptr< ::DcpTestSuite::DcpTestProcedure >
  DcpTestProcedure_ (const ::std::string& u,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::DcpTestSuite::DcpTestProcedure > (
      ::DcpTestSuite::DcpTestProcedure_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::DcpTestSuite::DcpTestProcedure >
  DcpTestProcedure_ (const ::std::string& u,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::DcpTestSuite::DcpTestProcedure > (
      ::DcpTestSuite::DcpTestProcedure_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::DcpTestSuite::DcpTestProcedure >
  DcpTestProcedure_ (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::DcpTestSuite::DcpTestProcedure > (
      ::DcpTestSuite::DcpTestProcedure_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::DcpTestSuite::DcpTestProcedure >
  DcpTestProcedure_ (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::DcpTestSuite::DcpTestProcedure_ (isrc, f, p);
  }

  ::std::auto_ptr< ::DcpTestSuite::DcpTestProcedure >
  DcpTestProcedure_ (::std::istream& is,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::DcpTestSuite::DcpTestProcedure_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::DcpTestSuite::DcpTestProcedure >
  DcpTestProcedure_ (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::DcpTestSuite::DcpTestProcedure_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::DcpTestSuite::DcpTestProcedure >
  DcpTestProcedure_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::DcpTestSuite::DcpTestProcedure_ (isrc, f, p);
  }

  ::std::auto_ptr< ::DcpTestSuite::DcpTestProcedure >
  DcpTestProcedure_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::DcpTestSuite::DcpTestProcedure_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::DcpTestSuite::DcpTestProcedure >
  DcpTestProcedure_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::DcpTestSuite::DcpTestProcedure_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::DcpTestSuite::DcpTestProcedure >
  DcpTestProcedure_ (::xercesc::InputSource& i,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::DcpTestSuite::DcpTestProcedure > (
      ::DcpTestSuite::DcpTestProcedure_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::DcpTestSuite::DcpTestProcedure >
  DcpTestProcedure_ (::xercesc::InputSource& i,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::DcpTestSuite::DcpTestProcedure > (
      ::DcpTestSuite::DcpTestProcedure_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::DcpTestSuite::DcpTestProcedure >
  DcpTestProcedure_ (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::DcpTestSuite::DcpTestProcedure > (
      ::DcpTestSuite::DcpTestProcedure_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::DcpTestSuite::DcpTestProcedure >
  DcpTestProcedure_ (const ::xercesc::DOMDocument& doc,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::DcpTestSuite::DcpTestProcedure > (
        ::DcpTestSuite::DcpTestProcedure_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "DcpTestProcedure" &&
        n.namespace_ () == "")
    {
      ::std::auto_ptr< ::DcpTestSuite::DcpTestProcedure > r (
        ::xsd::cxx::tree::traits< ::DcpTestSuite::DcpTestProcedure, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DcpTestProcedure",
      "");
  }

  ::std::auto_ptr< ::DcpTestSuite::DcpTestProcedure >
  DcpTestProcedure_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "DcpTestProcedure" &&
        n.namespace_ () == "")
    {
      ::std::auto_ptr< ::DcpTestSuite::DcpTestProcedure > r (
        ::xsd::cxx::tree::traits< ::DcpTestSuite::DcpTestProcedure, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DcpTestProcedure",
      "");
  }

  ::std::auto_ptr< ::DcpTestSuite::SendingPayloadField >
  SendingPayloadField_ (const ::std::string& u,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::DcpTestSuite::SendingPayloadField > (
      ::DcpTestSuite::SendingPayloadField_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::DcpTestSuite::SendingPayloadField >
  SendingPayloadField_ (const ::std::string& u,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::DcpTestSuite::SendingPayloadField > (
      ::DcpTestSuite::SendingPayloadField_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::DcpTestSuite::SendingPayloadField >
  SendingPayloadField_ (const ::std::string& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::DcpTestSuite::SendingPayloadField > (
      ::DcpTestSuite::SendingPayloadField_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::DcpTestSuite::SendingPayloadField >
  SendingPayloadField_ (::std::istream& is,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::DcpTestSuite::SendingPayloadField_ (isrc, f, p);
  }

  ::std::auto_ptr< ::DcpTestSuite::SendingPayloadField >
  SendingPayloadField_ (::std::istream& is,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::DcpTestSuite::SendingPayloadField_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::DcpTestSuite::SendingPayloadField >
  SendingPayloadField_ (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::DcpTestSuite::SendingPayloadField_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::DcpTestSuite::SendingPayloadField >
  SendingPayloadField_ (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::DcpTestSuite::SendingPayloadField_ (isrc, f, p);
  }

  ::std::auto_ptr< ::DcpTestSuite::SendingPayloadField >
  SendingPayloadField_ (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::DcpTestSuite::SendingPayloadField_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::DcpTestSuite::SendingPayloadField >
  SendingPayloadField_ (::std::istream& is,
                        const ::std::string& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::DcpTestSuite::SendingPayloadField_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::DcpTestSuite::SendingPayloadField >
  SendingPayloadField_ (::xercesc::InputSource& i,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::DcpTestSuite::SendingPayloadField > (
      ::DcpTestSuite::SendingPayloadField_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::DcpTestSuite::SendingPayloadField >
  SendingPayloadField_ (::xercesc::InputSource& i,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::DcpTestSuite::SendingPayloadField > (
      ::DcpTestSuite::SendingPayloadField_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::DcpTestSuite::SendingPayloadField >
  SendingPayloadField_ (::xercesc::InputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::DcpTestSuite::SendingPayloadField > (
      ::DcpTestSuite::SendingPayloadField_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::DcpTestSuite::SendingPayloadField >
  SendingPayloadField_ (const ::xercesc::DOMDocument& doc,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::DcpTestSuite::SendingPayloadField > (
        ::DcpTestSuite::SendingPayloadField_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "SendingPayloadField" &&
        n.namespace_ () == "")
    {
      ::std::auto_ptr< ::DcpTestSuite::SendingPayloadField > r (
        ::xsd::cxx::tree::traits< ::DcpTestSuite::SendingPayloadField, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SendingPayloadField",
      "");
  }

  ::std::auto_ptr< ::DcpTestSuite::SendingPayloadField >
  SendingPayloadField_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "SendingPayloadField" &&
        n.namespace_ () == "")
    {
      ::std::auto_ptr< ::DcpTestSuite::SendingPayloadField > r (
        ::xsd::cxx::tree::traits< ::DcpTestSuite::SendingPayloadField, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SendingPayloadField",
      "");
  }

  ::std::auto_ptr< ::DcpTestSuite::ReceivingPayloadField >
  ReceivingPayloadField_ (const ::std::string& u,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::DcpTestSuite::ReceivingPayloadField > (
      ::DcpTestSuite::ReceivingPayloadField_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::DcpTestSuite::ReceivingPayloadField >
  ReceivingPayloadField_ (const ::std::string& u,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::DcpTestSuite::ReceivingPayloadField > (
      ::DcpTestSuite::ReceivingPayloadField_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::DcpTestSuite::ReceivingPayloadField >
  ReceivingPayloadField_ (const ::std::string& u,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::DcpTestSuite::ReceivingPayloadField > (
      ::DcpTestSuite::ReceivingPayloadField_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::DcpTestSuite::ReceivingPayloadField >
  ReceivingPayloadField_ (::std::istream& is,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::DcpTestSuite::ReceivingPayloadField_ (isrc, f, p);
  }

  ::std::auto_ptr< ::DcpTestSuite::ReceivingPayloadField >
  ReceivingPayloadField_ (::std::istream& is,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::DcpTestSuite::ReceivingPayloadField_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::DcpTestSuite::ReceivingPayloadField >
  ReceivingPayloadField_ (::std::istream& is,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::DcpTestSuite::ReceivingPayloadField_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::DcpTestSuite::ReceivingPayloadField >
  ReceivingPayloadField_ (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::DcpTestSuite::ReceivingPayloadField_ (isrc, f, p);
  }

  ::std::auto_ptr< ::DcpTestSuite::ReceivingPayloadField >
  ReceivingPayloadField_ (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::DcpTestSuite::ReceivingPayloadField_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::DcpTestSuite::ReceivingPayloadField >
  ReceivingPayloadField_ (::std::istream& is,
                          const ::std::string& sid,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::DcpTestSuite::ReceivingPayloadField_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::DcpTestSuite::ReceivingPayloadField >
  ReceivingPayloadField_ (::xercesc::InputSource& i,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::DcpTestSuite::ReceivingPayloadField > (
      ::DcpTestSuite::ReceivingPayloadField_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::DcpTestSuite::ReceivingPayloadField >
  ReceivingPayloadField_ (::xercesc::InputSource& i,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::DcpTestSuite::ReceivingPayloadField > (
      ::DcpTestSuite::ReceivingPayloadField_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::DcpTestSuite::ReceivingPayloadField >
  ReceivingPayloadField_ (::xercesc::InputSource& i,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::DcpTestSuite::ReceivingPayloadField > (
      ::DcpTestSuite::ReceivingPayloadField_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::DcpTestSuite::ReceivingPayloadField >
  ReceivingPayloadField_ (const ::xercesc::DOMDocument& doc,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::DcpTestSuite::ReceivingPayloadField > (
        ::DcpTestSuite::ReceivingPayloadField_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ReceivingPayloadField" &&
        n.namespace_ () == "")
    {
      ::std::auto_ptr< ::DcpTestSuite::ReceivingPayloadField > r (
        ::xsd::cxx::tree::traits< ::DcpTestSuite::ReceivingPayloadField, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ReceivingPayloadField",
      "");
  }

  ::std::auto_ptr< ::DcpTestSuite::ReceivingPayloadField >
  ReceivingPayloadField_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "ReceivingPayloadField" &&
        n.namespace_ () == "")
    {
      ::std::auto_ptr< ::DcpTestSuite::ReceivingPayloadField > r (
        ::xsd::cxx::tree::traits< ::DcpTestSuite::ReceivingPayloadField, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ReceivingPayloadField",
      "");
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

